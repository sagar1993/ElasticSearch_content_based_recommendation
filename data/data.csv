,text,title,url
0,"These conventions are aimed to increase the readability and the comprehension of the Java Programming Wikibook. It completes the Wikibooks Manual of Style . However exceptions can be made if needed. If you find it too complex to follow, add the content rawly. It will be formatted by someone.",How to format the content ,https://en.wikibooks.org//wiki/Java_Programming/Conventions
1,Most of the time a page from the Java Programming Wikibook has a structure that looks like this:,How to format the content Page formatting,https://en.wikibooks.org//wiki/Java_Programming/Conventions
2,"Sometimes we wish to convey an entire java file, this can be done as follows:""1.1"" means that it is the first code of the first chapter. Using <source/> is better than using a template as || is a part of the Java syntax.",How to format the content Java file,https://en.wikibooks.org//wiki/Java_Programming/Conventions
3,"When just a small section of code is shown, the code template may be used as follows:",How to format the content Snippets,https://en.wikibooks.org//wiki/Java_Programming/Conventions
4,"To represent what is shown on the screen, use the following syntax:",How to format the content Screen print,https://en.wikibooks.org//wiki/Java_Programming/Conventions
5,Notes grant readers additional information about a certain topic. You can enter additional or side notes by using the following template:Use notes only when it is necessary. A note is less readable than paragraphs.,How to format the content Notes,https://en.wikibooks.org//wiki/Java_Programming/Conventions
6,"To warn the user of things like common pitfalls, the XWarning template should be used as demonstrated:",How to format the content Warning,https://en.wikibooks.org//wiki/Java_Programming/Conventions
7,"If there are sections of the book that require attention at a later time, you can add a to-do note by including the following template:",How to format the content To-do items,https://en.wikibooks.org//wiki/Java_Programming/Conventions
8,"If a section is optional, it can be hidden like this:",How to format the content Hidden section,https://en.wikibooks.org//wiki/Java_Programming/Conventions
9,"This book uses various illustrations and diagrams to convey its message, e.g., flow-chart or UML diagrams, etc. Due to the nature of diagrams, they need to be designed in a scalable vector format. It is highly recommended that you use the SVG format for your diagrams. Please, do not use JPG or PNG for diagrams that could otherwise be done in SVG. Ask a regular contributor for his/her help in this matter.A regular feature for diagrams used in this book is the overall color scheme. The most notable color used for illustrations in this book is   #2a7fff ( as is shown for the diagrams below, for instance ). In order to include illustrations into your content, you need to use the {{ Java/Illustration }} template. Given below is an example of how this template ought to be used.",How to format the content Illustrations and diagrams,https://en.wikibooks.org//wiki/Java_Programming/Conventions
10,"Use italic when you use a term for the first time.  Use the <code/> markup when you refer to a class, a field or a method.",How to format the content Text formatting,https://en.wikibooks.org//wiki/Java_Programming/Conventions
11,"This book uses United States English, purely for the sake of consistency. Most programming languages have words represented in the United States English, e.g., color , etc. You should use the US English wherever possible.",How to format the content Preferred English,https://en.wikibooks.org//wiki/Java_Programming/Conventions
12,"The Java Programming Wikibook is a shared effort in amassing a comprehensive guide of the complete Java platform  from programming advice and tutorials for the desktop computer to programming on mobile phones. The information presented in this book has been conceptualised with the combined efforts of various contributors , and anonymous editors.The primary purpose of this book is to teach the Java programming language to an audience of beginners, but its progressive layout of tutorials increasing in complexity, it can be just as helpful for intermediate and experienced programmers. Thus, this book is meant to be used as:a collection of tutorials building upon one another in a progressive manner;  a guidebook for efficient programming with the Java programming language; and,  a comprehensive manual resource for the advanced programmer.This book is intended to be used in conjunction with various other online resources, such as:the Java platform API documentation ;  the official Java website ; and,  active Java communities online, such as Java.net and JavaRanch , etc.",About this book ,https://en.wikibooks.org//wiki/Java_Programming/About_This_Book
13,"Everything you would need to know to write computer programs would be explained in this book. By the time you finish reading, you will find yourself proficient enough to tackle just about anything in Java and programs written using it. This book serves as the first few stepping stones of many you would need to cross the unfriendly waters of computer programming. We have put a lot of emphasis in structuring this book in a way that lets you start programming from scratch, with Java as your preferred language of choice. This book is designed for you if any one of the following is true.You are relatively new to programming and have heard how easy it is to learn Java.  You had some BASIC or Pascal in school, and have a grasp of basic programming and logic.  You already know and have been introduced to programming in earlier versions of Java.  You are an experienced developer and know how to program in other languages like C++ , Visual Basic , Python , Ruby , etc.  You've heard that Java is great for web applications and web services programming.Although this book is generally meant to be for readers who are beginning to learn programming, it can be highly beneficial for intermediate and advanced programmers who may have missed out on some vital information. After completing this book you should be able to solve many complicated problems using the Java skills presented in the following chapters. Once you finish, you are also encouraged to undertake ambitious programming projects of your own.This book assumes that the reader has no prior knowledge of programming in Java, or for that matter, any object-oriented programming language. Practical examples and exercises following each topic and module make it easy to understand the software development methodology.  If you are a complete beginner, we suggest that you move slowly through this book and complete each exercise at your own pace.",About this book Who should read this book?,https://en.wikibooks.org//wiki/Java_Programming/About_This_Book
14,"This book is a reference book of the Java language and its related technologies. Its goal is to give a complete picture of Java and its technologies.  While the book can be read from the beginning to end, it is also designed to have individual sections that can be read independently.  To help find information quickly, navigation boxes are given in the online version for access to individual topics.This book is divided to sections. Pages are grouped together into section topics. To make this book expandable in the future via the addition of new sections, the sections navigation-wide are independent from each other. Each section can be considered as a mini book by itself. Pages that belong to the same topic can be navigated by the links on the right hand side.",About this book How to use this book,https://en.wikibooks.org//wiki/Java_Programming/About_This_Book
15,"Content is constantly being updated and enhanced in this book as is the nature of wiki-based content. This book is therefore in a constant state of evolution. Any Wikibooks users can participate in helping this book to a better standard as both a reader, or a contributor.",About this book How can you participate,https://en.wikibooks.org//wiki/Java_Programming/About_This_Book
16,"If you are interested in reading the content present in this book, we encourage you to:share comments about the technical accuracy, content, or organization of this book by telling the contributors in the Discussion section for each page. You can find the link Discussion on each page in this book leading you to appropriate sections for discussion. Leave a signature when providing feedback, writing comments, or giving suggestion on the Discussion pages. This can be achieved by appending -- ~~~~ to your messages. Do not add your signatures to the Book pages, they are only meant for the Discussion pages.  share news about the Java Programming Wikibook with your family and friends and let them know about this comprehensive Java guide online.  become a contributing author, if you think that you have information that could fill in some missing gaps in this book.",About this book As a reader,https://en.wikibooks.org//wiki/Java_Programming/About_This_Book
17,"On 23 May 1995, John Gage , the director of the Science Office of the Sun Microsystems along with Marc Andreesen , co-founder and executive vice president at Netscape announced to an audience of SunWorld TM that Java technology wasn't a myth and that it was going to be incorporated into Netscape Navigator . [1]At the time the total number of people working on Java was less than 30. [1] This team would shape the future in the next decade and no one had any idea as to what was in store. From running an unmanned vehicle on Mars to serving as the operating environment of most consumer electronics, e.g. cable set-top boxes, VCRs, toasters and PDAs , [2] Java has come a long way from its inception. Let's see how it all began.",History of Java ,https://en.wikibooks.org//wiki/Java_Programming/History
18,"Before Java emerged as a programming language, C++ was the dominant player in the trade. The primary goal of the creators of Java was to create a language that could tackle most of the things that C++ offered while getting rid of some of the more tedious tasks that came with the earlier languages.Computer hardware went through a performance and price revolution from 1972 to 1991. Better, faster hardware was available at ever lower prices, and the demand for big and complex software exponentially increased. To accommodate the demand, new development technologies were invented.The C language developed in 1972 by Dennis Ritchie had taken a decade to become the most popular language amongst programmers working on PCs and similar platforms (other languages, like COBOL and FORTRAN , dominated the mainframe market). But, with time programmers found that programming in C became tedious with its structural syntax. [3] Although people attempted to solve this problem, it would be later that a new development philosophy was introduced, one named Object-Oriented Programming (OOP). With OOP, one can write code that can be reused later without needing to rewrite the code over and over again. In 1979, Bjarne Stroustrup developed C++, an enhancement to the C language with included OOP fundamentals and features. Sun generated revenue from Java through the selling of licenses for specialized products such as the Java Enterprise System .",History of Java Earlier programming languages,https://en.wikibooks.org//wiki/Java_Programming/History
19,"James Gosling , architect and designer of the compiler for the Java technologyIn December of 1990, a project was initiated behind closed doors with the aim to create a programming tool that could render obsolete the C and C++ programming languages. Engineer Patrick Naughton had become extremely frustrated with the state of Sun's C++ and C APIs ( Application Programming Interfaces ) and tools. While he was considering to move towards NeXT , he was offered a chance to work on new technology and the Stealth Project was started, a secret nobody but he knew.This Stealth Project was later named the Green Project when James Gosling and Mike Sheridan joined Patrick. [1] As the Green Project teethed, the prospects of the project started becoming clearer to the engineers working on it. No longer did it aim to create a new language far superior to the present ones, but it aimed to target devices other than the computer.Staffed at 13 people, they began work in a small office on Sand Hill Road in Menlo Park , California. This team came to be called the Green Team henceforth in time. The project they underwent was chartered by Sun Microsystems to anticipate and plan for the ""next wave"" in computing. For the team, this meant at least one significant trend, that of the convergence of digitally controlled consumer devices and computers. [1]",History of Java The Green team,https://en.wikibooks.org//wiki/Java_Programming/History
20,"The team started thinking of replacing C++ with a better version, a faster version, a responsive version. But the one thing they hadn't thought of, as of yet, was that the language they were aiming for had to be developed for an embedded system with limited resources. An embedded system is a computer system scaled to a minimalistic interface demanding only a few functions from its design. For such a system, C++ or any successor would seem too large as all the languages at the time demanded a larger footprint than what was desired. The team thus had to think in a different way to go about solving all these problems.Co-founder of Sun Microsystems, Bill Joy, envisioned a language combining the power of Mesa and C in a paper named Further he wrote for the engineers at Sun. Gathering ideas, Gosling began work on enhancing C++ and named it ""C++ ++ --"", a pun on the evolutionary structure of the language's name. The ++ and -- meant, putting in and taking out stuff . He soon abandoned the name and called it Oak [1] after the tree that stood outside his office.",History of Java Reshaping thought,https://en.wikibooks.org//wiki/Java_Programming/History
21,"By now, the work on Oak had been significant but come the year 1993, people saw the demise of set-top boxes, interactive TV and the PDAs. A failure that completely ushered the inventors' thoughts to be reinvented. Only a miracle could make the project a success now. And such a miracle awaited anticipation.National Center for Supercomputing Applications (NCSA) had just unveiled its new commercial web browser for the internet the previous year. The focus of the team, now diverted towards where they thought the ""next-wave"" of computing would be  the internet. The team then divulged into the realms of creating the same embeddable technology to be used in the web browser space calling it an applet  a small application . Keeping all of this in mind, the team created a list of features tackling the C++ problems. In their opinion, the project should.....be simple and gather tested fundamentals and features from the earlier languages in it,  ..have standard sets of APIs with basic and advanced features bundled with the language,  ..get rid of concepts requiring direct manipulation of hardware (in this case, memory) to make the language safe,  ..be platform independent and may written for every platform once (giving birth to the WORA idiom),  ..be able to manipulate network programming out-of-the-box,  ..be embeddable in web browsers, and...  ..have the ability for a single program to multi-task and do multiple things at the same time.The team now needed a proper identity and they decided on naming the new technology they created Java ushering a new generation of products for the internet boom. A by-product of the project was a cartoon named "" Duke "" created by Joe Parlang which became its identity then.Finally at the SunWorld TM conference, Andreesen unveiled the new technology to the masses. Riding along with the explosion of interest and publicity in the Internet, Java quickly received widespread recognition and expectations grew for it to become the dominant software for browser and consumer applications. [2]Initially Java was owned by Sun Microsystems, but later it was released to open source; the term Java was a trademark of Sun Microsystems. Sun released the source code for its HotSpot Virtual Machine and compiler in November 2006, and most of the source code of the class library in May 2007. Some parts were missing because they were owned by third parties, not by Sun Microsystems. The released parts were published under the terms of the GNU General Public License , a free software license.","History of Java The demise of an idea, birth of another",https://en.wikibooks.org//wiki/Java_Programming/History
22,"Unlike C and C++, Java's growth is pretty recent. Here, we'd quickly go through the development paths that Java took with age.Development of Java over the years. From version 1.0 to version 1.7, Java has displayed a steady growth.",History of Java Versions,https://en.wikibooks.org//wiki/Java_Programming/History
23,"Introduced in 1996 for the Solaris , Windows , Mac OS Classic and Linux , Java was initially released as the Java Development Kit 1.0 (JDK 1.0). This included the Java runtime (the virtual machine and the class libraries), and the development tools (e.g., the Java compiler). Later, Sun also provided a runtime-only package, called the Java Runtime Environment (JRE). The first name stuck, however, so usually people refer to a particular version of Java by its JDK version (e.g., JDK 1.0).",History of Java Initial Release (versions 1.0 and 1.1),https://en.wikibooks.org//wiki/Java_Programming/History
24,"Introduced in 1998 as a quick fix to the former versions, version 1.2 was the start of a new beginning for Java. The JDKs of version 1.2 and later versions are often called Java 2 as well. For example, the official name of JDK 1.4 is The Java(TM) 2 Platform, Standard Edition version 1.4 .Major changes include: Rewrite the event handling (add Event Listeners )  Change Thread synchronizations  Introduction of the JIT-Just in time compilers",History of Java Java 2 (version 1.2),https://en.wikibooks.org//wiki/Java_Programming/History
25,"Released in 8 May 2000. The most notable changes were:HotSpot JVM included (the HotSpot JVM was first released in April, 1999 for the J2SE 1.2 JVM)  RMI was modified to support optional compatibility with CORBA  JavaSound  Java Naming and Directory Interface (JNDI) included in core libraries (previously available as an extension)  Java Platform Debugger Architecture (JPDA)  Synthetic proxy classes",History of Java Kestrel (Java 1.3),https://en.wikibooks.org//wiki/Java_Programming/History
26,"Released in 6 February 2002, Java 1.4 has improved programmer productivity by expanding language features and available APIs:Assertion  Regular Expression  XML processing  Cryptography and Secure Socket Layer (SSL)  Non-blocking I/O (NIO)  Logging",History of Java Merlin (Java 1.4),https://en.wikibooks.org//wiki/Java_Programming/History
27,"Released in September 2004Major changes include: Generics - Provides compile-time type safety for collections :and eliminates the drudgery of casting.  Autoboxing/unboxing - Eliminates the drudgery of manual conversion between primitive types (such as int) and wrapper types (such as Integer).  Enhanced for - Shorten the for loop with Collections use.  Static imports - Lets you import all the static part of a class.  Annotation /Metadata - Enabling tools to generate code and deployment descriptors from annotations in the source code. This leads to a ""declarative"" programming style where the programmer says what should be done and tools emit the code to do it. Annotations can be inspected through source parsing or by using the additional reflection APIs added in Java 5.  JVM Improvements -  Most of the run time library is now mapped into memory as a memory image, as opposed to being loaded from a series of class files. Large portion of the runtime libraries will now be shared among multiple JVM instances.",History of Java Tiger (version 1.5.0; Java SE 5),https://en.wikibooks.org//wiki/Java_Programming/History
28,"Released on 11 December 2006.What's New in Java SE 6:Web Services - First-class support for writing XML web service client applications.Scripting - You can now mix in JavaScript technology source code, useful for prototyping. Also useful when you have teams with a variety of skill sets. More advanced developers can plug in their own scripting engines and mix their favorite scripting language in with Java code as they see fit.Database - No more need to find and configure your own JDBC database when developing a database application. Developers will also get the updated JDBC 4.0, a well-used API with many important improvements, such as special support for XML as an SQL datatype and better integration of Binary Large OBjects (BLOBs) and Character Large OBjects (CLOBs) into the APIs.More Desktop APIs - GUI developers get a large number of new tricks to play like the ever popular yet newly incorporated SwingWorker utility to help you with threading in GUI apps, JTable sorting and filtering, and a new facility for quick splash screens to quiet impatient users.Monitoring and Management - The really big deal here is that you don't need to do anything special to the startup to be able to attach on demand with any of the monitoring and management tools in the Java SE platform.Compiler Access - Really aimed at people who create tools for Java development and for frameworks like JavaServer Pages (JSP) or Personal Home Page construction kit (PHP) engines that need to generate a bunch of classes on demand, the compiler API opens up programmatic access to javac for in-process compilation of dynamically generated Java code. The compiler API is not directly intended for the everyday developer, but for those of you deafened by your screaming inner geek, roll up your sleeves and give it a try. And the rest of us will happily benefit from the tools and the improved Java frameworks that use this.Pluggable Annotations allows programmer to write annotation processor so that it can analyse your code semantically before javac compiles. For example, you could write an annotation processor that verifies whether your program obeys naming conventions.Desktop Deployment - At long last, Java SE 6 unifies the Java Plug-in technology and Java WebStart engines, which just makes sense. Installation of the Java WebStart application got a much needed makeover.Security - Java SE 6 has simplified the job of its security administrators by providing various new ways to access platform-native security services, such as native Public Key Infrastructure (PKI) and cryptographic services on Microsoft Windows for secure authentication and communication, Java Generic Security Services (Java GSS) and Kerberos services for authentication, and access to LDAP servers for authenticating users.The -lities: Quality, Compatibility, Stability - Bug fixes ...",History of Java Mustang (version 1.6.0; Java SE 6),https://en.wikibooks.org//wiki/Java_Programming/History
29,"Released on 28 July 2011.Feature additions for Java 7 include:JVM support for dynamic languages, following the prototyping work currently done on the Multi Language Virtual Machine  Compressed 64-bit pointers Available in Java 6 with -XX:+UseCompressedOops  Small language changes (grouped under a project named Coin):Strings in switch  Automatic resource management in try-statement  Improved type inference for generic instance creation  Simplified varargs method declaration  Binary integer literals  Allowing underscores in numeric literals  Catching multiple exception types and rethrowing exceptions with improved type checkingConcurrency utilities under JSR 166  New file I/O library to enhance platform independence and add support for metadata and symbolic links. The new packages are java.nio.file and java.nio.file.attribute  Library-level support for Elliptic curve cryptography algorithms  An XRender pipeline for Java 2D, which improves handling of features specific to modern GPUs  New platform APIs for the graphics features originally planned for release in Java version 6u10  Enhanced library-level support for new network protocols, including SCTP and Sockets Direct Protocol  Upstream updates to XML and UnicodeLambda (Java's implementation of lambda functions), Jigsaw (Java's implementation of modules), and part of Coin were dropped from Java 7.",History of Java Dolphin (version 1.7.0; Java SE 7),https://en.wikibooks.org//wiki/Java_Programming/History
30,"Java 8 was released on 18 March 2014, and included some features that were planned for Java 7 but later deferred.Work on features was organized in terms of JDK Enhancement Proposals (JEPs).JSR 335, JEP 126: Language-level support for lambda expressions (officially, lambda expressions; unofficially, closures) under Project Lambda which allow the addition of methods to interfaces without breaking existing implementations. There was an ongoing debate in the Java community on whether to add support for lambda expressions. Supporting lambda expressions also allows the performance of  functional-style operations on streams of elements, such as MapReduce-inspired transformations on collections. Default methods allow an author of an API to add new methods to an interface without breaking the old code using it. Although it was not their primary intent, default methods also allow multiple inheritance of behavior (but not state).JSR 223, JEP 174: Project Nashorn, a JavaScript runtime which allows developers to embed JavaScript code within applications  JSR 308, JEP 104: Annotation on Java Types  Unsigned Integer Arithmetic  JSR 337, JEP 120: Repeating annotations  JSR 310, JEP 150: Date and Time API  JEP 178: Statically-linked JNI libraries  JEP 153: Launch JavaFX applications (direct launching of JavaFX application JARs)  JEP 122: Remove the permanent generation",History of Java Spider (version 1.8.0; Java SE 8),https://en.wikibooks.org//wiki/Java_Programming/History
31,"The new features and upgrades included into Java changed the face of programming environment and gave a new definition to Object Oriented Programming ( OOP in short). But unlike its predecessors, Java needed to be bundled with standard functionality and be independent of the host platform.The primary goals in the creation of the Java language:It is simple.  It is object-oriented.  It is independent of the host platform.  It contains language facilities and libraries for networking.  It is designed to execute code from remote sources securely.The Java language introduces some new features that did not exist in other languages like C and C++.",Overview of the Java programming language ,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
32,"Object oriented programming can be represented with UML diagrams.Object orientation (""OO"") refers to a method of programming and language technique. The main idea of OO is to design software around the ""things"" (i.e. objects) it manipulates, rather than the actions it performs.As the hardware of the computer advanced, it brought about the need to create better software techniques to be able to create ever increasing complex applications.
The intent is to make large software projects easier to manage, thus improving quality and reducing the number of failed projects.
Object oriented solution is the latest software technique.Assembly languages  Software techniques started with the assembly languages, that were close to machine instruction and were easy to convert into executable code. Each hardware had its own assembly language. Assembly language contains low level instructions like move data from memory to hardware registers, do arithmetic operations, and move data back to memory. Programmers had to know the detailed architecture of the computer in order to write programs.Procedural languages  After the assembly languages, high level languages were developed. Here the language compiler is used to convert the high level program to machine instructions, freeing the programmers from the burden of knowing the computer hardware architecture. To promote the re-use of code and to minimize the use of GOTO instructions, ""procedural"" techniques were introduced. This simplified the creation and maintenance of software control flow, but left out the organization of data. It became a nightmare to debug and maintain programs having many global variables (i.e. variables that contain data that can be modified anywhere in the application).Object oriented languages  In OO languages, data is taken seriously with information hiding. Data that is specific to an object can only be accessed by procedures in that object. As a result, objects contain data as well as control flow and a program becomes a series of interactions between objects.",Overview of the Java programming language Object orientation,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
33,"In C or C++ programming, you start to write a source code:... you compile it to a machine code file:... and then you execute it:In this situation, the machine code file and its execution are specific to the platform (Windows, Linux, Mac OS, ...) it was compiled for, that is to say to the targeted platform :... because the compiled file is a machine code file designed to work on a specific platform and hardware. It would have produced a different results/output for another platform. So if you want your program to run on several platforms, you have to compile your program several times:It poses greater vulnerability risks. Note here that when a certain code is compiled into an executable format, the executable cannot be changed dynamically. It would need to be recompiled from the changed code for the changes to be reflected in the finished executable. Modularity (dividing code into modules) is not present in Java's predecessors. If instead of a single executable, the output application was in the form of modules, one could easily change a single module and review changes in the application. In C/C++ on the other hand, a slight change in code required the whole application to be recompiled.The idea of Java is to compile the source code into an intermediate language that will be interpreted.The intermediate language is the byte code . The interpreter is the Java Virtual Machine (JVM). The byte code file is universal and the JVM is platform specific:So a JVM should be coded for each platform. And that's the case. So you just have to generate a unique byte code file (a .class file).The first implementations of the language used an interpreted virtual machine to achieve portability, and many implementations still do. These implementations produce programs that run more slowly than the fully-compiled programs created by the typical C++ compiler, so the language suffered a reputation for producing slow programs. Since Java 1.2, Java VM produces programs that run much faster, using multiple techniques.The first of these is to simply compile directly into native code like a more traditional compiler, skipping bytecode entirely. This achieves great performance, but at the expense of portability. This is not really used any more.Another technique, the just-in-time (JIT) compiler, compiles the Java bytecode into native code at the time the program is run, and keep the compiled code to be used again and again.  More sophisticated VMs even use dynamic recompilation , in which the VM can analyze the behavior of the running program and selectively recompile and optimize critical parts of the program.  Both of these techniques allow the program to take advantage of the speed of native code without losing portability.Portability is a technically difficult goal to achieve, and Java's success at that goal is a matter of some controversy.  Although it is indeed possible to write programs for the Java platform that behave consistently across many host platforms, the large number of available platforms with small errors or inconsistencies led some to parody Sun's ""Write once, run anywhere"" slogan as ""Write once, debug everywhere"".",Overview of the Java programming language Platform dependence,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
34,"C++ was built atop the C language and as a result divergent ways of doing the same thing manifested around the language. For instance, creating an object could be done in three different ways in C++. Furthermore, C++ did not come with a standard library bundled with its compilers. Instead, it relied on resources created by other programmers; code which rarely fit together.In Java, standardized libraries are provided to allow access to features of the host machines (such as graphics and networking) in unified ways. The Java language also includes support for multi-threaded programsa necessity for many networking applications.Platform independent Java is, however, very successful with server side applications, such as web services, servlets, or Enterprise JavaBeans.Swing does not rely on the underlying native user interface.Java also made progress on the client side, first it had Abstract Window Toolkit (AWT), then Swing , and the most recent client side library is the Standard Widget Toolkit (SWT).
It is interesting to see how they tried to handle the two opposing consuming forces. Those are:Efficient, fast code; port to most popular hardware (write once, test anywhere)  Use the underlying native subroutine to create a GUI component. This approach was taken by AWT, and SWT.Portability to any hardware where JVM ported (write once, run anywhere)  To achieve this to the latter, the Java toolkit should not rely on the underlying native user interface. Swing took this approach.It is interesting to see how the approach was switched back and forth. AWT  Swing  SWT.",Overview of the Java programming language Standardization,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
35,"The segmentation fault, one of the most recurrent issues in C programming.With the high-level of control built into the language to manipulate hardware, a C/C++ programmer could access almost any resource, either hardware or software on the system. This was intended to be one of the languages' strong points, but this very flexibility led to confusion and complex programming practices.",Overview of the Java programming language Secure execution,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
36,"The old way of error handling was to let each function return an error code then let the caller check what was returned. The problem with this method was that if the return code was full of error-checking codes, this got in the way of the original one that was doing the actual work, which in turn did not make it very readable.In the new way of error handling, functions/methods do not return error codes. Instead, when there is an error, an exception is thrown. The exceptions can be handled by the catch keyword at the end of a try block.  This way, the code that is calling the function does not need to be mangled with error checking codes, thus making the code more readable. This new way of error handling is called Exception handling .Exception handling was also added to C++. However, there are two differences between Java and C++ Exception handling:In Java, the exception that is thrown is a Java object like any other object in Java. It only has to implement Throwable interface.  In Java, the compiler checks whether an exception may be caught or not. The compiler gives an error if there is no catch block for a thrown exception.The optional exception handling in the Java predecessors leads the developers not to care about the error handling. As a consequence, unexpected errors often occur. Java forces the developers to handle exceptions. The programmer must handle exception or declare that the user must handle it. Someone must handle it.",Overview of the Java programming language Error handling,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
37,"However powerful, the predecessors of Java lacked a standard feature to network with other computers, and usually relied on the platforms' intricate networking capabilities. With almost all network protocols being standardized, the creators of Java technology wanted this to be a flagship feature of the language while keeping true to the spirit of earlier advances made towards standardizing Remote Procedure Call . Another feature that the Java team focused on was its integration in the World Wide Web and the Internet.The Java platform was one of the first systems to provide wide support for the execution of code from remote sources. The Java language was designed with network computing in mind.An applet could run within a user's browser, executing code downloaded from a remote HTTP server. The remote code runs in a highly restricted ""sandbox"", which protects the user from misbehaving or malicious code; publishers could apply for a certificate that they could use to digitally sign applets as ""safe"", giving them permission to break out of the sandbox and access the local file system and network, presumably under user control.",Overview of the Java programming language Networking capabilities,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
38,"In conventional languages like C and C++, all code had to be compiled and linked to one executable program, before execution. In Java, classes are compiled as needed. If a class is not needed during an execution phase, that class is not even compiled into byte code.This feature comes in handy especially in network programming when we do not know, beforehand, what code will be executed. A running program could load classes from the file system or from a remote server.Also this feature makes it theoretically possible for a Java program to alter its own code during execution, in order to do some self-learning behavior. It would be more realistic to imagine, however, that a Java program would generate Java code before execution, and then, that code would be executed. With some feedback mechanism, the generated code could improve over time.",Overview of the Java programming language Dynamic class loading,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
39,"In conventional languages like C and C++, the programmer has to make sure that all memory that was allocated is freed. Memory leaks became a regular nuisance in instances where the programmers had to manually allocate the system's memory resources.Memory resources or buffers have specific modes of operation for optimal performance. Once a buffer is filled with data, it needs to be cleaned up after there is no further use for its content. If a programmer forgets to clean it in his/her code, the memory is easily overloaded. Programming in C/C++ languages became tedious and unsafe because of these very quirks, and programs built in these languages were prone to memory leakages and sudden system crashes  sometimes even harming the hardware itself. Freeing memory is particularly important in servers, since it has to run without stopping for days. If a piece of memory is not freed after use and the server just keeps allocating memory, that memory leak can take down the server.In Java, freeing up memory is taken out of the programmers hands; the Java Virtual Machine keeps track of all used memory. When memory is not used any more it is automatically freed up. A separate task is running in the background by the JVM, freeing up unreferenced, unused memory. That task is called the Garbage Collector .The Garbage Collector is always running. This automatic memory garbage collection feature makes it easy to write robust server side programs in Java. The only thing the programmer has to watch for is the speed of object creation. If the application is creating objects faster than the Garbage Collector can free them, it can cause memory problems. Depending on how the JVM is configured, the application either can run out of memory by throwing the NotEnoughMemoryException , or can halt to give time for the Garbage Collector to do its job.",Overview of the Java programming language Automatic memory garbage collection,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
40,The Java creators created the concept of the applet . A Java program can be run in a client browser program. Java was released in 1995; the time when the Internet was becoming more available and familiar to the general public. The promise of Java was in the client browser-side in that code would be downloaded and executed as a Java applet in the client browser program.See also Java Programming/Applets .,Overview of the Java programming language Applet,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
41,"Over the years, some features in C/C++ programming became abused by the programmers. Although the language allows it, it was known as bad practices. So the creators of Java have disabled them:Operator overloading  Multiple inheritance  Friend classes (access another object's private members)  Restrictions of explicit type casting (related to memory management)",Overview of the Java programming language Forbidden bad practices,https://en.wikibooks.org//wiki/Java_Programming/Java_Overview
42,"The Java platform is the name given to the computing platform from Oracle that helps users to run and develop Java applications. The platform does not just enable a user to run and develop a Java application, but also features a wide variety of tools that can help developers work efficiently with the Java programming language.The platform consists of two essential pieces of software:the Java Runtime Environment (JRE) , which is needed to run Java applications and applets; and,  the Java Development Kit (JDK) , which is needed to develop those Java applications and applets. If you have installed the JDK, you should know that it comes equipped with a JRE as well. So, for all the purposes of this book, you would only require the JDK.In this section, we will explore in further detail what these two software components of the Java platform do.",The Java platform (JRE & JDK) ,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
43,"Any piece of code written in the Java programming language can be run on any operating system, platform or architecture  in fact, it can be run on any device that supports the Java platform. Before Java, this amount of ubiquity was very hard to achieve. If a software was written for a Unix-based system, it was impossible to run the same application on a Windows system  in this case, the application was native only to Unix-based systems.A major milestone in the development of the Java programming language was to develop a special runtime environment that would execute any Java application independent of the computer's operating system, platform or architecture.The Java Runtime Environment (JRE) sits on top of the machine's operating system, platform and architecture. If and when a Java application is run, the JRE acts as a liaison between the underlying platform and that application. It interprets the Java application to run in accordance with the underlying platform, such that upon running the application, it looks and behaves like a native application. The part of the JRE that accomplishes this complex liaison agreement is called the Java Virtual Machine (JVM) .",The Java platform (JRE & JDK) Java Runtime Environment (JRE),https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
44,"Native Java applications are preserved in a special format called the byte-code . Byte-code remains the same, no matter what hardware architecture, operating system, or software platform it is running under. On a file-system, Java byte-code resides in files that have the .class (also known as a class file ) or the .jar (also known as a Java archive ) extension. To run byte-code, the JRE comes with a special tool (appropriately named java ).Suppose your byte-code is called SomeApplication.class . If you want to execute this Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):If you want to execute a Java byte-code with a .jar extension (say, SomeApplication.jar ), you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):",The Java platform (JRE & JDK) Executing native Java code (or byte-code),https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
45,"Most computers come with a pre-installed copy of the JRE. If your computer doesn't have a JRE, then the above commands would not work. You can always check what version of the JRE is installed on the computer by writing the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):",The Java platform (JRE & JDK) Do you have a JRE?,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
46,"Quite possibly, the most important part of the JRE is the Java Virtual Machine (JVM) . The JVM acts like a virtual processor, enabling Java applications to be run on the local system. Its main purpose is to interpret ( read translate) the received byte-code and make it appear as native code. The older Java architecture used this process of interpretation to execute Java byte-code. Even though the process of interpretation brought the WORA principle to diverse machines, it had a drawback  it consumed a lot of time and clocked the system processor intensively to load an application.",The Java platform (JRE & JDK) Java Virtual Machine (JVM),https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
47,"Since version 1.2, the JRE features a more robust JVM. Instead of interpreting byte-code, it down-right converts the code straight into equivalent native code for the local system. This process of conversion is called just-in-time compilation or JIT-compilation . This process only occurs when the byte-code is executed for the first time. Unless the byte-code itself is changed, the JVM uses the compiled version of the byte-code on every successive execution. Doing so saves a lot of time and processor effort, allowing applications to execute much faster at the cost of a small delay on first execution.",The Java platform (JRE & JDK) Just-in-Time Compilation,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
48,"The JVM is an intelligent virtual processor. It has the ability to identify areas within the Java code itself that can be optimized for faster and better performance. Based on every successive run of your Java applications, the JVM would optimize it to run even better.",The Java platform (JRE & JDK) Native optimization,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
49,"Java was not the first virtual-machine-based platform, though it is by far the most successful and well-known.  Previous uses for virtual machine technology primarily involved emulators to aid development for not-yet-developed hardware or operating systems, but the JVM was designed to be implemented entirely in software, while making it easy to efficiently port an implementation to hardware of all kinds.",The Java platform (JRE & JDK) Was JVM the first virtual machine?,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
50,"The JRE takes care of running the Java code on multiple platforms, however as developers, we are interested in writing pure code in Java which can then be converted into Java byte-code for mass deployment. As developers, we do not need to write Java byte-code; rather we write the code in the Java programming language (which is quite similar to writing C or C++ code).Upon downloading the JDK, a developer ensures that their system has the appropriate JRE and additional tools to help with the development of applications in the Java programming language. Java code can be found in files with the extension .java . These files are called Java source files . In order to convert the Java code in these source files to Java byte-code, you need to use the Java compiler tool installed with your JDK.",The Java platform (JRE & JDK) Java Development Kit (JDK),https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
51,"The Java compiler tool (named javac in the JDK) is the most important utility found with the JDK.  In order to compile a Java source file (say, SomeApplication.java ) to its respective Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):This command would convert the SomeApplication.java source file into its equivalent Java byte-code. The resultant byte-code would exist in a newly created file named SomeApplication.class . This process of converting Java source files into their equivalent byte-codes is known as compilation .A list of other JDK tools  There are a huge array of tools available with the JDK that will all be explained in due time as you progress with the book. These tools are briefly listed below in order of their usage:  Applet development [ edit ]  appletviewer  Java applets require a particular environment to execute. Typically, this environment is provided by a browser with a Java plug-in, and a web server serving the applet. However, during development and testing of an applet it might be more convenient to start an applet without the need to fiddle with a browser and a web server. In such a case, Oracle's appletviewer from the JDK can be used to run an applet.  Annotation processing [ edit ]  For more about annotation processing, read this  In Java 1.5 (alias Java 5.0) Oracle added a mechanism called annotations . Annotations allow the addition of meta-data to Java source code, and even provide mechanisms to carry that meta-data into compiled .class files.  apt  An annotation processing tool which digs through source code, finds annotation statements in the source code and executes actions if it finds known annotations. The most common task is to generate some particular source code. The actions apt performs when finding annotations in the source code are not hard-coded into apt. Instead, one has to code particular annotation handlers (in Java). These handlers are called annotation processors. It can also be described in a simple way without the Oracle terminology: apt can be seen as a source code preprocessor framework, and annotation processors are typically code generators.  Integration of non-Java and Java code [ edit ]  javah  A Java class can call native, or non-Java, code that has been prepared to be called from Java. The details and procedures are specified in the JNI (Java Native Interface). Commonly, native code is written in C (or C++). The JDK tool javah helps to write the necessary C code, by generating C header files and C stub code.  Class library conflicts [ edit ]  extcheck  It can be used prior to the installation of a Java extension into the JDK or JRE environment. It checks if a particular Jar file conflicts with an already installed extension. This tool appeared first with Java 1.5.  Software security and cryptography tools [ edit ]  The JDK comes with a large number of tools related to the security features of Java. Usage of these tools first requires study of the particular security mechanisms. The tools are:  keytool  To manage keys and certificates  jarsigner  To generate and verify digital signatures of JARs (Java ARchives)  policytool  To edit policy files  kinit  To obtain Kerberos v5 tickets  klist  To manage Kerberos credential cache and key table  ktab  To manage entries in a key table  The Java archiver [ edit ]  jar  (short for Java archiver) is a tool for creating Java archives or jar files  a file with .jar as the extension. A Java archive is a collection of compiled Java classes and other resources which those classes may require (such as text files, configuration files, images) at runtime. Internally, a jar file is really a .zip file .  The Java debugger [ edit ]  jdb  (short for Java debugger) is a command-line console that provides a debugging environment for Java programs. Although you can use this command line console, IDE's normally provide easier to use debugging environments.  Documenting code with Java [ edit ]  As programs grow large and complex, programmers need ways to track changes and to understand the code better at each step of its evolution. For decades, programmers have been employing the use of special programming constructs called comments  regions that help declare user definitions for a code snippet within the source code. But comments are prone to be verbose and incomprehensible, let alone be difficult to read in applications having hundreds of lines of code.  javadoc  Java provides the user with a way to easily publish documentation about the code using a special commenting system and the javadoc tool. The javadoc tool generates documentation about the Application Programming Interface (API) of a set of user-created Java classes. javadoc reads source file comments from the .java source files and generates HTML documents that are easier to read and understand without looking at the code itself.  javap  Where Javadoc provide a detailed view into the API and documentation of a Java class, the javap tool prints information regarding members (constructors, methods and variables) in a class. In other words, it lists the class' API and/or the compiled instructions of the class. javap is a formatting disassembler for Java bytecode.  The native2ascii tool [ edit ]  native2ascii is an important, though underappreciated, tool for writing properties files  files containing configuration data  or resource bundles  files containing language translations of text. Such files can contain only ASCII and Latin-1 characters, but international programmers need a full range of character sets. Text using these characters can appear in properties files and resource bundles only if the non-ASCII and non-Latin-^1 characters are converted into Unicode escape sequences (\uXXXX notation). The task of writing such escape sequences is handled by native2ascii . You can write the international text in an editor using the appropriate character encoding, then use native2ascii to generate the necessary ASCII text with embedded Unicode escape sequences. Despite the name, native2ascii can also convert from ASCII to native, so it is useful for converting an existing properties file or resource bundle back to some other encoding. native2ascii makes most sense when integrated into a build system to automate the conversion.  Remote Method Invocation (RMI) tools [ edit ]        To do: Add section    Java IDL and RMI-IIOP Tools [ edit ]        To do: Add section    Deployment & Web Start Tools [ edit ]        To do: Add section    Browser Plug-In Tools [ edit ]        To do: Add section    Monitoring and Management Tools / Troubleshooting Tools [ edit ]  With Java 1.5 a set of monitoring and management tools have been added to the JDK, in addition to a set of troubleshooting tools. The monitoring and management tools are intended for monitoring and managing the virtual machine and the execution environment. They allow, for example, monitoring memory usage during the execution of a Java program. The troubleshooting tools provide rather esoteric insight into aspects of the virtual machine. (Interestingly, the Java debugger is not categorized as a troubleshooting tool.) All the monitoring and management and troubleshooting tools are currently marked as ""experimental"" (which does not affect jdb). So they might disappear in future JDKs.",The Java platform (JRE & JDK) The Java compiler,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
52,"In most modern operating systems, a large body of reusable code is provided to simplify the programmer's job.  This code is typically provided as a set of dynamically loadable libraries that applications can call at runtime.  Because the Java platform is not dependent on any specific operating system, applications cannot rely on any of the existing libraries.  Instead, the Java platform provides a comprehensive set of standard class libraries, containing much of the same reusable functions commonly found in modern operating systems.The Java class libraries serve three purposes within the Java platform.  Like other standard code libraries, they provide the programmer with a well-known set of functions to perform common tasks, such as maintaining lists of items or performing complex string parsing.  In addition, the class libraries provide an abstract interface to tasks that would normally depend heavily on the hardware and operating system.  Tasks such as network access and file access are often heavily dependent on the native capabilities of the platform.  The Java java.net and java.io libraries implement the required native code internally, then provide a standard interface for the Java applications to perform those tasks.  Finally, some underlying platforms may not support all of the features a Java application expects.  In these cases, the class libraries can either emulate those features using whatever is available, or provide a consistent way to check for the presence of a specific feature.",The Java platform (JRE & JDK) Java class libraries (JCL),https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
53,"The success of the Java platform and the concepts of the write once, run anywhere principle has led to the development of similar frameworks and platforms. Most notable of these is the Microsoft's .NET framework and its open-source equivalent Mono .",The Java platform (JRE & JDK) Similar concepts,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
54,"The .NET framework borrows many of the concepts and innovations of Java  their alternative for the JVM is called the Common Language Runtime (CLR) , while their alternative for the byte-code is the Common Intermediate Language (CIL) . In fact, the .NET platform had an implementation of a Java-like language called Visual J# (formerly known as J++ ).J# is normally not supported with the JVM because instead of compiling it in Java byte-code, the .NET platform compiles the code into CIL, thus making J# different from the Java programming language. Furthermore, because J# implements the .NET Base Class Libraries (BCL) instead of the Java Class Libraries, J# is nothing more than a non-standard extension of the Java programming language. Due to the lack of interest from developers, Microsoft had to withdraw their support for J#, and focused on a similar programming language: C#.",The Java platform (JRE & JDK) The .NET framework,https://en.wikibooks.org//wiki/Java_Programming/The_Java_Platform
55,"In Java, programs are not compiled into executable files; they are compiled into bytecode (as discussed earlier ), which the JVM (Java Virtual Machine) then executes at runtime. Java source code is compiled into bytecode when we use the javac compiler. The bytecode gets saved on the disk with the file extension .class . When the program is to be run, the bytecode is converted, using the just-in-time (JIT) compiler. The result is machine code which is then fed to the memory and is executed.Java code needs to be compiled twice in order to be executed:Java programs need to be compiled to bytecode.  When the bytecode is run, it needs to be converted to machine code.The Java classes/bytecode are compiled to machine code and loaded into memory by the JVM when needed the first time. This is different from other languages like C/C++ where programs are to be compiled to machine code and linked to create an executable file before it can be executed.",Compiling programs ,https://en.wikibooks.org//wiki/Java_Programming/Compilation
56,"To execute your first Java program, follow the instructions below:Ask for help if the program did not execute properly in the Discussion page for this chapter .",Compiling programs Quick compilation procedure,https://en.wikibooks.org//wiki/Java_Programming/Compilation
57,"In Java, if you have used any reference to any other java object, then the class for that object will be automatically compiled, if that was not compiled already. These automatic  compilations are nested, and this continues until all classes are compiled that are needed to run the program. So it is usually enough to compile only the high level class, since all the dependent classes will be automatically compiled.However, you can't rely on this feature if your program is using reflection to create objects, or you are compiling for servlets or for a ""jar"", package. In these cases you should list these classes for explicit compilation.",Compiling programs Automatic Compilation of Dependent Classes,https://en.wikibooks.org//wiki/Java_Programming/Compilation
58,"Each Java top level class belongs to a package (covered in the chapter about Packages ). This may be declared in a package statement at the beginning of the file; if that is missing, the class belongs to the unnamed package.For compilation, the file must be in the right directory structure. A file containing a class in the unnamed package must be in the current/root directory; if the class belongs to a package, it must be in a directory with the same name as the package.The convention is that package names and directory names corresponding to the package consist of only lower case letters.","Compiling programs Packages, Subdirectories, and Resources",https://en.wikibooks.org//wiki/Java_Programming/Compilation
59,A class with this package declarationhas to be in a directory named example .,Compiling programs Top level package,https://en.wikibooks.org//wiki/Java_Programming/Compilation
60,"A class with this package declarationhas to be in a directory named en which has to be a sub-directory of wikibooks which in turn has to be a sub-directory of org resulting in org/wikibooks/en on Linux or org\wikibooks\en on Windows.Java programs often contain non-code files such as images and properties files. These are referred to generally as resources and stored in directories local to the classes in which they're used. For example, if the class com.example.ExampleApp uses the icon.png file, this file could be stored as /com/example/resources/icon.png . These resources present a problem when a program is compiled, because javac does not copy them to wherever the .class files are being compiled to (see above); it is up to the programmer to move the resource files and directories.",Compiling programs Subpackages,https://en.wikibooks.org//wiki/Java_Programming/Compilation
61,"The Java source file name must be the same as the public class name that the file contains. There can be only one public class defined per file.  The Java class name is case sensitive, as is the source file name.The naming convention for the class name is for it to start with a capital letter.",Compiling programs Filename Case,https://en.wikibooks.org//wiki/Java_Programming/Compilation
62,"To debug into Java system classes such as String and ArrayList, you need a special version of the JRE which is compiled with ""debug information"". The JRE included inside the JDK provides this info, but the regular JRE does not. Regular JRE does not include this info to ensure better performance.Modern compilers do a pretty good job converting your high-level code, with its nicely indented and nested control structures and arbitrarily typed variables into a big pile of bits called machine code (or bytecode in case of Java), the sole purpose of which is to run as fast as possible on the target CPU (virtual CPU of your JVM). Java code gets converted into several machine code instructions. Variables are shoved all over the place  into the stack, into registers, or completely optimized away. Structures and objects dont even exist in the resulting code  theyre merely an abstraction that gets translated to hard-coded offsets into memory buffers.So how does a debugger know where to stop when you ask it to break at the entry to some function? How does it manage to find what to show you when you ask it for the value of a variable? The answer is  debugging information.Debugging information is generated by the compiler together with the machine code. It is a representation of the relationship between the executable program and the original source code. This information is encoded into a pre-defined format and stored alongside the machine code. Many such formats were invented over the years for different platforms and executable files.Symbolic Information: Symbolic resolution is done at class loading time at linking resolution step.
It is the process of replacing symbolic references from the type with direct references. It is done by searching into method area to locate the referenced entity",Compiling programs Debugging and Symbolic Information,https://en.wikibooks.org//wiki/Java_Programming/Compilation
63,There are various ways in which Java code can be executed.  A complex Java application usually uses third party APIs or services. In this section we list the most popular ways a piece of Java code may be packed together and/or executed.,Running Java programs ,https://en.wikibooks.org//wiki/Java_Programming/Execution
64,"Java language first edition came out in the client-server era.  Thick clients were developed with rich GUI interfaces. Java first edition, JSE (Java Standard Edition) had/has the following in its belt:GUI capabilities (AWT, Swing)  Network computing capabilities ( RMI )  Multi-tasking capabilities (Threads)With JSE the following Java code executions are possible:Figure 1: Stand alone executionStand alone Java application  (Figure 1) Stand alone application refers to a Java program where both the user interface and business modules are running on the same computer.  The application may or may not use a database to persist data. The user interface could be either AWT or Swing.  The application would start with a main() method of a Class.  The application stops when the main() method exits, or if an exception is thrown from the application to the JVM. Classes are loaded to memory and compiled as needed, either from the file system or from a *.jar file, by the JVM.  Invocation of Java programs distributed in this manner requires usage of the command line.  Once the user has all the class files, he needs to launch the application by the following command line (where Main is the name of the class containing the main() method.)Java 'jar' class libraries  Utility classes, framework classes, and/or third party classes are usually packaged and distributed in Java ' *.jar' files.  These 'jar' files need to be put in the CLASSPATH of the java program from  which these classes are going to be used.  If a jar file is executable, it can be run from the command line:Client Server applications  The client server applications consist of a front-end, and a back-end part, each running on a separate computer. The idea is that the business logic would be on the back-end part of the program, which would be reused by all the clients. Here the challenge is to achieve a separation between front-end user interface code, and the back-end business logic code.  The communication between the front-end and the back-end can be achieved by two ways. One way is to define a data communication protocol between the two tiers. The back-end part would listen for an incoming request. Based on the protocol it interprets the request and sends back the result in data form.  The other way is to use Java Remote Invocation (RMI). With the use of RMI, a remote object can be created and used by the client.  In this case Java objects are transmitted across the network.  More information can be found about client-server programming, with sample code, at the Client Server Chapter in this book.Web Applications  For applications needed by lots of client installations, the client-server model did not work. Maintaining and upgrading the hundreds or thousands of clients caused a problem. It was not practical. The solution to this problem was to create a unified, standard client, for all applications, and that is the Browser .  Having a standard client, it makes sense to create a unified, standard back-end service as well, and that is the Application Server .  Web Application is an application that is running in the Application Server , and it can be accessed and used by the Browser client.  There are three main area of interest in Web Applications, those are: The Web Browser . This is the container of rendering HTML text, and running client scripts  The HTTP  protocol . Text data are sent back and forth between Browser and the Server  The Web server to serve static content, Application server to serve dynamic content and host EJBs .  Wikipedia also has an article about Web application .",Running Java programs JSE code execution,https://en.wikibooks.org//wiki/Java_Programming/Execution
65,"As the focus was shifting from reaching GUI clients to thin client applications, with Java version 2, Sun introduced J2EE (Java 2 Extended Edition). J2EE added:Components Base Architecture , (Servlet, JSP, EJB Containers)With J2EE the following Java component executions are possible:Figure 2: Servlet ExecutionJava Servlet code  (Figure 2) Java got its popularity with server side programming, more specifically with J2EE servlets. Servlets are running in a simple J2EE framework to handle client HTTP requests. They are meant to replace CGI programming for web pages rendering dynamic content.  The servlet is running in a so called servlet-container/web container . The servlet's responsibility is to: Handle the request by doing the business logic computation,  Connecting to a database if needed,  Create HTML to present to the user through the browser  The HTML output represents both the presention logic and the results of the business computations.  This represents a huge problem, and there is no real application relying only on servlets to handle the presention part of the responsibility. There are two main solutions to this: Use a template tool (Store the presentation part in an HTML file, marking the areas that need to be replaced after business logic computations).  Use JSP (See next section)  Wikipedia also has an article about Servlets .Figure 3: Jsp ExecutionJava Server Pages (JSP) code  (Figure 3) JSP is an HTML file with embedded Java code inside.  The first time the JSP is accessed, the JSP is converted to a Java Servlet. This servlet outputs HTML which has inside the result of the business logic computation. There are special JSP tags that helps to add data dynamically to the HTML. Also JSP technology allows to create custom tags.  Using the JSP technology correctly, business logic computations should not be in the embedded Java part of the JSP. JSP should be used to render the presentation of the static and dynamic data. Depending on the complexity of the data, 100% separation is not easy to achieve. Using custom tags, however may help to get closer to 100%. This is advocated also in MVC architecture (see below).Figure 4: EJB ExecutionEJB code  (Figure 4) In the 1990s, with the client server computing, a trend started, that is to move away from Mainframe computing. That resulted in many small separate applications in a Company/Enterprise. Many times the same data was used in different applications. A new philosophy, ""Enterprise Computing"", was created to address these issues.  The idea was to create components that can be reused throughout the Enterprise. The Enterprise Java Beans (EJBs) were supposed to address this.  An EJB is an application component that runs in an EJB container. The client accesses the EJB modules through the container, never directly.  The container manages the life cycle of the EJB modules, and handles all the issues that arise from network/enterpise computing. Some of those are security/access control , object pooling , transaction management , ... .  EJBs have the same problems as any reusable code: they need to be generic enough to be able to be reused and the changes or maintenance of EJBs can affect existing clients. Many times EJBs are used unnecessarily when they are not really needed. An EJB should be designed as a separate application in the enterprise, fulfilling one function.Figure 5: MVC ExecutionCombine J2EE components to create an MVC architecture  This leads us to the three layers/tiers as shown in (Figure 5).  In modern web applications, with lots of static data and nice graphics, how the data is presented to the user became very important and usually needs the help of a graphic artist.  To help programmers and graphic artists to work together, the separation between data, code, and how it is presented became crucial.   The view (User Interface Logic) contains the logic that is necessary to construct the presentation.  This could be handled by JSP technology.  The servlet acts as the controller and contains the logic that is necessary to process user events and to select an appropriate response.  The business logic ( model ) actually accomplishes the goal of the interaction. This might be a query or an update to a database.  This could be handled by EJB technology.  For more information about MVC, please see MVC .",Running Java programs J2EE code execution,https://en.wikibooks.org//wiki/Java_Programming/Execution
66,"This article presents a small Java program which can be run from the console. It computes the distance between two points on a plane. You do not need to understand the structure and meaning of the program just yet; we will get to that soon. Also, because the program is intended as a simple introduction, it has some room for improvement, and later in the module we will show some of these improvements. But let's not get too far ahead of ourselves!",Understanding a Java program ,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
67,"This class is named Distance , so using your favorite editor or Java IDE , first create a file named Distance.java , then copy the source below, paste it into the file and save the file.At this point, you may wish to review the source to see how much you might be able to understand. While perhaps not being the most literate of programming languages, someone with understanding of other procedural languages such as C, or other object oriented languages such as C++ or C#, will be able to understand most if not all of the sample program.Once you save the file, compile the program:(If the javac command fails, review the installation instructions .)To run the program, you supply it with the x and y coordinates of two points on a plane separated by a space. For this version of Distance, only integer points are supported. The command sequence is java Distance <x 0 > <y 0 > <x 1 > <y 1 > to compute the distance between the points ( x 0 , y 0 ) and ( x 1 , y 1 ).Here are two examples:We'll explain this strange looking output, and also show how to improve it, later.","Understanding a Java program The Distance Class: Intent, Source, and Use",https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
68,"As promised, we will now provide a detailed description of this Java program. We will discuss the syntax and structure of the program and the meaning of that structure.",Understanding a Java program Detailed Program Structure and Overview,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
69,"Figure 2.1 : Basic Java syntax. For a further treatment of the syntax elements of Java, see also Syntax .The syntax of a Java class is the characters, symbols and their structure used to code the class. Java programs consist of a sequence of tokens. There are different kinds of tokens. For example, there are word tokens such as class and public which represent keywords  (in purple  above )  special words with reserved meaning in Java. Other words such as Distance , point0 , x1 , and printDistance are not keywords but identifiers (in grey) . Identifiers have many different uses in Java but primarily they are used as names. Java also has tokens to represent numbers, such as 1 and 3 ; these are known as literals  (in orange) . String literals  (in blue) , such as ""Distance between "" , consist of zero or more characters embedded in double quotes, and operators  (in red) such as + and = are used to express basic computation such as addition or String concatenation or assignment. There are also left and right braces ( { and } ) which enclose blocks . The body of a class is one such block. Some tokens are punctuation, such as periods . and commas , and semicolons ; . You use whitespace such as spaces, tabs, and newlines, to separate tokens. For example, whitespace is required between keywords and identifiers: publicstatic is a single identifier with twelve characters, not two Java keywords.",Understanding a Java program Introduction to Java Syntax,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
70,"public class Distance {    private java.awt.Point point0, point1;       public Distance(int x0, int y0, int x1, int y1) {  point0 = new java.awt.Point(x0, y0);  point1 = new java.awt.Point(x1, y1);  }       public void printDistance() {  System.out.println(""Distance between "" + point0 + "" and "" + point1  + "" is "" + point0.distance(point1));  }       public static void main(String[] args) {  Distance dist = new Distance(  intValue(args[0]), intValue(args[1]),  intValue(args[2]), intValue(args[3]));  dist.printDistance();  }       private static int intValue(String data) {  return Integer.parseInt(data);  }     }Figure 2.2 : Declarations and Definitions.Sequences of tokens are used to construct the next building blocks of Java classes as shown above : declarations and definitions. A class declaration provides the name and visibility of a class. In our example, public class Distance is the class declaration. It consists (in this case) of two keywords, public and class followed by the identifier Distance .This means that we are defining a class named Distance . Other classes, or in our case, the command line, can refer to the class by this name. The public keyword is an access modifier which declares that this class and its members may be accessed from other classes. The class keyword, obviously, identifies this declaration as a class. Java also allows declarations of interfaces and annotations .The class declaration is then followed by a block (surrounded by curly braces) which provides the class's definition (in blue in figure 2.2 ) . The definition is the implementation of the class  the declaration and definitions of the class's members. This class contains exactly six members, which we will explain in turn.Two field declarations, named point0 and point1  (in green)  A constructor declaration (in orange)  Three method declarations (in red)",Understanding a Java program Declarations and Definitions,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
71,"The declaration...declares two instance fields . Instance fields represent named values that are allocated whenever an instance of the class is constructed. When a Java program creates a Distance instance, that instance will contain space for point0 and point1 . When another Distance object is created, it will contain space for its own  point0 and point1 values. The value of point0 in the first Distance object can vary independently of the value of point0 in the second Distance object.This declaration consists of:The private access modifier, which means these instance fields are not visible to other classes.  The type of the instance fields. In this case, the type is java.awt.Point . This is the class Point in the java.awt package.  The names of the instance fields in a comma separated list.These two fields could also have been declared with two separate but more verbose declarations,Since the type of these fields is a reference type (i.e. a field that refers to or can hold a reference to an object value), Java will implicitly initialize the values of point0 and point1 to null when a Distance instance is created. The null value means that a reference value does not refer to an object. The special Java literal null is used to represent the null value in a program. While you can explicitly assign null values in a declaration, as inIt is not necessary and most programmers omit such default assignments.",Understanding a Java program Example: Instance Fields,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
72,"A constructor is a special method in a class which is used to construct an instance of the class. The constructor can perform initialization for the object, beyond that which the Java VM does automatically. For example, Java will automatically initialize the fields point0 and point1 to null.The constructor above consists of five parts:The optional access modifier(s) . In this case, the constructor is declared public  The constructor name, which must match the class name exactly: Distance in this case.  The constructor parameters. The parameter list is required. Even if a constructor does not have any parameters, you must specify the empty list () . The parameter list declares the type and name of each of the method's parameters.  An optional throws clause which declares the exceptions that the constructor may throw. This constructor does not declare any exceptions.  The constructor body, which is a Java block (enclosed in {} ).  This constructor's body contains two statements.This constructor accepts four parameters, named x0, y0, x1 and y1 . Each parameter requires a parameter type declaration, which in this example is int for all four parameters. The parameters in the parameter list are separated by commas.The two assignments in this constructor use Java's new operator to allocate two java.awt.Point objects. The first allocates an object representing the first point, (x0, y0) , and assigns it to the point0 instance variable (replacing the null value that the instance variable was initialized to). The second statement allocates a second java.awt.Point instance with (x1, y1) and assigns it to the point1 instance variable.This is the constructor for the Distance class. Distance implicitly extends from java.lang.Object . Java inserts a call to the super constructor as the first executable statement of the constructor if there is not one explicitly coded. The above constructor body is equivalent to the following body with the explicit super constructor call:While it is true that this class could be implemented in other ways, such as simply storing the coordinates of the two points and computing the distance as       (   x   1       x   0     )   2    +  (   y   1       y   0     )   2        {\displaystyle {\sqrt {(x_{1}-x_{0})^{2}+(y_{1}-y_{0})^{2}}}}   , this class instead uses the existing java.awt.Point class. This choice matches the abstract definition of this class: to print the distance between two points on the plane. We take advantage of existing behavior already implemented in the Java platform rather than implementing it again. We will see later how to make the program more flexible without adding much complexity, because we choose to use object abstractions here. However, the key point is that this class uses information hiding. That is, how the class stores its state or how it computes the distance is hidden. We can change this implementation without altering how clients use and invoke the class.",Understanding a Java program Example: Constructor,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
73,"Methods are the third and most important type of class member. This class contains three methods in which the behavior of the Distance class is defined: printDistance() , main() , and intValue()",Understanding a Java program Example: Methods,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
74,"The printDistance() method prints the distance between the two points to the standard output (normally the console).This instance method executes within the context of an implicit Distance object. The instance field references, point0 and point1 , refer to instance fields of that implicit object. You can also use the special variable this to explicitly reference the current object. Within an instance method, Java binds the name this to the object on which the method is executing, and the type of this is that of the current class. The body of the printDistance method could also be coded asto make the instance field references more explicit.This method both computes the distance and prints it in one statement. The distance is computed with point0.distance(point1) ; distance() is an instance method of the java.awt.Point class (of which point0 and point1 are instances). The method operates on point0 (binding this to the object that point0 refers to during the execution of the method) and accepting another Point as a parameter. Actually, it is slightly more complicated than that, but we'll explain later. The result of the distance() method is a double precision floating point number.This method uses the syntaxto construct a String to pass to the System.out.println() . This expression is a series of String concatenation methods which concatenates Strings or the String representation of primitive types (such as doubles) or objects, and returns a long string. For example, the result of this expression for the points (0,3) and (4,0) is the Stringwhich the method then prints to System.out .In order to print, we invoke the println() . This is an instance method from java.io.PrintStream , which is the type of the static field out in the class java.lang.System . The Java VM binds System.out to the standard output stream when it starts a program.",Understanding a Java program The printDistance() method,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
75,"The main() method is the main entry point which Java invokes when you start a Java program from the command line. The commandinstructs Java to locate the Distance class, put the four command line arguments into an array of String values, then pass those arguments to the public static main(String[]) method of the class. We will introduce arrays shortly. Any Java class that you want to invoke from the command line or desktop shortcut must have a main method with this signature or the following signature: public static main(String...) .The main() method invokes the final method, intValue() , four times. The intValue() takes a single string parameter and returns the integer value represented in the string. For example, intValue(""3"") will return the integer 3.People who do test-first programming or perform regression testing
write
a main() method in every Java class, and
a main() function in every Python module ,
to run automated tests.
When a person executes the file directly,
the main() method executes and runs the automated tests for that file.
When a person executes some other Java file
that in turn imports many other Java classes,
only one main() method is executed --
the main() method of the directly-executed file.",Understanding a Java program The main() method,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
76,"The intValue() method delegates its job to the Integer.parseInt() method. The main method could have called Integer.parseInt() directly; the intValue() method simply makes the main() method slightly more readable.This method is private since, like the fields point0 and point1 , it is part of the internal implementation of the class and is not part of the external programming interface of the Distance class.",Understanding a Java program The intValue() method,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
77,"Both the main() and intValue() methods are static methods . The static keyword tells the compiler to create a single memory space associated with the class.  Each individual object instantiated has its own private state variables and methods but use the same static methods and members common to the single class object created by the compiler when the first class object is instantiated or created.  This means that the method executes in a static or non-object context  there is no implicit separate instance available when the static methods run from various objects, and the special variable this is not available. As such, static methods cannot access instance methods or instance fields (such as printDistance() ) or point0 ) directly. The main() method can only invoke the instance method printDistance() method via an instance reference such as dist .",Understanding a Java program Static vs. Instance Methods,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
78,"Most declarations have a data type. Java has several categories of data types: reference types, primitive types, array types, and a special type, void.",Understanding a Java program Data Types,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
79,"The primitive types are used to represent boolean, character, and numeric values. This program uses only one primitive type explicitly, int , which represents 32 bit signed integer values. The program also implicitly uses double , which is the return type of the distance() method of java.awt.Point . double values are 64 bit IEEE floating point values. The main() method uses integer values 0, 1, 2, and 3 to access elements of the command line arguments. The Distance() constructor's four parameters also have the type int . Also, the intValue() method has a return type of int . This means a call to that method, such as intValue(args[0]) , is an expression of type int . This helps explain why the main method cannot call:Since the type of the args array element is String, and our constructor's parameters must be int , such a call would result in an error because Java will not automatically convert values of type String into int values.Java's primitive types are boolean , byte , char , short , int , long , float and double . Each of which are also Java language keywords.",Understanding a Java program Primitive Types,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
80,"In addition to primitive types, Java supports reference type . A reference type is a Java data type which is defined by a Java class or interface. Reference types derive this name because such values refer to an object or contain a reference to an object. The idea is similar to pointers in other languages like C.Java represents sequences of character data, or String , with the reference type java.lang.String which is most commonly referred to as String . String literals , such as ""Distance between "" are constants whose type is String.This program uses three separate reference types:java.lang.String (or simply String)  Distance  java.awt.PointFor more information see chapter: Java Programming/Classes, Objects and Types .",Understanding a Java program Reference Types,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
81,"Java supports arrays , which are aggregate types which have a fixed element type (which can be any Java type) and an integral size. This program uses only one array, String[] args . This indicates that args has an array type and that the element type is String . The Java VM constructs and initializes the array that is passed to the main method. See arrays for more details on how to create arrays and access their size.The elements of arrays are accessed with integer indices. The first element of an array is always element 0. This program accesses the first four elements of the args array explicitly with the indices 0, 1, 2, and 3. This program does not perform any input validation, such as verifying that the user passed at least four arguments to the program. We will fix that later.",Understanding a Java program Array Types,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
82,void is not a type in Java; it represents the absence of a type. Methods which do not return values are declared as void methods .This class defines two void methods:,Understanding a Java program void,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
83,"Whitespace in Java is used to separate the tokens in a Java source file. Whitespace is required in some places, such as between access modifiers , type names and Identifiers, and is used to improve readability elsewhere.Wherever whitespace is required in Java, one or more whitespace characters may be used. Wherever whitespace is optional in Java, zero or more whitespace characters may be used.Java whitespace consists of thespace character ' ' (0x20),  the tab character (hex 0x09),  the form feed character (hex 0x0c),  the line separators characters newline (hex 0x0a) or carriage return (hex 0x0d) characters.Line separators are special whitespace characters in that they also terminate line comments, whereas normal whitespace does not.Other Unicode space characters, including vertical tab, are not allowed as whitespace in Java.",Understanding a Java program Whitespace,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
84,"Look at the static method intValue :Whitespace is required between private and static , between static and int , between int and intValue , and between String and data .If the code is written like this:...it means something completely different: it declares a method which has the return type privatestaticint It is unlikely that this type exists and the method is no longer static, so the above would result in a semantic error.",Understanding a Java program Required Whitespace,https://en.wikibooks.org//wiki/Java_Programming/Understanding_a_Java_Program
85,"A Java IDE (for Integrated Development Environment ) is a software application which enables users to more easily write and debug Java programs. Many IDEs provide features like syntax highlighting and code completion, which help the user to code more easily.",Java IDEs What is a Java IDE?,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
86,"Eclipse on UbuntuEclipse is a Free and Open Source IDE, plus a developer tool framework that can be extended for a particular development need. IBM was behind its development, and it replaced IBM VisualAge tool. The idea was to create a standard look and feel that can be extended via plugins. The extensibility distinguishes Eclipse from other IDEs. Eclipse was also meant to compete with Microsoft Visual Studio tools. Microsoft tools give a standard way of developing code in the Microsoft world. Eclipse gives a similar standard way of developing code in the Java world, with a big success so far. With the online error checking only, coding can be sped up by at least 50% (coding does not include programming).The goals for Eclipse are twofold:Give a standard IDE for developing code  Give a starting point, and the same look and feel for all other more sophisticated tools built on EclipseIBM's WSAD, and later IBM Rational Software Development Platform, are built on Eclipse.Standard Eclipse features:Standard window management (perspectives, views, browsers, explorers, ...)  Error checking as you type (immediate error indications, ...)  Help window as you type (type ., or <ctrl>  space , ...)  Automatic build (changes in source code are automatically compiled, ...)  Built-in debugger (full featured GUI debugger)  Source code generation (getters and setters, ...)  Searches (for implementation, for references, ...)  Code refactoring (global reference update, ...)  Plugin-based architecture (ability to build tools that integrate seamlessly with the environment, and some other tools)  ...More info: Eclipse and Plugincentral .",Java IDEs Eclipse,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
87,"NetBeans on GNU/LinuxThe NetBeans IDE is a Free and Open Source IDE for software developers. The IDE runs on many platforms including Windows, GNU/Linux, Solaris and Mac OS X. It is easy to install and use straight out of the box. You can easily create Java applications for mobile devices using Mobility Pack in NetBeans. With Netbeans 6.0, the IDE has become one of the most preferred development tools, whether it be designing a Swing UI, building a mobile application, an enterprise application or using it as a platform for creating your own IDE.More info: netbeans.org",Java IDEs NetBeans,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
88,"JCreator is a simple and lightweight JAVA IDE from XINOX Software. It runs only on Windows platforms. It is very easy to install and starts quickly, as it is a native application. This is a good choice for beginners.More info: http://www.apcomputerscience.com/ide/jcreator/index.htm or JCreator",Java IDEs JCreator,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
89,"Processing is an enhanced IDE. It adds some extra commands and a simplified programming model. This makes it much easier for beginners to start programming in Java. It was designed to help graphic artists learn a bit of programming without struggling too much. Processing runs on Windows, GNU/Linux and Mac OS X platforms.More info: Processing .",Java IDEs Processing,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
90,"BlueJ on Mac OS XBlueJ is an IDE that includes templates and will compile and run the applications for you. BlueJ is often used by classes because it is not necessary to set classpaths. BlueJ has its own sets of libraries and you can add your own under preferences. That sets the classpath for all compilations that come out of it to include those you have added and the BlueJ libraries.BlueJ offers an interesting GUI for creation of packages and programs. Classes are represented as boxes with arrows running between them to represent inheritance/implementation or if on is constructed in another. The source code is generated by the UML diagram or vice-versa. BlueJ adds all those classes (the project) into the classpath at compile time.By default it doesn't display the line numbers, so this should be ticked into Options\Preferences...More info: BlueJ Homesite",Java IDEs BlueJ,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
91,"Kawa is basically a Java editor developed by Tek-Tools. It does not include wizards and GUI tools, best suited to experienced Java programmers in small and midsized development teams. It looks that there is no new development for Kawa.See also a javaworld article",Java IDEs Kawa,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
92,"JBuilder is an IDE with proprietary source code, sold by Embarcadero Technologies. One of the advantages is the integration with Together, a modeling tool.More info: Embarcadero .",Java IDEs JBuilder,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
93,DrJava is an IDE developed by the JavaPLT group at Rice University. It is designed for students.For more information see DrJava .,Java IDEs DrJava,https://en.wikibooks.org//wiki/Java_Programming/Java_IDEs
94,"Now that we have the Java platform on our systems and have run the first program successfully, we are geared towards understanding how programs are actually made. As we have already discussed, a program is a set of instructions, which are tasks provided to a computer. These instructions are called statements in Java. Statements can be anything from a single line of code to a complex mathematical equation. Consider the following line:This line is a simple instruction that tells the system to initialize a variable and set its value as 24. If the above statement was the only one in the program, it would look similar to this:Java places its statements within a class declaration and, in the class declaration, the statements are usually placed in a method declaration, as above.",Statements ,https://en.wikibooks.org//wiki/Java_Programming/Statements
95,"The simplest statement is a variable declaration:It defines a variable that can be used to store values for later use. The first token is the data type of the variable (which type of values this variable can store). The second token is the name of the variable, by which you will be referring to it. Then each declaration statement is ended by a semicolon ( ; ).",Statements Variable declaration statement,https://en.wikibooks.org//wiki/Java_Programming/Statements
96,"Up until now, we've assumed the creation of variables as a single statement. In essence, we assign a value to those variables, and that's just what it is called. When you assign a value to a variable in a statement, that statement is called an assignment statement (also called an initialization statement ). Did you notice one more thing? It's the semicolon ( ; ), which is at the end of each statement. A clear indicator that a line of code is a statement is its termination with an ending semicolon. If one was to write multiple statements, it is usually done with each statement on a separate line ending with a semicolon. Consider the example below:You do not necessarily have to use a new line to write each statement. Just like English, you can begin writing the next statement where you ended the first one as depicted below:However, the only problem with putting multiple statements on one line is, it's very difficult to read it. It doesn't look that intimidating at first, but once you've got a significant amount of code, it's usually better to organize it in a way that makes sense. It would look more complex and incomprehensible written as it is in Listing 3.4.Now that we have looked into the anatomy of a simple assignment statement, we can look back at what we've achieved. We know that...A statement is a unit of code in programming.  If we are assigning a variable a value, the statement is called an assignment statement.  An assignment statement includes three parts: a data type, the variable name (also called the identifier) and the value of a variable. We will look more into the nature of identifiers and values in the section Variables later.Now, before we move on to the next topic, you need to try and understand what the code below does.The first two statements are pretty much similar to those in Section 3.3 but with different variable names. The third however is a bit interesting. We've already talked of variables as being similar to gift boxes. Think of your computer's memory as a shelf where you put all those boxes. Whenever you need a box (or variable), you call its identifier (that's the name of the variable). So calling the variable identifier firstNumber gives you the number 10 , calling secondNumber would give you 20 hence when you add the two up, the answer should be 30 . That's what the value of the last variable result would be. The part of the third statement where you add the numbers, i.e., firstNumber + secondNumber is called an expression and the expression is what decides what the value is to be. If it's just a plain value, like in the first two statements, then it's called a literal (the value is literally the value, hence the name literal ).Note that after the assignment to result its value will not be changed if we assign different values to firstNumber or secondNumber , like in line 5.With the information you have just attained, you can actually write a decent Java program that can sum up values.",Statements Assignment statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
97,"An assertion checks if a condition is true:Each assert statement is ended by a semi-colon ( ; ). However, assertions are disabled by default, so you must run the program with the -ea argument in order for assertions to be enabled ( java -ea [name of compiled program] ).",Statements Assertion,https://en.wikibooks.org//wiki/Java_Programming/Statements
98,"Statements are evaluated in the order as they occur. The execution of flow begins at the top most statement and proceed downwards till the last statement is encountered. A statement can be substituted by a statement block. There are special statements that can redirect the execution flow based on a condition, those statements are called branching statements, described in detail in a later section.",Statements Program Control Flow,https://en.wikibooks.org//wiki/Java_Programming/Statements
99,"A bunch of statements can be placed in braces to be executed as a single block. Such a block of statements can be named
or be provided with a condition for execution. Below is how you'd place a series of statements in a block.",Statements Statement Blocks,https://en.wikibooks.org//wiki/Java_Programming/Statements
100,"Program flow can be affected using function/method calls, loops and iterations. Of various types of branching constructs,
we can easily pick out two generic branching methods.Unconditional Branching  Conditional Branching",Statements Branching Statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
101,"If you look closely at a method, you'll see that a method is a named statement block that is executed by calling that particular name. An unconditional branch is created either by invoking the method or by calling break , continue , return or throw , all of which are described below.When a name of a method is encountered in a flow, it stops execution in the current method and branches to the newly called method. After returning a value from the called method, execution picks up at the original method on the line below the method call.The program flow begins in the main method. Just as aMethod is invoked, the flow travels to
the called method. At this very point, the flow branches to the other method. Once the method is completed, the flow
is returned to the point it left off and resumes at the next statement after the call to the method.",Statements Unconditional Branching Statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
102,"A return statement exits from a block, so it is often the last statement of a method:A return statement can return the content of a variable or nothing. Beware not to write statements after a return statement which would not be executed! Each return statement is ended by a semi-colon ( ; ).",Statements Return statement,https://en.wikibooks.org//wiki/Java_Programming/Statements
103,"Conditional branching is attained with the help of the if...else and switch statements. A
conditional branch occurs only if a certain condition expression evaluates to true.",Statements Conditional Branching Statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
104,"Also referred to as if statements , these allow a program to perform a test and then take action based on the result of that test.The form of the if statement:if ( condition ) { do statements here if condition is true } else { do statements here if condition is false }The condition is a boolean expression which can be either true or false . The actions performed will depend on the value of the condition.Example:If statements can also be made more complex using the else if combination:if ( condition 1 ) { do statements here if condition 1 is true } else  if ( condition 2 ) { do statements here if condition 1 is false and condition 2 is true } else { do statements here if neither condition 1 nor condition 2 is true }Example:If there is only one statement to be executed after the condition, as in the above example, it is possible to omit the curly braces, however Oracle's Java Code Conventions explicitly state that the braces should always be used.There is no looping involved in an if statement so once the condition has been evaluated the program will continue with the next instruction after the statement.",Statements Conditional Statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
105,"The if ... else statement is used to conditionally execute one of two blocks of
statements, depending on the result of a boolean condition.Example:Oracle's Java Code Conventions recommend that the braces should always be used.An if statement has two forms:if (boolean-condition) statement 1andif (boolean-condition) statement 1  else  statement 2Use the second form if you have different statements to execute if the boolean-condition is true or if it is false. Use the first if you only wish to execute statement 1 if the condition is true and you do not wish to execute alternate statements if the condition is false.The code section 3.13 calls two int methods, f() and y() , stores the results, then uses an if statement to test if x is less than y and if it is, the statement 1 body will swap the values. The end result is x always contains the larger result and y always contains the smaller result.if ... else statements also allow for the use of another statement, else  if .  This statement is used to provide another if statement to the conditional that can only be executed if the others are not true.  For example:The else  if statement is useful in this case because if one of the conditionals is true, the other must be false.  Keep in mind that if one is true, the other will not execute.  For example, if the statement at line 2 contained in the first conditional were changed to x = 3; , the second conditional, the else  if , would still not execute.  However, when dealing with primitive types in conditional statements, it is more desirable to use switch statements rather than multiple else  if statements.",Statements If...else statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
106,"The switch conditional statement is basically a shorthand version of writing many if ... else statements.  The syntax for switch statements is as follows:switch (<variable>) {
  case <result>: <statements>; break;
  case <result>: <statements>; break;
  default: <statements>; break;
}This means that if the variable included equals one of the case results, the statements following that case, until the word break will run.  The default case executes if none of the others are true. Note: the only types that can be analysed through switch statements are char , byte , short , or int primitive types.  This means that Object variables can not by analyzed through switch statements. However, as of the JDK 7 release, you can use a String object in the expression of a switch statement.In this example, since the integer variable n is equal to 2, case 2 will execute, make x equal to 4.  Thus, 4 is returned by the method.",Statements Switch statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
107,"Iteration Statements are statements that are used to iterate a block of statements. Such statements are often referred
to as loops. Java offers four kinds of iterative statements.The while loop  The do...while loop  The for loop  The foreach loop",Statements Iteration Statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
108,"Main page: Java Programming/Keywords/whileThe while loop iterates a block of code while the condition it specifies is true .The syntax for the loop is:while (condition) {
   statement;
 }Here the condition is an expression.
An expression as discussed earlier is any statement that returns a value. While condition statements
evaluate to a boolean value, that is, either true or false . As long as the condition is true , the loop will iterate the block of code over and over and again. Once the condition evaluates
to false , the loop exits to the next statement outside the loop.",Statements The while loop,https://en.wikibooks.org//wiki/Java_Programming/Statements
109,"The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executesdo {
   statement;
 } while (condition);",Statements The do...while loop,https://en.wikibooks.org//wiki/Java_Programming/Statements
110,Main page: Java Programming/Keywords/forThe for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. Example:The program prints the numbers 0 to 99 and their squares.The same statement in a while loop:,Statements The for loop,https://en.wikibooks.org//wiki/Java_Programming/Statements
111,"The foreach statement allows you to iterate through all the items in a collection,
examining each item in turn while still preserving its type. The syntax for the foreach statement is:for ( type item: collection) statement;For an example, we'll take an array of String s denoting days in a week and traverse through the
collection, examining one item at a time.Notice that the loop automatically exits after the last item in the collection has been examined in the statement
block.Although the enhanced for loop can make code much clearer, it can't be used in some common situations.Only access. Elements can not be assigned to, eg, not to increment each element in a collection.  Only single structure. It's not possible to traverse two structures at once, eg, to compare two arrays.  Only single element. Use only for single element access, eg, not to compare successive elements.  Only forward. It's possible to iterate only forward by single steps.  At least Java 5. Don't use it if you need compatibility with versions before Java 5.",Statements The foreach loop,https://en.wikibooks.org//wiki/Java_Programming/Statements
112,"At times, you would like to re-iterate a loop without executing the remaining statement within the loop. The continue statement causes the loop to re-iterate and start over from the top most statement inside
the loop.Where there is an ability to re-iterate the loop, there is an ability to exit the loop when required. At any given
moment, if you'd like to exit a loop and end all further work within the loop, the break ought to be
used.The continue and break statements can be used with a label like follows:",Statements The continue and break statements,https://en.wikibooks.org//wiki/Java_Programming/Statements
113,A throw statement exits from a method and so on and so on or it is caught by a try / catch block. It does not return a variable but an exception:Beware not to write statements after a throw statement which would not be executed too! Each throw statement is ended by a semi-colon ( ; ).,Statements Throw statement,https://en.wikibooks.org//wiki/Java_Programming/Statements
114,"Conditional blocks allow a program to take a different path depending on some condition(s). These allow a program to perform a test and then take action based on the result of that test. In the code sections, the actually executed code lines will be highlighted.",Conditional blocks ,https://en.wikibooks.org//wiki/Java_Programming/Conditional_blocks
115,The if block executes only if the boolean expression associated with it is true. The structure of an if block is as follows:Here is a double example to illustrate what happens if the condition is true and if the condition is false:,Conditional blocks If,https://en.wikibooks.org//wiki/Java_Programming/Conditional_blocks
116,The if block may optionally be followed by an else block which will execute if that boolean expression is false. The structure of an if block is as follows:,Conditional blocks If/else,https://en.wikibooks.org//wiki/Java_Programming/Conditional_blocks
117,"An else-if block may be used when multiple conditions need to be checked. else-if statements come after the if block, but before the else block. The structure of an if block is as follows:Here is an example to illustrate:Keep in mind that only a single block will execute, and it will be the first true condition.All the conditions are evaluated when if is reached, no matter what the result of the condition is, after the execution of the if block:",Conditional blocks If/else-if/else,https://en.wikibooks.org//wiki/Java_Programming/Conditional_blocks
118,"Conditional expressions use the compound ?: operator. Syntax:This evaluates boolean expression 1 , and if it is true then the conditional expression has the value of expression 1 ; otherwise the conditional expression has the value of expression 2 .Example:This is equivalent to the following code fragment:",Conditional blocks Conditional expressions,https://en.wikibooks.org//wiki/Java_Programming/Conditional_blocks
119,"Loops are a handy tool that enables programmers to do repetitive tasks with minimal effort. Say we want a program that can count from 1 to 10, we could write the following program .The task will be completed just fine, the numbers 1 to 10 will be printed in the output, but there are a few problems with this solution:Flexibility :  what if we wanted to change the start number or end number? We would have to go through and change them, adding extra lines of code where they're needed.  Scalability : 10 repeats are trivial, but what if we wanted 100 or even 1000 repeats? The number of lines of code needed would be overwhelming for a large number of iterations.  Maintenance : where there is a large amount of code, one is more likely to make a mistake.  Feature : the number of tasks is fixed and doesn't change at each execution.Using loops we can solve all these problems. Once you get you head around them they will be invaluable to solving many problems in programming.Open up your editing program and create a new file saved as Loop.java . Now type or copy the following code :If we run the program, the same result is produced, but looking at the code, we immediately see the advantages of loops. Instead of executing 10 different lines of code, line 5 executes ten times. 10 lines of code have been reduced to just 4. Furthermore, we may change the number 10 to any number we like. Try it yourself, replace the 10 with your own number.",Loop blocks ,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
120,"while loops are the simplest form of loop. The while loop repeats a block of code while the specified condition is true. Here is the structure of a while loop:The loop's condition is checked before each iteration of the loop. If the condition is false at the start of the loop, the loop will not be executed at all. The code section 3.28 sets in squareHigherThan200 the smallest integer whose square exceeds 200.",Loop blocks While,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
121,"The do - while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executes It is useful when we try to find a data that does the job by randomly browsing an amount of data.",Loop blocks Do... while,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
122,"The for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. It consists of the keyword for followed by three extra statements enclosed in parentheses. The first statement is the variable declaration statement, which allows you to declare one or more integer variables. The second is the condition, which is checked the same way as the while loop. Last is the iteration statement, which is used to increment or decrement variables, though any statement is allowed.This is the structure of a for loop:To clarify how a for loop is used, here is an example:The for loop is like a template version of the while loop. The alternative code using a while loop would be as follows:The code section 3.31 shows how to iterate with the for loop using multiple variables and the code section 3.32 shows how any of the parameters of a for loop can be skipped. Skip them all, and you have an infinitely repeating loop.",Loop blocks For,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
123,"Arrays haven't been covered yet, but you'll want to know how to use the enhanced for loop, called the for-each loop. The for-each loop automatically iterates through a list or array and assigns the value of each index to a variable.To understand the structure of a for-each loop, look at the following example:The example iterates through an array of words and prints them out like a sentence. What the loop does is iterate through sentence and assign the value of each index to word , then execute the code block.Here is the general contract of the for-each loop:Make sure that the type of the array or list is assignable to the declared variable, or you will get a compilation error. Notice that the loop automatically exits after the last item in the collection has been examined in the statement
block.Although the enhanced for loop can make code much clearer, it can't be used in some common situations.Only access. Elements can not be assigned to, eg, not to increment each element in a collection.  Only single structure. It's not possible to traverse two structures at once, eg, to compare two arrays.  Only single element. Use only for single element access, eg, not to compare successive elements.  Only forward. It's possible to iterate only forward by single steps.  At least Java 5. Don't use it if you need compatibility with versions before Java 5.",Loop blocks For-each,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
124,"The break keyword exits a flow control loop, such as a for loop. It basically breaks the loop.In the code section 3.34 , the loop would print out all the numbers from 1 to 10, but we have a check for when i equals 5. When the loop reaches its fifth iteration, it will be cut short by the break statement, at which point it will exit the loop.The continue keyword jumps straight to the next iteration of a loop and evaluates the boolean expression controlling the loop. The code section 3.35 is an example of the continue statement in action:As the break and continue statements reduce the readability of the code, it is recommended to reduce their use or replace them with the use of if and while blocks. Some IDE refactoring operations will fail because of such statements.Test your knowledge  Question 3.2 : Consider the following code:      Question 3.2: Loops and conditions.  1 int  numberOfItems  =  5 ;  2 int  currentItems  =  0 ;  3 int  currentCandidate  =  1 ;  4  5 while  ( currentItems  <  numberOfItems )  {  6  currentCandidate  =  currentCandidate  +  1 ;  7  System . out . println ( ""Test with integer: ""  +  currentCandidate );  8  9  boolean  found  =  true ;  10  for  ( int  i  =  currentCandidate  -  1 ;  i  >  1 ;  i --)  {  11  12  // Test if i is a divisor of currentCandidate  13  if  (( currentCandidate  %  i )  ==  0 )  {  14  System . out . println ( ""Not matching..."" );  15  found  =  false ;  16  break ;  17  }  18  19  }  20  21  if  ( found )  {  22  System . out . println ( ""Matching!"" );  23  currentItems  =  currentItems  +  1 ;  24  }  25 }  26  27 System . out . println ( ""Find the value: ""  +  currentCandidate );    What will be printed in the standard output?  Answer      Output for Question 3.2  Test with integer: 2
Matching!
Test with integer: 3
Matching!
Test with integer: 4
Not matching...
Test with integer: 5
Matching!
Test with integer: 6
Not matching...
Test with integer: 7
Matching!
Test with integer: 8
Not matching...
Test with integer: 9
Not matching...
Test with integer: 10
Not matching...
Test with integer: 11
Matching!
Find the value: 11   The snippet is searching the 5 th  prime number , that is to say: 11. It iterates on each positive integer from 2 (2, 3, 4, 5, 6, 7, 8, 9, 10, 11...), among them, it counts the prime numbers (2, 3, 5, 7, 11) and it stops at the 5 th one. So the snippet first iterates on each positive integer from 2 using the while loop:      Answer 3.2.1: while loop.  1 int  numberOfItems  =  5 ;  2 int  currentItems  =  0 ;  3 int  currentCandidate  =  1 ;  4  5 while  ( currentItems  <  numberOfItems )  {  6  currentCandidate  =  currentCandidate  +  1 ;  7  System . out . println ( ""Test with integer: ""  +  currentCandidate );  8  9  boolean  found  =  true ;  10  for  ( int  i  =  currentCandidate  -  1 ;  i  >  1 ;  i --)  {  11  12  // Test if i is a divisor of currentCandidate  13  if  (( currentCandidate  %  i )  ==  0 )  {  14  System . out . println ( ""Not matching..."" );  15  found  =  false ;  16  break ;  17  }  18  19  }  20  21  if  ( found )  {  22  System . out . println ( ""Matching!"" );  23  currentItems  =  currentItems  +  1 ;  24  }  25 }  26  27 System . out . println ( ""Find the value: ""  +  currentCandidate );    For each iteration, the current number is either a prime number or not. If it is a prime number, the code at the left will be executed. If it is not a prime number, the code at the right will be executed.         Answer 3.2.2: A prime number.  1 int  numberOfItems  =  5 ;  2 int  currentItems  =  0 ;  3 int  currentCandidate  =  1 ;  4  5 while  ( currentItems  <  numberOfItems )  {  6  currentCandidate  =  currentCandidate  +  1 ;  7  System . out . println ( ""Test with integer: ""  +  currentCandidate );  8  9  boolean  found  =  true ;  10  for  ( int  i  =  currentCandidate  -  1 ;  i  >  1 ;  i --)  {  11  12  // Test if i is a divisor of currentCandidate  13  if  (( currentCandidate  %  i )  ==  0 )  {  14  System . out . println ( ""Not matching..."" );  15  found  =  false ;  16  break ;  17  }  18  19  }  20  21  if  ( found )  {  22  System . out . println ( ""Matching!"" );  23  currentItems  =  currentItems  +  1 ;  24  }  25 }  26  27 System . out . println ( ""Find the value: ""  +  currentCandidate );          Answer 3.2.3: Not a prime number.  1 int  numberOfItems  =  5 ;  2 int  currentItems  =  0 ;  3 int  currentCandidate  =  1 ;  4  5 while  ( currentItems  <  numberOfItems )  {  6  currentCandidate  =  currentCandidate  +  1 ;  7  System . out . println ( ""Test with integer: ""  +  currentCandidate );  8  9  boolean  found  =  true ;  10  for  ( int  i  =  currentCandidate  -  1 ;  i  >  1 ;  i --)  {  11  12  // Test if i is a divisor of currentCandidate  13  if  (( currentCandidate  %  i )  ==  0 )  {  14  System . out . println ( ""Not matching..."" );  15  found  =  false ;  16  break ;  17  }  18  19  }  20  21  if  ( found )  {  22  System . out . println ( ""Matching!"" );  23  currentItems  =  currentItems  +  1 ;  24  }  25 }  26  27 System . out . println ( ""Find the value: ""  +  currentCandidate );     The prime numbers are counted using currentItems . When currentItems is equal to numberOfItems (5), the program go out of the while loop. currentCandidate contains the last number, that is to say the 5 th prime number:      Answer 3.2.4: End of the program.  1 int  numberOfItems  =  5 ;  2 int  currentItems  =  0 ;  3 int  currentCandidate  =  1 ;  4  5 while  ( currentItems  <  numberOfItems )  {  6  currentCandidate  =  currentCandidate  +  1 ;  7  System . out . println ( ""Test with integer: ""  +  currentCandidate );  8  9  boolean  found  =  true ;  10  for  ( int  i  =  currentCandidate  -  1 ;  i  >  1 ;  i --)  {  11  12  // Test if i is a divisor of currentCandidate  13  if  (( currentCandidate  %  i )  ==  0 )  {  14  System . out . println ( ""Not matching..."" );  15  found  =  false ;  16  break ;  17  }  18  19  }  20  21  if  ( found )  {  22  System . out . println ( ""Matching!"" );  23  currentItems  =  currentItems  +  1 ;  24  }  25 }  26  27 System . out . println ( ""Find the value: ""  +  currentCandidate );",Loop blocks Break and continue keywords,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
125,"Labels can be used to give a name to a loop. The reason to do this is so we can break out of or continue with upper-level loops from a nested loop.Here is how to label a loop:To break out of or continue with a loop, use the break or continue keyword followed by the name of the loop.For example:You needn't worry if you don't understand all the code, but look at how the label is used to break out of the outer loop from the inner loop. However, as such a code is hard to read and maintain, it is highly recommended not to use labels.",Loop blocks Labels,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
126,"See also Throwing and Catching Exceptions .The try - catch blocks are used to catch any exceptions or other throwable objects within the code.Here's what try-catch blocks looks like:The code listing 3.6 tries to print all the arguments that have been passed to the program. However, if there not enough arguments, it will throw an exception.In addition to the try and catch blocks, a finally block may be present. The finally block is always executed, even if an exception is thrown. It may appear with or without a catch block, but always with a try block.Here is what a finally block looks like:",Loop blocks Try... catch blocks,https://en.wikibooks.org//wiki/Java_Programming/Loop_blocks
127,"Boolean values are values that evaluate to either true or false , and are represented by the boolean data type.  Boolean expressions are very similar to mathematical expressions, but instead of using mathematical operators such as ""+"" or ""-"", you use comparative or boolean operators such as ""=="" or ""!"".",Boolean expressions ,https://en.wikibooks.org//wiki/Java_Programming/Boolean_expressions
128,"Java has several operators that can be used to compare variables.  For example, how would you tell if one variable has a greater value than another?  The answer: use the ""greater-than"" operator.Here is a list of the comparative operators in Java:> : Greater than  < : Less than  >= : Greater than or equal to  <= : Less than or equal to  == : Equal to  != : Not equal toTo see how these operators are used, look at this example:Comparative operators can be used on any primitive types (except boolean ), but only the ""equals"" and ""does not equal"" operators work on objects.  This is because the less-than/greater-than operators cannot be applied to objects, but the equivalency operators can.",Boolean expressions Comparative operators,https://en.wikibooks.org//wiki/Java_Programming/Boolean_expressions
129,"In the Java programming language, the words field and variable are both one and the same thing. Variables are devices that are used to store data, such as a number, or a string of character data.",Variables ,https://en.wikibooks.org//wiki/Java_Programming/Variables
130,"Java is considered as a strongly typed programming language. Thus all variables in the Java programming language ought to have a particular data type . This is either declared or inferred and the Java language only allows programs to run if they adhere to type constraints.If you present a numeric type with data that is not numeric, say textual content, then such declarations would violate Javas type system. This gives Java the ability of type safety . Java checks if an expression or data is encountered with an incorrect type or none at all. It then automatically flags this occurrence as an error at compile time. Most type-related errors are caught by the Java compiler, hence making a program more secure and safe once compiled completely and successfully. Some languages (such as C) define an interpretation of such a statement and use that interpretation without any warning; others (such as PL/I) define a conversion for almost all such statements and perform the conversion to complete the assignment. Some type errors can still occur at runtime because Java supports a cast operation which is a way of changing the type of one expression to another. However, Java performs run time type checking when doing such casts, so an incorrect type cast will cause a runtime exception rather than succeeding silently and allowing data corruption.On the other hand, Java is also known as a hybrid language . While supporting object oriented programming (OOP), Java is not a pure OO language like Smalltalk or Ruby . Instead, Java offers both object types and primitive types . Primitive types are used for boolean, character, and numeric values and operations. This allows relatively good performance when manipulating numeric data, at the expense of flexibility. For example, you cannot subclass the primitive types and add new operations to them.",Variables Variables in Java programming,https://en.wikibooks.org//wiki/Java_Programming/Variables
131,"In the Java programming language, there are four kinds of variables.In the code listing 3.9 , are examples of all four kinds of variables.Instance variables : These are variables that are used to store the state of an object (for example, id ). Every object created from a class definition would have its own copy of the variable. It is valid for and occupies storage for as long as the corresponding object is in memory.  Class variables : These variables are explicitly defined within the class-level scope with a static modifier (for example, isClassUsed ). No other variables can have a static modifier attached to them. Because these variables are defined with the static modifier, there would always be a single copy of these variables no matter how many times the class has been instantiated. They live as long as the class is loaded in memory.  Parameters or Arguments : These are variables passed into a method signature (for example, parameter ). Recall the usage of the args variable in the main method. They are not attached to modifiers (i.e. public , private , protected or static ) and they can be used everywhere in the method. They are in memory during the execution of the method and can't be used after the method returns.  Local variables : These variables are defined and used specifically within the method-level scope (for example, currentValue ) but not in the method signature. They do not have any modifiers attached to it. They no longer exist after the method has returned.Test your knowledge  Question 3.5 : Consider the following code:      Question 3.5: SomeClass.java  1 public  class  SomeClass  {  2  public  static  int  c  =  1 ;  3  public  int  a  =  c ;  4  private  int  b ;  5  6  public  void  someMethod ( int  d )  {  7  d  =  c ;  8  int  e ;  9  }  10 }    In the example above, we created five variables: a , b , c , d and e . All these variables have the same data type int (integer). However, can you tell what kind of variable each one is?  Answer  a and b are instance variables ;  c is a class variable ;  d is a parameter or argument ; and,  e is a local variable .",Variables Kinds of variables,https://en.wikibooks.org//wiki/Java_Programming/Variables
132,"A graphical representation of computer memoryVariables and all the information they store are kept in the computer's memory for access. Think of a computer's memory as a table of data  where each cell corresponds to a variable.Upon creating a variable, we basically create a new address space and give it a unique name. Java goes one step further and lets you define what you can place within the variable  in Java parlance you call this a data type . So, you essentially have to do two things in order to create a variable:Create a variable by giving it a unique name; and,  Define a data type for the variable.The following code demonstrates how a simple variable can be created. This process is known as variable declaration .",Variables Creating variables,https://en.wikibooks.org//wiki/Java_Programming/Variables
133,"Because we have provided a data type for the variable, we have a hint as to what the variable can and cannot hold. We know that int (integer) data type supports numbers that are either positive or negative integers. Therefore once a variable is created, we can provide it with any integer value using the following syntax. This process is called an assignment operation .Java provides programmers with a simpler way of combining both variable declaration and assignment operation in one line. Consider the following code:",Variables Assigning values to variables,https://en.wikibooks.org//wiki/Java_Programming/Variables
134,"Consider the following code:There are various ways by which you can streamline the writing of this code. You can group the declarations of similar data types in one statement, for instance:Alternatively, you can further reduce the syntax by doing group declarations and assignments together, as such:",Variables Grouping variable declarations and assignment operations,https://en.wikibooks.org//wiki/Java_Programming/Variables
135,"Although memory spaces have their own addresses  usually a hash number such as 0xCAD3 , etc.  it is much easier to remember a variable's location in the memory if we can give it a recognizable name. Identifiers are the names we give to our variables. You can name your variable anything like aVariable , someVariable , age , someonesImportantData , etcetera. But notice: none of the names we described here has a space within it. Hence, it is pretty obvious that spaces aren't allowed in variable names. In fact, there are a lot of other things that are not allowed in variable names. The things that are allowed are:Characters A to Z and their lower-case counterparts a to z .  Numbers 0 to 9 . However, numbers should not come at the beginning of a variable's name.  And finally, special characters that include only $ (dollar sign) and _ (underscore).Test your knowledge  Question 3.6 : Which of the ones below are proper variable identifiers?  f_name  lastname  someones name  $SomeoneElsesName  7days  TheAnswerIs42  Answer  I can tell you that 3 and 5 are not the right way to do things around here, the rest are proper identifiers.Any valid variable names might be correct but they are not always what you should be naming your variables for a few reasons as listed below:The name of the variable should reflect the value within them.  The identifier should be named following the naming guidelines or conventions for doing so. We will explain that in a bit.  The identifier shouldn't be a nonsense name like lname , you should always name it properly: lastName is the best way of naming a variable.",Variables Identifiers,https://en.wikibooks.org//wiki/Java_Programming/Variables
136,"When naming identifiers, you need to use the following guidelines which ensure that your variables are named accurately. As we discussed earlier, we should always name our variables in a way that tells us what they hold. Consider this example:Do you know what this program does? Well, it multiplies two values. That much you guessed right. But, do you know what those values are? Exactly, you don't. Now consider this code:Now you can tell what's happening, can't you? However, before we continue, notice the case of the variables. If a word contains CAPITAL LETTERS, it is in UPPER CASE . If a word has small letters, it is in lower case . Both cases in a word renders it as mIxEd CaSe .The variables we studied so far had a mixed case. When there are two or more words making up the names of a variable, you need to use a special case called the camel-case . Just like the humps of a camel, your words need to stand out. Using this technique, the words first and name could be written as either firstName or FirstName .The first instance, firstName is what we use as the names of variables. Remember though, firstName is not the same as FirstName because Java is case-sensitive . Case-sensitive basically implies that the case in which you wrote one word is the case you have to call that word in when using them later on. Anything other than that is not the same as you intended. You'll know more as you progress. You can hopefully tell now why the variables you were asked to identify weren't proper.",Variables Naming conventions for identifiers,https://en.wikibooks.org//wiki/Java_Programming/Variables
137,"Primitive types are the most basic data types available within the Java language. There are 8: boolean , byte , char , short , int , long , float and double . These types serve as the building blocks of data manipulation in Java. Such types serve only one purpose  containing pure, simple values of a kind. Because these data types are defined into the Java type system by default, they come with a number of operations predefined. You can not define a new operation for such primitive types. In the Java type system, there are three further categories of primitives:Numeric primitives: short , int , long , float and double . These primitive data types hold only numeric data. Operations associated with such data types are those of simple arithmetic (addition, subtraction, etc.) or of comparisons (is greater than, is equal to, etc.)  Textual primitives: byte and char . These primitive data types hold characters (that can be Unicode alphabets or even numbers). Operations associated with such types are those of textual manipulation (comparing two words, joining characters to make words, etc.). However, byte and char can also support arithmetic operations.  Boolean and null primitives: boolean and null .All the primitive types have a fixed size. Thus, the primitive types are limited to a range of values. A smaller primitive type ( byte ) can contain less values than a bigger one ( long ).Integer primitive types silently overflow:As Java is strongly typed, you can't assign a floating point number (a number with a decimal point) to an integer variable:A primitive type should be set by an appropriate value. The primitive types can be initialized with a literal. Most of the literals are primitive type values, except String Literals , which are instance of the String class.",Primitive Types ,https://en.wikibooks.org//wiki/Java_Programming/Primitive_Types
138,"Programming may not be as trivial or boring as just crunching huge numbers any more. However, huge chunks of code written in any programming language today, let alone Java, obsessively deal with numbers, be it churning out huge prime numbers, [1] or just calculating a cost of emission from your scooter. In 1965, Gemini V space mission escaped a near-fatal accident caused by a programming error. [2] Again in 1979, a computer program overestimated the ability of five nuclear reactors to withstand earthquakes; the plants shut down temporarily. [3] There is one thing common to both these programming errors: the subject data, being computed at the time the errors occurred, was numeric. Out of past experience, Java came bundled with revised type checking for numeric data and put significant emphasis on correctly identifying different types of it. You must recognise the importance of numeric data when it comes to programming.Numbers are stored in memory using a binary system. The memory is like a grid of cells:Each cell can contain a binary digit (shortened to bit ), that is to say, zero or one:Actually, each cell does contain a binary digit, as one bit is roughly equivalent to 1 and an empty cell in the memory signifies 0 . A single binary digit can only hold two possible values: a zero or a one.Multiple bits held together can hold multiple permutations  2 bits can hold 4 possible values, 3 can hold 8, and so on. For instance, the maximum number 8 bits can hold ( 11111111 in binary) is 255 in the decimal system. So, the numbers from 0 to 255 can fit within 8 bits.It is all good, but this way, we can only host positive numbers (or unsigned integers). They are called unsigned integers . Unsigned integers are whole number values that are all positive and do not attribute to negative values. For this very reason, we would ask one of the 8 bits to hold information about the sign of the number (positive or negative). This leaves us with just 7 bits to actually count out a number. The maximum number that these 7 bits can hold ( 1111111 ) is 127 in the decimal system.Altogether, using this method, 8 bits can hold numbers ranging from -128 to 127 (including zero)  a total of 256 numbers. Not a bad pay-off one might presume. The opposite to an unsigned integer is a signed integer that have the capability of holding both positive and negative values.But, what about larger numbers. You would need significantly more bits to hold larger numbers. That's where Java's numeric types come into play. Java has multiple numeric types  their size dependent on the number of bits that are at play.In Java, numbers are dealt with using data types specially formulated to host numeric data. But before we dive into these types, we must first set some concepts in stone. Just like you did in high school (or even primary school), numbers in Java are placed in clearly distinct groups and systems. As you'd already know by now, number systems includes groups like the integer numbers (0, 1, 2 ... ); negative integers (0, -1, -2 ... -) or even real and rational numbers ( value of Pi , , 0.333~, etcetera). Java simply tends to place these numbers in two distinct groups, integers (- ... 0 ... ) and floating point numbers (any number with decimal points or fractional representation). For the moment, we would only look into integer values as they are easier to understand and work with.",Primitive Types Numbers in computer science,https://en.wikibooks.org//wiki/Java_Programming/Primitive_Types
139,"With what we have learned so far, we will identify the different types of signed integer values that can be created and manipulated in Java. Following is a table of the most basic numeric types: integers. As we have discussed earlier, the data types in Java for integers caters to both positive and negative values and hence are signed numeric types . The size in bits for a numeric type determines what its minimum and maximum value would be. If in doubt, one can always calculate these values.Lets see how this new found knowledge of the basic integer types in Java fits into the picture. Say, you want to numerically manipulate the days in a year  all 365 days. What type would you use? Since the data type byte only goes up to 127, would you risk giving it a value greater than its allowed maximum. Such decisions might save you from dreaded errors that might occur out of the programmed code. A much more sensible choice for such a numeric operation might be a short . Oh, why couldn't they make just one data type to hold all kinds of numbers? Wouldn't you ask that question? Well, let's explore why.When you tell a program you need to use an integer, say even a byte , the Java program allocates a space in the memory. It allocates whole 8 bits of memory. Where it wouldn't seem to matter for today's memory modules that have place for almost a dozen trillion such bits, it matters in other cases. Once allocated that part of the memory gets used and can only be claimed back after the operation is finished. Consider a complicated Java program where the only data type you'd be using would be long integers. What happens when there's no space for more memory allocation jobs? Ever heard of the Stack Overflow errors . That's exactly what happens  your memory gets completely used up and fast. So, choose your data types with extreme caution.Enough talk, let's see how you can create a numeric type. A numeric type begins with the type's name ( short , int , etc.) and then provides with a name for the allocated space in the memory. Following is how it's done. Say, we need to create a variable to hold the number of days in a year.Here, daysInYear is the name of the variable that holds 365 as its value, while short is the data type for that particular value. Other uses of integer data types in Java might see you write code such as this given below:",Primitive Types Integer types in Java,https://en.wikibooks.org//wiki/Java_Programming/Primitive_Types
140,"The data types that one can use for integer numbers are byte , short , int and long but when it comes to floating point numbers, we use float or double . Now that we know that, we can modify the code in the code section 3.53 as:Why not float , you say? If we'd used a float , we would have to append the number with a f as a suffix, so 10.5 should be 10.5f as in:Floating-point math never throws exceptions. Dividing a non-zero value by 0 equals infinity . Dividing a non-infinite value by infinity equals 0 .Test your knowledge  Question 3.7 : Consider the following code:      Question 3.7: Primitive type assignments.  5 ...  6  7 a  =  false ;  8 b  =  3.2 ;  9 c  =  35 ;  10 d  =  - 93485L ;  11 e  =  'q' ;    These are five variables. There are a long , a byte , a char , a double and a boolean . Retrieve the type of each one.  Answer      Answer 3.7: Primitive type assignments and declarations.  1 boolean  a ;  2 double  b ;  3 byte  c ;  4 long  d ;  5 char  e ;  6  7 a  =  false ;  8 b  =  3.2 ;  9 c  =  35 ;  10 d  =  - 93485L ;  11 e  =  'q' ;    a can only be the boolean because only a boolean can handle boolean values.  e can only be the char because only a char can contain a character.  b can only be the double because only a double can contain a decimal number here.  d is the long because a byte can not contain such a low value.  c is the remaining one so it is the byte .",Primitive Types Integer numbers and floating point numbers,https://en.wikibooks.org//wiki/Java_Programming/Primitive_Types
141,"Data conversion (casting) can happen between two primitive types. There are two kinds of casting:Implicit: casting operation is not required; the magnitude of the numeric value is always preserved. However, precision may be lost when converting from integer to floating point types  Explicit: casting operation required; the magnitude of the numeric value may not be preservedThe following table shows the conversions between primitive types, it shows the casting operation for explicit conversions:Unlike C, C++ and similar languages, Java can't represent false as 0 or null and can't represent true as non-zero. Java can't cast from boolean to a non-boolean primitive data type, or vice versa.For non primitive types:",Primitive Types Data conversion (casting),https://en.wikibooks.org//wiki/Java_Programming/Primitive_Types
142,"In order to do arithmetic in Java, one must first declare at least one variable. Typically one declares a variable and assigns it a value before any arithmetic is done. Here's an example of declaring an integer variable:After creating a variable, one can manipulate its value by using Java's operators: + (addition), - (subtraction), * (multiplication), / (integer division), % ( modulo or remainder ), ++ (pre- & postincrement by one), -- (pre- & postdecrement by one).The division operator rounds towards zero: 5/2 is 2, and -5/2 is -2.
The remainder operator has the same sign as the left operand; it is defined such that ((a/b)*b) + (a%b) is always equal to a.
The preincrement, predecrement, postincrement, and postdecrement operators are special: they also change the value of the variable, by adding or subtracting one. The only difference is that preincrement/decrement returns the new value of the variable; postincrement returns the original value of the variable.Test your knowledge  Question 3.8 : Consider the following code:      Question 3.8: Question8.java  1 public  class  Question8  {  2  public  static  void  main ( String []  args )  {  3  int  x  =  10 ;  4  x  =  x  +  10 ;  5  x  =  2  *  x ;  6  x  =  x  -  19 ;  7  x  =  x  /  3 ;  8  System . out . println ( x );  9  }  10 }    What will be printed in the standard output?  Answer      Output for Question 3.8  7   int x = 10; => 10  x = x + 10; => 20  x = 2 * x; => 40  x = x - 19; => 21  x = x / 3; => 7When using several operators in the same expression, one must consider Java's order of precedence. Java uses the standard PEMDAS (Parenthesis, Exponents, Multiplication and Division, Addition and Subtraction) order. When there are multiple instances of the same precedence, Java reads from left to right. Consider what the output of the following code would be:The following chart shows how Java would compute this expression:Besides performing mathematical functions, there are also operators to assign numbers to variables (each example again uses the variable initialized as x = 5 ):",Arithmetic expressions ,https://en.wikibooks.org//wiki/Java_Programming/Arithmetic_expressions
143,"Java Literals are syntactic representations of boolean, character, numeric, or string data. Literals provide a means of expressing specific values in your program. For example, in the following statement, an integer variable named count is declared and assigned an integer value. The literal 0 represents, naturally enough, the value zero.The code section 3.62 contains two number literals followed by two boolean literals at line 1, one string literal followed by one number literal at line 2, and one string literal followed by one real number literal at line 3:",Literals ,https://en.wikibooks.org//wiki/Java_Programming/Literals
144,"There are two boolean literalstrue represents a true boolean value  false represents a false boolean valueThere are no other boolean literals, because there are no other boolean values!",Literals Boolean Literals,https://en.wikibooks.org//wiki/Java_Programming/Literals
145,There are three types of numeric literals in Java.,Literals Numeric Literals,https://en.wikibooks.org//wiki/Java_Programming/Literals
146,"In Java, you may enter integer numbers in several formats:As decimal numbers such as 1995 , 51966 . Negative decimal numbers such as -42 are actually expressions consisting of the integer literal with the unary negation operation - .  As octal numbers, using a leading 0 (zero) digit and one or more additional octal digits (digits between 0 and 7 ), such as 077 . Octal numbers may evaluate to negative numbers; for example 037777777770 is actually the decimal value -8.  As hexadecimal numbers, using the form 0x (or 0X ) followed by one or more hexadecimal digits (digits from 0 to 9 , a to f or A to F ). For example, 0xCAFEBABEL is the long integer 3405691582. Like octal numbers, hexadecimal literals may represent negative numbers.  Starting in J2SE 7.0, as binary numbers, using the form 0b (or 0B ) followed by one or more binary digits (0 or 1). For example, 0b101010 is the integer 42. Like octal and hex numbers, binary literals may represent negative numbers.By default, the integer literal primitive type is int . If you want a long , add a letter el suffix (either the character l or the character L ) to the integer literal. This suffix denotes a long integer rather than a standard integer. For example, 3405691582L is a long integer literal. Long integers are 8 bytes in length as opposed to the standard 4 bytes for int . It is best practice to use the suffix L instead of l to avoid confusion with the digit 1 (one) which looks like l in many fonts: 200l  2001 . If you want a short integer literal, you have to cast it.Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.",Literals Integer Literals,https://en.wikibooks.org//wiki/Java_Programming/Literals
147,"Floating point numbers are expressed as decimal fractions or as exponential notation:Floating point numbers consist of:an optional leading + or - sign, indicating a positive or negative value; if omitted, the value is positive,  one of the following number formats integer digits (must be followed by either an exponent or a suffix or both, to distinguish it from an integer literal)  integer digits  .  integer digits  .  integer digits  .  integer digits  an optional exponent of the form the exponent indicator e or E  an optional exponent sign + or - (the default being a positive exponent)  integer digits representing the integer exponent value  an optional floating point suffix: either f or F indicating a single precision (4 bytes) floating point number, or  d or D indicating the number is a double precision floating point number (by default, thus the double precision (8 bytes) is default).Here, integer digits represents one or more of the digits 0 through 9 .Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.",Literals Floating Point Literals,https://en.wikibooks.org//wiki/Java_Programming/Literals
148,"Character literals are constant valued character expressions embedded in a Java program. Java characters are sixteen bit Unicode characters, ranging from 0 to 65535. Character literals are expressed in Java as a single quote, the character, and a closing single quote ( 'a' , '7' , '$' , '' ). Character literals have the type char , an unsigned integer primitive type . Character literals may be safely promoted to larger integer types such as int and long . Character literals used where a short or byte is called for must be cast to short or byte since truncation may occur.",Literals Character Literals,https://en.wikibooks.org//wiki/Java_Programming/Literals
149,"String literals consist of the double quote character ( "" ) (ASCII 34, hex 0x22), zero or more characters (including Unicode characters), followed by a terminating double quote character ( "" ), such as: ""Ceci est une string.""So a string literal follows the following grammar:<STRING:
        ""\""""
        (    (~[""\"""",""\\"",""\n"",""\r""])
        |(""\\""
            ( [""n"",""t"",""b"",""r"",""f"",""\\"",""'"",""\""""]
            |[""0""-""7""]([""0""-""7""])?
            |[""0""-""3""][""0""-""7""][""0""-""7""]
            )
        )
        )*
        ""\"""">Within string and character literals, the backslash character can be used to escape special characters, such as unicode escape sequences , or the following special characters:String literals may not contain unescaped newline or linefeed characters. However, the Java compiler will evaluate compile time expressions, so the following String expression results in a string with three lines of text:",Literals String Literals,https://en.wikibooks.org//wiki/Java_Programming/Literals
150,null is a special Java literal which represents a null value : a value which does not refer to any object. It is an error to attempt to dereference the null value  Java will throw a NullPointerException . null is often used to represent uninitialized state.,Literals null,https://en.wikibooks.org//wiki/Java_Programming/Literals
151,"Methods are how we communicate with objects. When we invoke or call a method we are asking the object to carry out a task. We can say methods implement the behaviour of objects. For each method we need to give a name, we need to define its input parameters and we need to define its return type. We also need to set its visibility (private, protected or public). If the method throws a checked exception, that needs to be declared as well. It is called a method definition . The syntax of method definition is:1 MyClass  {  2  ...  3  public  ReturnType  methodName ( ParamOneType  parameter1 ,  ParamTwoType  parameter2 )  {  4  ...  5  return  returnType ;  6  }  7  ...  8 }We can declare that the method does not return anything using the void Java keyword. For example:When the method returns nothing, the return keyword at the end of the method is optional. When the execution flow reaches the return keyword, the method execution is stopped and the execution flow returns to the caller method. The return keyword can be used anywhere in the method as long as there is a way to execute the instructions below:In the code section 3.68 , the return keyword at line 5 is well placed because the instructions below can be reached when a is negative or equal to 0. However, the return keyword at line 8 is badly placed because the instructions below can't be reached.Test your knowledge  Question 3.9 : Consider the following code:      Question 3.9: Compiler error.  1 private  int  myMethod ( int  a ,  int  b ,  boolean  c )  {  2  b  =  b  +  2 ;  3  if  ( a  >  0 )  {  4  a  =  a  +  b ;  5  return  a ;  6  }  else  {  7  a  =  0 ;  8  }  9 }    The code above will return a compiler error. Why?  Answer      Answer 3.9: Compiler error.  1 private  int  myMethod ( int  a ,  int  b ,  boolean  c )  {  2  b  =  b  +  2 ;  3  if  ( a  >  0 )  {  4  a  =  a  +  b ;  5  return  a ;  6  }  else  {  7  a  =  0 ;  8  }  9 }    The method is supposed to return a int but when a is negative or equal to 0, it returns nothing.",Methods ,https://en.wikibooks.org//wiki/Java_Programming/Methods
152,We can pass any primitive data types or reference data type to a method.,Methods Parameter passing,https://en.wikibooks.org//wiki/Java_Programming/Methods
153,"The primitive types are passed in by value . It means that as soon as the primitive type is passed in, there is no more link between the value inside the method and the source variable:As you can see in code section 3.70 , the modifyValue() method has not modified the value of i .",Methods Primitive type parameter,https://en.wikibooks.org//wiki/Java_Programming/Methods
154,"The object references are passed by value. It means that:There is no more link between the reference inside the method and the source reference,  The source object itself and the object itself inside the method are still the same.You must understand the difference between the reference of an object and the object itself. A object reference is the link between a variable name and an instance of object:An object reference is a pointer, an address to the object instance.The object itself is the value of its attributes inside the object instance:Take a look at the example above:The name has changed because the method has changed the object itself and not the reference. Now take a look at the other example:The name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:",Methods Reference type parameter,https://en.wikibooks.org//wiki/Java_Programming/Methods
155,"Java SE 5.0 added syntactic support for methods with variable argument list , which simplifies the typesafe usage of methods requiring a variable number of arguments. Less formally, these parameters are called varargs [1] . The type of a variable parameter must be followed with ... , and Java will box all the arguments into an array:When calling the method, a programmer can simply separate the points by commas, without having to explicitly create an array of Point objects. Within the method, the points can be referenced as points[0] , points[1] , etc. If no points are passed, the array has a length of zero.A method can have both normal parameters and a variable parameter but the variable parameter must always be the last parameter. For instance, if the programmer is required to use a minimum number of parameters, those parameters can be specified before the variable argument:",Methods Variable argument list,https://en.wikibooks.org//wiki/Java_Programming/Methods
156,"A method may return a value (which can be a primitive type or an object reference). If the method does not return a value we use the void Java keyword.However, a method can return only one value so what if you want to return more than one value from a method?
You can pass in an object reference to the method, and let the method modify the object properties so the modified values can be considered as an output value from the method.
You can also create an Object array inside the method, assign the return values and return the array to the caller. However, this gives a problem if you want to mix primitive data types and object references as the output values from the method.There is a better approach, define a special return object with the needed return values. Create that object inside the method, assign the values and return the reference to this object. This special object is ""bound"" to this method and used only for returning values, so do not use a public class. The best way is to use a nested class, see example below:In the above example the getPersonInfoById method returns an object reference that contains both values of the name and the age. See below how you may use that object:Test your knowledge  Question 3.10 : Consider the following code:      Question 3.10: Compiler error.  1 private  int  myMethod ( int  a ,  int  b ,  String  c )  {  2  if  ( a  >  0 )  {  3  c  =  """" ;  4  return  c ;  5  }  6  int  b  =  b  +  2 ;  7  return  b ;  8 }    The code above will return a compiler error. Why?  Answer      Answer 3.10: Compiler error.  1 private  int  myMethod ( int  a ,  int  b ,  String  c )  {  2  if  ( a  >  0 )  {  3  c  =  """" ;  4  return  c ;  5  }  6  int  b  =  b  +  2 ;  7  return  b ;  8 }    The method is supposed to return a int but at line 4, it returns c , which is a String.",Methods Return parameter,https://en.wikibooks.org//wiki/Java_Programming/Methods
157,"The constructor is a special method called automatically when an object is created with the new keyword. Constructor does not have a return value and its name is the same as the class name. Each class must have a constructor. If we do not define one, the compiler will create a default so called empty constructor automatically.","Methods Special method, the constructor",https://en.wikibooks.org//wiki/Java_Programming/Methods
158,"String is a class built into the Java language defined in the java.lang package. It represents character strings. Strings are ubiquitous in Java. Study the String class and its methods carefully. It will serve you well to know how to manipulate them skillfully. String literals in Java programs, such as ""abc"", are implemented as instances of this class like this:On the right hand side a String object is created represented by the string literal. Its object reference is assigned to the str variable.",String ,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
159,"Strings are immutable ; that is, they cannot be modified once created. Whenever it looks as if a String object was modified actually a new String object was created. For instance, the String.trim() method returns the string with leading and trailing whitespace removed. Actually, it creates a new trimmed string and then returns it. Pay attention on what happens in Code section 3.82 :The trim() method call does not modify the object so nothing happens. It creates a new trimmed string and then throws it away.The returned string is assigned to the variable. It does the job as the trim() method has created a new String instance.",String Immutability,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
160,"The Java language provides special support for the string concatenation with operator + :The concatenation is not always processed at the same time. Raw string literals concatenation is done at compile time, hence there is a single string literal in the byte code of the class. Concatenation with at least one object is done at runtime.+ operator can concatenate other objects with strings. For instance, integers will be converted to strings before the concatenation:Each Java object has the String toString() inherited from the Object class. This method provides a way to convert objects into String s. Most classes override the default behavior to provide more specific (and more useful) data in the returned String :",String Concatenation,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
161,"Remember that String objects are immutable objects. Once a String is created, it can not be modified, takes up memory until garbage collected. Be careful of writing a method like this:On the + operation a new String object is created at each iteration. Suppose words contains the elements [""Foo"", ""Bar"", ""Bam"", ""Baz""] . At runtime, the method creates thirteen String s:""""  ""Foo""  "" ""  ""Foo ""  ""Foo Bar""  "" ""  ""Foo Bar ""  ""Foo Bar Bam""  "" ""  ""Foo Bar Bam ""  ""Foo Bar Bam Baz""  "" ""  ""Foo Bar Bam Baz ""Even though only the last one is actually useful.To avoid unnecessary memory use like this, use the StringBuilder class. It provides similar functionality to String s, but stores its data in a mutable way. Only one StringBuilder object is created. Also because object creation is time consuming, using StringBuilder produces much faster code.As StringBuilder isn't thread safe (see the chapter on Concurrency ) you can't use it in more than one thread. For a multi-thread environment, use StringBuffer instead which does the same and is thread safe. However, StringBuffer is slower so only use it when it is required. Moreover, before Java 5 only StringBuffer existed.",String Using StringBuilder/StringBuffer to concatenate strings,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
162,"Comparing strings is not as easy as it may first seem. Be aware of what you are doing when comparing String 's using == :The difference between the above and below code is that the above code checks
to see if the String 's are the same objects in memory which they are. This is as a result of the fact that String 's are stored in a place in memory called the String Constant Pool. If the new keyword is not explicitly used when 
creating the String it checks to see if it already exists in the Pool and uses the existing one. If it does not exist, a new Object is created. This is what allows Strings to be immutable in Java.
To test for equality, use the equals(Object) method inherited by every class and defined by String to return true if and only if the object passed in is a String contains the exact same data:Remember that the comparison is case sensitive.To order String objects, use the compareTo() method, which can be accessed wherever we use a String datatype. The compareTo() method returns a negative, zero, or positive number if the parameter is less than, equal to, or greater than the object on which it is called. Let's take a look at an example:The code section 3.92 is comparing the String variable person1 to person2 . If person1 is different even in the slightest manner, we will get a value above or below 0 depending on the exact difference. The result is negative if this String object lexicographically precedes the argument string. The result is positive if this String object lexicographically follows the argument string. Take a look at the Java API for more details.",String Comparing Strings,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
163,"Sometimes it is useful to split a string into separate strings, based on a regular expressions . The String class has a split() method, since Java 1.4, that will return a String array:Another useful application could be to split the String text based on the new line character, so you could process the text line by line.",String Splitting a String,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
164,"It may also be sometimes useful to create substrings , or strings using the order of letters from an existing string.  This can be done in two methods.The first method involves creating a substring out of the characters of a string from a given index to the end:The index of the first character in a string is 0.By counting from there, it is apparent that the character in index 3 is the second ""f"" in ""coffee"". This is known as the beginIndex . All characters from the beginIndex until the end of the string will be copied into the new substring.The second method involves a user-defined beginIndex and endIndex :The string returned by substring() would be ""port"".Please note that the endIndex is not inclusive. This means that the last character will be of the index endIndex-1 . Therefore, in this example, every character from index 3 to index 6, inclusive, was copied into the substring.",String Substrings,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
165,"The String class also allows for the modification of cases. The two methods that make this possible are toLowerCase() and toUpperCase() .These methods are useful to do a search which is not case sensitive:Test your knowledge  Question 3.12 : You have mail addresses in the following form: <firstName> . <lastName> @ <companyName> .org  Write the String getDisplayName(String) method that receives the mail string as parameter and returns the readable person name like this: LASTNAME Firstname   Answer      Answer 3.12: getDisplayName()  1 public  static  String  getDisplayName ( String  mail )  {  2  String  displayName  =  null ;  3  4  if  ( mail  !=  null )  {  5  String []  mailParts  =  mail . split ( ""@"" );  6  String  namePart  =  mailParts [ 0 ];  7  String []  namesParts  =  namePart . split ( ""\\."" );  8  9  // The last name  10  String  lastName  =  namesParts [ 1 ];  11  lastName  =  lastName . toUpperCase ();  12  13  // The first name  14  String  firstName  =  namesParts [ 0 ];  15  16  String  firstNameInitial  =  firstName . substring ( 0 ,  1 );  17  firstNameInitial  =  firstNameInitial . toUpperCase ();  18  19  String  firstNameEnd  =  firstName . substring ( 1 );  20  firstNameEnd  =  firstNameEnd . toLowerCase ();  21  22  // Concatenation  23  StringBuilder  displayNameBuilder  =  new  StringBuilder ( lastName ). append ( "" "" ). append ( firstNameInitial ). append ( firstNameEnd );  24  displayName  =  displayNameBuilder . toString ();  25  }  26  27  return  displayName ;  28 }    We only process non null strings,  We first split the mail into two parts to separate the personal information from the company information and we keep the name data,  Then we split the name information to separate the first name from the last name. As the split() method use regular expression and . is a wildcard character, we have to escape it ( \. ). However, in a string, the \ is also a special character, so we need to escape it too ( \\. ),  The last name is just capitalized,  As the case of all the first name characters will not be the same, we have to cut the first name. Only the first name initial will be capitalized,  Now we can concatenate all the fragments. We prefer to use a StringBuilder to do that.",String String cases,https://en.wikibooks.org//wiki/Java_Programming/API/java.lang.String
166,"An object is composed of fields and methods . The fields, also called data members , characteristics , attributes , or properties , describe the state of the object. The methods generally describe the actions associated with a particular object. Think of an object as a noun, its fields as adjectives describing that noun, and its methods as the verbs that can be performed by or on that noun.For example, a sports car is an object. Some of its fields might be its height, weight, acceleration, and speed. An object's fields just hold data about that object. Some of the methods of the sports car could be ""drive"", ""park"", ""race"", etc. The methods really don't mean much unless associated with the sports car, and the same goes for the fields.The blueprint that lets us build our sports car object is called a class . A class doesn't tell us how fast our sports car goes, or what color it is, but it does tell us that our sports car will have a field representing speed and color, and that they will be say, a number and a word (or hex color code), respectively. The class also lays out the methods for us, telling the car how to park and drive, but these methods can't take any action with just the blueprint  they need an object to have an effect.In Java, a class is located in a file similar to its own name.  If you want to have a class called SportsCar , its source file needs to be SportsCar.java .  The class is created by placing the following in the source file:The class doesn't do anything yet, as you will need to add methods and field variables first.The objects are different from the primitive types because:The primitive types are not instantiated.  In the memory, for a primitive type only its value is stored. For an object, also a reference to an instance can be stored.  In the memory, the allocated space of a primitive type is fixed, whatever their value. The allocated space of an object can vary, for instance either the object is instantiated or not.  The primitive types don't have methods callable on them.  A primitive type can't be inherited.",Objects ,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
167,"In order to get from class to object, we ""build"" our object by instantiation . Instantiation simply means to create an instance of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a specific object , which was created from a class.This instantiation is brought about by one of the class's methods, called a constructor . As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.In general there are four constructor types: default, non-default, copy, and cloning.A default constructor will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from setting the color of your default sports car color to red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.A non-default constructor is designed to create an object instance with prescribed values for most, if not all, of the object's fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.A copy constructor is not included in the Java language, however one can easily create a constructor that does the same as a copy constructor. It's important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.Java has the concept of cloning an object , and the end results are similar to the copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to the destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.",Objects Instantiation and constructors,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
168,"When an object is created, a reference to the object is also created. The object can not be accessed directly in Java, only through this object reference. This object reference has a type assigned to it. We need this type when passing the object reference to a method as a parameter. Java does strong type checking.Type is basically a list of features/operations, that can be performed through that object reference.  The object reference type is basically a contract that guarantees that those operations will be there at run time.When a car is created, it comes with a list of features/operations listed in the user manual that guarantees that those will be there when the car is used.When you create an object from a class by default its type is the same as its class. It means that all the features/operations the class defined are there and available, and can be used. See below:You can assign this to a variable having the same type as the class:You can assign the created object reference to the class, super class, or to an interface the class implements:In the car analogy, the created car may have different Type s of drivers. We create separate user manuals for them, an Average user manual, a Power user manual, a Child user manual, or a Handicapped user manual. Each type of user manual describes only those features/operations appropriate for the type of driver.  For instance, the Power driver may have additional gears to switch to higher speeds, that are not available to other type of users...When the car key is passed from an adult to a child we are replacing the user manuals, that is called Type Casting .In Java, casts can occur in three ways:up casting going up in the inheritance tree, until we reach the Object  up casting to an interface the class implements  down casting until we reach the class the object was created from",Objects Type,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
169,"Autoboxing and unboxing, language features since Java 1.5, make the programmer's life much easier when it comes to working with the primitive wrapper types. Consider this code fragment:Primitive wrapper objects were Java's way of allowing one to treat primitive data types as though they were objects. Consequently, one was expected to wrap one's primitive data type with the corresponding primitive wrapper object, as shown above.Since Java 1.5, one may write as below and the compiler will automatically create the wrap object. The extra step of wrapping the primitive is no longer required. It has been automatically boxed up on your behalf:Each primitive type has a class wrapper:Unboxing uses the same process in reverse. Study the following code for a moment. The if statement requires a boolean primitive value, yet it was given a Boolean wrapper object. No problem! Java 1.5 will automatically unbox this.Test your knowledge  Question 3.11 : Consider the following code:      Question 3.11: Autoboxing/unboxing.  5 Integer  a  =  10 ;  6 Integer  b  =  a  +  2 ;  7 System . out . println ( b );    How many autoboxings and unboxings are there in this code?  Answer      Answer 3.11: Autoboxing/unboxing.  1 Integer  a  =  10 ;  2 Integer  b  =  a  +  2 ;  3 System . out . println ( b );    3  1 autoboxing at line 1 to assign.  1 unboxing at line 2 to do the addition.  1 autoboxing at line 2 to assign.  No autoboxing nor unboxing at line 3 as println() supports the Integer class as parameter.",Objects Autoboxing/unboxing,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
170,"Methods in the java.lang.Object class are inherited, and thus shared in common by all classes.",Objects Methods in the Object class,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
171,The java.lang.Object.clone() method returns a new object that is a copy of the current object.  Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.,Objects The clone method,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
172,"The java.lang.Object.equals(java.lang.Object) method compares the object to another object and returns a boolean result indicating if the two objects are equal.  Semantically, this method compares the contents of the objects whereas the equality comparison operator "" == "" compares the object references.  The equals method is used by many of the data structure classes in the java.util package.  Some of these data structure classes also rely on the Object.hashCode methodsee the hashCode method for details on the contract between equals and hashCode . Implementing equals() isn't always as easy as it seems, see ' Secrets of equals() ' for more information.",Objects The equals method,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
173,"The java.lang.Object.finalize() method is called exactly once before the garbage collector frees the memory for object.  A class overrides finalize to perform any clean up that must be performed before an object is reclaimed.  Most objects do not need to override finalize .There is no guarantee when the finalize method will be called, or the order in which the finalize method will be called for multiple objects.  If the JVM exits without performing garbage collection, the OS may free the objects, in which case the finalize method doesn't get called.The finalize method should always be declared protected to prevent other classes from calling the finalize method.protected void finalize() throws Throwable { ... }",Objects The finalize method,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
174,The java.lang.Object.getClass() method returns the java.lang.Class object for the class that was used to instantiate the object.  The class object is the base class of reflection in Java.  Additional reflection support is provided in the java.lang.reflect package.,Objects The getClass method,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
175,"The java.lang.Object.hashCode() method returns an integer ( int ). This integer can be used to distinguish objects although not completely. It quickly separates most of the objects and those with the same hash code are separated later in another way. It is used by the classes that provide associative arrays, for instance, those that implement the java.util.Map interface
. They use the hash code to store the object in the associative array. A good hashCode implementation will return a hash code:Stable: does not change  Evenly distributed: the hash codes of unequal objects tend to be unequal and the hash codes are evenly distributed across integer values.The second point means that two different objects can have the same hash code so two objects with the same hash code are not necessarily the same !Since associative arrays depend on both the equals and hashCode methods, there is an important contract between these two methods that must be maintained if the objects are to be inserted into a Map :For two objects a and b  a.equals(b) == b.equals(a)  if a.equals(b) then a.hashCode() == b.hashCode()  but if a.hashCode() == b.hashCode() then a.equals(b)In order to maintain this contract, a class that overrides the equals method must also override the hashCode method, and vice versa, so that hashCode is based on the same properties (or a subset of the properties) as equals .A further contract that the map has with the object is that the results of the hashCode and equals methods will not change once the object has been inserted into the map.  For this reason, it is generally a good practice to base the hash function on immutable properties of the object.",Objects The hashCode method,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
176,The java.lang.Object.toString() method returns a java.lang.String that contains a text representation of the object.  The toString method is implicitly called by the compiler when an object operand is used with the string concatenation operators ( + and += ).,Objects The toString method,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
177,"Every object has two wait lists for threads associated with it.  One wait list is used by the synchronized keyword to acquire the mutex lock associated with the object.  If the mutex lock is currently held by another thread, the current thread is added to the list of blocked threads waiting on the mutex lock.  The other wait list is used for signaling between threads accomplished through the wait and notify and notifyAll methods.Use of wait/notify allows efficient coordination of tasks between threads.  When one thread needs to wait for another thread to complete an operation, or needs to wait until an event occurs, the thread can suspend its execution and wait to be notified when the event occurs.  This is in contrast to polling, where the thread repeatedly sleeps for a short period of time and then checks a flag or other condition indicator.  Polling is both more computationally expensive, as the thread has to continue checking, and less responsive since the thread won't notice the condition has changed until the next time to check.",Objects The wait and notify thread signaling methods,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
178,"There are three overloaded versions of the wait method to support different ways to specify the timeout value: java.lang.Object.wait() , java.lang.Object.wait(long) and java.lang.Object.wait(long, int) .  The first method uses a timeout value of zero (0), which means that the wait does not timeout; the second method takes the number of milliseconds as a timeout; the third method takes the number of nanoseconds as a timeout, calculated as 1000000 * timeout + nanos .The thread calling wait is blocked (removed from the set of executable threads) and added to the object's wait list.  The thread remains in the object's wait list until one of three events occurs:another thread calls the object's notify or notifyAll method;  another thread calls the thread's java.lang.Thread.interrupt method; or  a non-zero timeout that was specified in the call to wait expires.The wait method must be called inside of a block or method synchronized on the object.  This insures that there are no race conditions between wait and notify .  When the thread is placed in the wait list, the thread releases the object's mutex lock.  After the thread is removed from the wait list and added to the set of executable threads, it must acquire the object's mutex lock before continuing execution.",Objects The wait methods,"https://en.wikibooks.org//wiki/Java_Programming/Classes,_Objects_and_Types"
179,"If your application becomes quite big, you may have lots of classes. Although you can browse them in their alphabetic order, it becomes confusing. So your application classes can be sorted into packages .A package is a name space that mainly contains classes and interfaces. For instance, the standard class ArrayList is in the package java.util . For this class, java.util.ArrayList is called its fully qualified name because this syntax has no ambiguity. Classes in different packages can have the same name. For example, you have the two classes java.util.Date and java.sql.Date which are not the same. If no package is declared in a class, its package is the default package.",Packages ,https://en.wikibooks.org//wiki/Java_Programming/Packages
180,"In a class, a package is declared at the top of the source code using the keyword package :If your class is declared in a package, say business , your class must be placed in a subfolder called business from the root of your application folder. This is how the compiler and the class loader find the Java files on the file system. You can declare your class in a subpackage, say engine . So the full package is business.engine and the class must be placed in a subsubfolder called engine in the subfolder business (not in a folder called business.engine ).",Packages Package declaration,https://en.wikibooks.org//wiki/Java_Programming/Packages
181,"The simpliest way to use a class declared in a package is to prefix the class name with its package:If you are using the class from a class in the same package, you don't have to specify the package. If another class with the same name exists in another package, it will use the local class.The syntax above is a bit verbose. You can import the class by using the import Java keyword at the top of the file and then only specify its name:Note that you can't import two classes with the same name in two different packages.The classes Integer and String belongs to the package java.lang but they don't need to be imported as the java.lang package is implicitly imported in all classes.",Packages Import and class usage,https://en.wikibooks.org//wiki/Java_Programming/Packages
182,"It is possible to import an entire package, using an asterisk:While it may seem convenient, it may cause problems if you make a typographical error.  For example, if you use the above import to use JFrame, but then type JFraim frame = new JFraim(); , the Java compiler will report an error similar to ""Cannot find symbol: JFraim"".  Even though it seems as if it was imported,  the compiler is giving the error report at the first mention of JFraim, which is half-way through your code, instead of the point where you imported JFrame along with everything else in javax.swing.If you change this to import javax.swing.JFraim; the error will be at the import instead of within your code.Furthermore, if you import javax.swing.*; and import java.util.*; , and javax.swing.Queue is later added in a future version of Java, your code that uses Queue (java.util) will fail to compile.  This particular example is fairly unlikely, but if you are working with non-Oracle libraries, it may be more likely to happen.",Packages Wildcard imports,https://en.wikibooks.org//wiki/Java_Programming/Packages
183,"A package name should start with a lower character. This eases to distinguish a package from a class name. In some operating systems, the directory names are not case sensitive. So package names should be lowercase.The Java package needs to be unique across Vendors to avoid name collisions. For that reason Vendors usually use their domain name in reverse order. That is guaranteed to be unique.  For example a company called Your Company Inc. , would use a package name something like this: com.yourcompany.yourapplicationname.yourmodule.YourClass .",Packages Package convention,https://en.wikibooks.org//wiki/Java_Programming/Packages
184,"If you are importing library packages and classes that reside in a .jar file, you must ensure that the file is in the current classpath (both at compile- and execution-time). Apart from this requirement, importing these packages and classes is the same as if they were in their full, expanded, directory structure.",Packages Importing packages from .jar files,https://en.wikibooks.org//wiki/Java_Programming/Packages
185,"For example, to compile and run a class from a project's top directory (that contains the two directories /source and /libraries ) you could use the following command:And then to run it, similarly:The above is simplified, and demands that MainClass be in the default package, or a package called source , which isn't very desirable.",Packages Javac,https://en.wikibooks.org//wiki/Java_Programming/Packages
186,"With BlueJ just click on Tools, Preferences, Libraries , and add the .jar one by one.",Packages BlueJ,https://en.wikibooks.org//wiki/Java_Programming/Packages
187,"An array is similar to a table of objects or primitive types, keyed by index. You may have noticed the strange parameter of the default main() method ( String[] args ) since the beginning of the book. It is an array. Let's handle this parameter:In the code listing 3.15 , the array is args . It is an array of String objects (here those objects are the words that have been typed by the user at the program launching). At line 4, One contained object is accessed using its index in the array. You can see that its value is printed on the standard output. Note that the strings have been put in the array with the right order.",Arrays ,https://en.wikibooks.org//wiki/Java_Programming/Arrays
188,"In Java, an array is an object. This object has a given type for the contained primitive types or objects ( int , char , String , ...). An array can be declared in several ways:Those syntaxes are identical but the first one is recommended. It can also be instantiated in several ways:At line 1, we instantiate an array of 10 items that get the default value (which is 0 for int ). At lines 2 and 3, we instantiate arrays of 10 given items. It will each be given an index according to its order. We can know the size of the array using the length attribute:Arrays are allocated at runtime, so the specified size in an array creation expression may be a variable (rather than a constant expression as in C). However, the size of an instantiated array never changes. If you need to change the size, you have to create a new instance. Items can be accessed by their index. Beware! The first index is 0:If you attempt to access to a too high index or negative index, you will get an ArrayIndexOutOfBoundsException .Test your knowledge  Question 3.20 : Consider the following code:      Question 3.20: Question20.java  1 public  class  Question20  {  2  public  static  void  main ( String []  args )  {  3  String []  listOfWord  =  { ""beggars"" ,  ""can't"" ,  ""be"" ,  ""choosers"" };  4  System . out . println ( listOfWord [ 1 ]);  5  System . out . println ( listOfWord [ listOfWord . length - 1 ]);  6  }  7 }    What will be printed in the standard output?  Answer      Output for Question 3.20  can't
choosers   Indexes start at 0. So the index 1 point at the second string ( can't ). There are 4 items so the size of the array is 4. Hence the item pointed by the index 3 is the last one ( choosers ).",Arrays Fundamentals,https://en.wikibooks.org//wiki/Java_Programming/Arrays
189,"Actually, there are no two-dimensional arrays in Java. However, an array can contain any class of object, including an array:It's not exactly equivalent to two-dimensional arrays because the size of the sub-arrays may vary. The sub-array reference can even be null. Consider:Note that the length of a two-dimensional array is the number of one-dimensional arrays it contains. In the above example, weirdTwoDimArray.length is 3, whereas weirdTwoDimArray[2].length is 5.In the code section 3.58 , we defined an array that has three elements, each element contains an array having 5 elements. We could create the array having the 5 elements first and use that one in the initialize block.Test your knowledge  Question 3.21 : Consider the following code:      Question 3.21: The alphabet.  1 String [][]  alphabet  =  {{ ""a"" ,  ""b"" ,  ""c"" ,  ""d"" ,  ""e"" },  2  { ""f"" ,  ""g"" ,  ""h"" ,  ""i"" ,  ""j"" },  3  { ""k"" ,  ""l"" ,  ""m"" ,  ""n"" ,  ""o"" },  4  { ""p"" ,  ""q"" ,  ""r"" ,  ""s"" ,  ""t"" },  5  { ""u"" ,  ""v"" ,  ""w"" ,  ""x"" ,  ""y"" },  6  { ""z"" }};    Print the whole alphabet in the standard output.  Answer      Question 3.21: Answer21.java  1 public  class  Answer21  {  2  public  static  void  main ( String []  args )  {  3  String [][]  alphabet  =  {{ ""a"" ,  ""b"" ,  ""c"" ,  ""d"" ,  ""e"" },  4  { ""f"" ,  ""g"" ,  ""h"" ,  ""i"" ,  ""j"" },  5  { ""k"" ,  ""l"" ,  ""m"" ,  ""n"" ,  ""o"" },  6  { ""p"" ,  ""q"" ,  ""r"" ,  ""s"" ,  ""t"" },  7  { ""u"" ,  ""v"" ,  ""w"" ,  ""x"" ,  ""y"" },  8  { ""z"" }};  9  10  for  ( int  i  =  0 ;  i  <  alphabet . length ;  i ++)  {  11  for  ( int  j  =  0 ;  j  <  alphabet [ i ]. length ;  j ++)  {  12  System . out . println ( alphabet [ i ][ j ]);  13  }  14  }  15  }  16 }    i will be the indexes of the main array and j will be the indexes of all the sub-arrays. We have to first iterate on the main array. We have to read the size of the array. Then we iterate on each sub-array. We have to read the size of each array as it may vary. Doing so, we iterate on all the sub-array items using the indexes. All the items will be read in the right order.",Arrays Two-Dimensional Arrays,https://en.wikibooks.org//wiki/Java_Programming/Arrays
190,"The java.lang.Math class allows the use of many common mathematical functions that can be used while creating programs.Since it is in the java.lang package, the Math class does not need to be imported. However, in programs extensively utilizing these functions, a static import can be used.",Mathematical functions ,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
191,There are two constants in the Math class that are fairly accurate approximations of irrational mathematical numbers.,Mathematical functions Math constants,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
192,"The Math.E constant represents the value of Euler's number ( e ), the base of the natural logarithm.",Mathematical functions Math.E,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
193,"The Math.PI constant represents the value of pi , the ratio of a circle's circumference to its diameter.",Mathematical functions Math.PI,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
194,There are several methods in the Math class that deal with exponential functions.,Mathematical functions Exponential methods,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
195,"The power method, double Math. pow (double, double) , returns the first parameter to the power of the second parameter.  For example, a call to Math.pow(2, 10) will return a value of 1024 (2 10 ).The Math. exp (double) method, a special case of pow , returns e to the power of the parameter. In addition, double Math. expm1 (double) returns ( e x - 1). Both of these methods are more accurate and convenient in these special cases.Java also provides special cases of the pow function for square roots and cube roots of doubles, double Math. sqrt (double) and double Math. cbrt (double) .",Mathematical functions Exponentiation,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
196,"Java has no general logarithm function; when needed this can be simulated using the change-of-base theorem.double Math. log ( double ) returns the natural logarithm of the parameter ( not the common logarithm , as its name suggests!).double Math. log10 ( double ) returns the common (base-10) logarithm of the parameter.double Math. log1p ( double ) returns ln(parameter+1). It is recommended for small values.",Mathematical functions Logarithms,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
197,"The trigonometric methods of the Math class allow users to easily deal with trigonometric functions in programs. All accept only double s. Please note that all values using these methods are initially passed and returned in radians , not degrees .  However, conversions are possible.",Mathematical functions Trigonometric and hyperbolic methods,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
198,"The three main trigonometric methods are Math. sin (x) , Math. cos (x) , and Math. tan (x) , which are used to find the sine, cosine, and tangent, respectively, of any given number. So, for example, a call to Math.sin(Math.PI/2) would return a value of about 1.  Although methods for finding the cosecant, secant, and cotangent are not available, these values can be found by taking the reciprocal of the sine, cosine, and tangent, respectively.  For example, the cosecant of pi/2 could be found using 1/Math.sin(Math.PI/2) .",Mathematical functions Trigonometric functions,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
199,"Java provides inverse counterparts to the trigonometric functions: Math. asin (x) , and Math. acos (x) , Math. atan (x) .",Mathematical functions Inverse trigonometric functions,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
200,"In addition, hyperbolic functions are available: Math. sinh (x) , Math. cosh (x) , and Math. tanh (x) .",Mathematical functions Hyperbolic functions,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
201,"To convert between degree and radian measures of angles, two methods are available, Math. toRadians (x) and Math. toDegrees (x) .  While using Math.toRadians(x) , a degrees value must be passed in, and that value in radians (the degree value multiplied by pi/180) will be returned.  The Math.toDegrees(x) method takes in a value in radians and the value in degrees (the radian value multiplied by 180/pi) is returned.",Mathematical functions Radian/degree conversion,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
202,"The absolute value method of the Math class is compatible with the int , long , float , and double types. The data returned is the absolute value of parameter (how far away it is from zero) in the same data type.  For example:In this example, result will contain a value of 3.",Mathematical functions Absolute value: Math.abs,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
203,"These methods are very simple comparing functions.  Instead of using if ... else statements, one can use the Math.max(x1, x2) and Math.min(x1, x2) methods.  The Math.max(x1, x2) simply returns the greater of the two values, while the Math.min(x1, x2) returns the lesser of the two.  Acceptable types for these methods include int , long , float , and double .",Mathematical functions Maximum and minimum values,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
204,"Java 1.5 and 1.6 introduced several non-mathematical functions specific to the computer floating-point representation of numbers.Math. ulp ( double ) and Math. ulp ( float ) return an ulp, the smallest value which, when added to the argument, would be recognized as larger than the argument.Math.copySign returns the value of the first argument with the sign of the second argument. It can be used to determine the sign of a zero value.Math.getExponent returns (as an int ) the exponent used to scale the floating-point argument in computer representation.",Mathematical functions Functions dealing with floating-point representation,https://en.wikibooks.org//wiki/Java_Programming/Mathematical_functions
205,"The integer primitive type with the largest range of value is the long , from -2 63 to 2 63 -1. If you need greater or lesser values, you have to use the BigInteger class in the package java.math . A BigInteger object can represent any integer (as large as the RAM on the computer can hold) as it is not mapped on a primitive type. Respectively, you need to use the BigDecimal class for great decimal numbers.However, as these perform much slower than primitive types, it is recommended to use primitive types when it is possible.",Large numbers ,https://en.wikibooks.org//wiki/Java_Programming/Large_numbers
206,"The BigInteger class represents integers of almost any size. As with other objects, they need to be constructed.  Unlike regular numbers, the BigInteger represents an immutable object - methods in use by the BigInteger class will return a new copy of a BigInteger .To instantiate a BigInteger , you can create it from either byte array, or from a string.  For example:BigInteger cannot use the normal Java operators . They use the methods provided by the class.It is possible to convert to a long , but the long may not be large enough.",Large numbers BigInteger,https://en.wikibooks.org//wiki/Java_Programming/Large_numbers
207,"To generate random numbers the Math.random() method can be used, which returns a double , greater than or equal to 0.0 and less than 1.0.The following code returns a random integer between n and m (where n <= randomNumber < m ):Alternatively, the java.util.Random class provides methods for generating random boolean s, byte s, float s, int s, long s and 'Gaussians' ( double s from a normal distribution with mean 0.0 and standard deviation 1.0). For example, the following code is equivalent to that above:As an example using random numbers, we can make a program that uses a Random object to simulate flipping a coin 20 times:Of course, if you run the program you will probably get different results.",Random numbers ,https://en.wikibooks.org//wiki/Java_Programming/Random_numbers
208,"Most Java program text consists of ASCII characters, but any Unicode character can be used as part of identifier names, in comments, and in character and string literals. For example,  (which is the Greek Lowercase Letter pi ) is a valid Java identifier:and in a string literal:",Unicode ,https://en.wikibooks.org//wiki/Java_Programming/Unicode
209,"Unicode characters can also be expressed through Unicode Escape Sequences. Unicode escape sequences may appear anywhere in a Java source file (including inside identifiers, comments, and string literals ).Unicode escape sequences consist ofa backslash ' \ ' (ASCII character 92, hex 0x5c),  a ' u ' (ASCII 117, hex 0x75)  optionally one or more additional ' u ' characters, and  four hexadecimal digits (the characters ' 0 ' through ' 9 ' or ' a ' through ' f ' or ' A ' through ' F ').Such sequences represent the UTF-16 encoding of a Unicode character. For example, 'a' is equivalent to '\u0061'. This escape method does not support characters beyond U+FFFF or you have to make use of surrogate pairs. [1]Any and all characters in a program may be expressed in Unicode escape characters, but such programs are not very readable, except by the Java compiler - in addition, they are not very compact.One can find a full list of the characters here . may also be represented in Java as the Unicode escape sequence  \u03C0 . Thus, the following is a valid, but not very readable, declaration and assignment:The following demonstrates the use of Unicode escape sequences in other Java syntax:Note that a Unicode escape sequence functions just like any other character in the source code. E.g., \u0022 (double quote, "") needs to be quoted in a string just like "".",Unicode Unicode escape sequences,https://en.wikibooks.org//wiki/Java_Programming/Unicode
210,"The language distinguishes between bytes and characters. Characters are stored internally using UCS-2, although as of J2SE 5.0, the language also supports using UTF-16 and its surrogates. Java program source may therefore contain any Unicode character.The following is thus perfectly valid Java code; it contains Chinese characters in the class and variable names as well as in a string literal :",Unicode International language support,https://en.wikibooks.org//wiki/Java_Programming/Unicode
211,"A comment allows to insert text that will not be compiled nor interpreted. It can appear anywhere in the source code where whitespaces are allowed.It is useful for explaining what the source code does by:explaining the adopted technical choice: why this given algorithm and not another, why calling this given method...  explaining what should be done in the next steps (the TODO list): improvement, issue to fix...  giving the required explanation to understand the code and be able to update it yourself later or by other developers.It can also be used to make the compiler ignore a portion of code: temporary code for debugging, code under development...",Comments ,https://en.wikibooks.org//wiki/Java_Programming/Comments
212,"The comments in Java use the same syntax as in C++ .An end-of-line comment starts with two slashes and ends with the end of the line. This syntax can be used on a single line too.A comment on several lines is framed with '/' + '*' and '*' + '/'.By convention, subsequent lines of slash-star comments begin with a star aligned under the star in the open comment sequence, but this is not required. Never nest a slash-star comment in another slash-star comment. If you accidentally nest such comments, you will probably get a syntax error from the compiler soon after the first star-slash sequence.If you need to have the sequence */ inside a comment you can use html numeric entities: *&#47; .Slash-star comments may also be placed between any Java tokens, though not recommended:However, comments are not parsed as comments when they occur in string literals.It results in a 33 character string.Test your knowledge  Question 3.26 : Consider the following code:      Question 3.26: Commented code.  int a = 0;
// a = a + 1;
a = a + 1;
/*
a = a + 1;
*/
a = a + 1;
// /*
a = a + 1;
// */
a = a /*+ 1*/;
a = a + 1; // a = a + 1;
System.out.println(""a="" + a);   What is printed in the standard output?  Answer      Output for Answer 3.26  a=4       Answer 3.26: Commented code.  1 int  a  =  0 ;  2 // a = a + 1;  3 a  =  a  +  1 ;  4 /*  5 a = a + 1;  6 */  7 a  =  a  +  1 ;  8 // /*  9 a  =  a  +  1 ;  10 // */  11 a  =  a  /*+ 1*/ ;  12 a  =  a  +  1 ;  // a = a + 1;  13 System . out . println ( ""a=""  +  a );    The highlighted lines are code lines but line 11 does nothing and only the first part of line 12 is code.",Comments Syntax,https://en.wikibooks.org//wiki/Java_Programming/Comments
213,"Be aware that Java still interprets Unicode sequences within comments. For example, the Unicode sequence \u002a\u002f (whose codepoints correspond to */) is processed early in the Java compiler's lexical scanning of the source file, even before comments are processed, so this is a valid star-slash comment in Java:and is lexically equivalent to(The '*' character is Unicode 002A and the '/' character is Unicode 002F .)Similar caveats apply to newline characters in slash-slash comments.For example:That is because \u000a is Unicode for a new line, making the compiler think that you have added a new line when you haven't.",Comments Comments and unicode,https://en.wikibooks.org//wiki/Java_Programming/Comments
214,"Keywords are special tokens in the language which have reserved use in the language. Keywords may not be used as identifiers in Java  you cannot declare a field whose name is a keyword, for instance.Examples of keywords are the primitive types, int and boolean ; the control flow statements for and if ; access modifiers such as public , and special words which mark the declaration and definition of Java classes, packages, and interfaces: class , package , interface .Below are all the Java language keywords:abstract  assert (since Java 1.4)  boolean  break  byte  case  catch  char  class  const (not used)  continue  default  do  double  else  enum (since Java 5.0)  extends  final  finally  float  for  goto (not used)  if  implements  import  instanceof  int  interface  long  native  new  package  private  protected  public  return  short  static  strictfp (since Java 1.2)  super  switch  synchronized  this  throw  throws  transient  try  void  volatile  whileIn addition, the identifiers null , true , and false denote literal values and may not be used to create identifiers.",Keywords ,https://en.wikibooks.org//wiki/Java_Programming/Keywords
215,"abstract is a Java keyword. It can be applied to a class and methods. An abstract class cannot be directly instantiated. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and after the static keyword. A non-abstract class is a concrete class. An abstract class cannot be final .Only an abstract class can have abstract methods. An abstract method is only declared, not implemented:An abstract method cannot be final , static nor native . Either you instantiate a concrete sub-class, either you instantiate the abstract class by implementing its abstract methods alongside a new statement:A private method cannot be abstract .",Keywords abstract,https://en.wikibooks.org//wiki/Java_Programming/Keywords
216,"assert is a Java keyword used
to define an assert statement .
An assert statement is used to declare an expected boolean condition in a program.
If the program is running with assertions enabled, then the condition
is checked at runtime. If the condition is false, the Java runtime system throws an AssertionError .Assertions may be declared using the following syntax:expression1 is a boolean that will throw the assertion if it is false.  When it is thrown, the assertion error exception is created with the parameter expression2 (if applicable).An example:Assertions are usually used as a debugging aid.  They should not be used instead of validating arguments to public methods, or in place of a more precise runtime error exception.Assertions are enabled with the Java -ea or -enableassertions runtime option. See your Java environment documentation for additional options
for controlling assertions.",Keywords assert,https://en.wikibooks.org//wiki/Java_Programming/Keywords
217,"boolean is a keyword which designates the boolean  primitive type . There are only two possible boolean values: true and false . The default value for boolean fields is false .The following is a declaration of a private  boolean field named initialized , and its use in a method named synchronizeConnection .The previous code only creates a connection once (at the first method call). Note that there is no automatic conversion between integer types (such as int ) to boolean as is possible in some languages like C . Instead, one must use an equivalent expression such as (i!= 0) which evaluates to true if i is not zero.",Keywords boolean,https://en.wikibooks.org//wiki/Java_Programming/Keywords
218,break is a Java keyword.Jumps (breaks) out from a loop. Also used at switch statement.For example:See also:Java Programming/Keywords/switch,Keywords break,https://en.wikibooks.org//wiki/Java_Programming/Keywords
219,"byte is a keyword which designates
the 8 bit signed integer primitive type .The java.lang.Byte class is the nominal
wrapper class when you need to store a byte value
but an object reference is required.Syntax:byte <variable-name> = <integer-value>;For example:orThe number 65 is the code for 'A' in ASCII .See also:Java Programming/Primitive Types",Keywords byte,https://en.wikibooks.org//wiki/Java_Programming/Keywords
220,"case is a Java keyword.This is part of the switch statement, to find if the value passed to the switch statement matches a value followed by case.For example:",Keywords case,https://en.wikibooks.org//wiki/Java_Programming/Keywords
221,"catch is a keyword.It's part of a try block. If an exception is thrown inside a try block, the exception will be compared to any of the catch part of the block. If the exception match with one of the exception in the catch part, the exception will be handled there.For example:See also:Java Programming/Keywords/try",Keywords catch,https://en.wikibooks.org//wiki/Java_Programming/Keywords
222,"char is a keyword. It defines a character primitive type . char can be created from character literals and numeric representation. Character literals consist of a single quote character ( ' ) (ASCII 39, hex 0x27), a single character, and a close quote ( ' ), such as 'w' . Instead of a character, you can also use unicode escape sequences , but there must be exactly one.Syntax:65 is the numeric representation of character 'A' , or its ASCII code.The nominal wrapper class is the java.lang.Character class when you need to store a char value but an object reference is required.See also:Java Programming/Primitive Types",Keywords char,https://en.wikibooks.org//wiki/Java_Programming/Keywords
223,"class is a Java keyword
which begins the declaration and definition of a class .The general syntax of a class declaration, using Extended Backus-Naur Form , isclass-declaration::= [ access-modifiers ] class  identifier [ extends-clause ] [ implements-clause ] class-body extends-clause::= extends  class-name implements-clause::= implements  interface-names interface-names::= interface-name [ ,  interface-names ]
class-body::= { [ member-declarations ] } member-declarations = member-declaration [ member-declarations ]
member-declaration = field-declaration | initializer | constructor | method-declaration | class-declarationThe extends word is optional. If omitted, the class extends the Object class, as all Java classes inherit from it.See also:Java Programming/Keywords/new",Keywords class,https://en.wikibooks.org//wiki/Java_Programming/Keywords
224,"const is a reserved keyword , presently not being used.In other programming languages, such as C, const is often used to declare a constant. However, in Java, final is used instead.",Keywords const,https://en.wikibooks.org//wiki/Java_Programming/Keywords
225,"continue is a Java keyword. It skips the remainder of the loop and continues with the next iteration.For example:results in0
1
2
3
4
6
7",Keywords continue,https://en.wikibooks.org//wiki/Java_Programming/Keywords
226,Java Programming/Statements,Keywords See also,https://en.wikibooks.org//wiki/Java_Programming/Keywords
227,"default is a Java keyword.This is an optional part of the switch statement, which only executes if none of the above cases are matched.See also:Java Programming/Keywords/switch",Keywords default,https://en.wikibooks.org//wiki/Java_Programming/Keywords
228,"do is a Java keyword.It starts a do-while looping block. The do-while loop is functionally similar to the while loop, except the condition is evaluated after the statements executeSyntax:For example:See also:Java Programming/Statements  Java Programming/Keywords/for  Java Programming/Keywords/while",Keywords do,https://en.wikibooks.org//wiki/Java_Programming/Keywords
229,"double is a keyword which designates
the 64 bit float primitive type .The java.lang.Double class is the nominal wrapper class when you need to store a double value but an object reference is required.Syntax:double <variable-name> = <float-value>;For example:See also:Java Programming/Primitive Types",Keywords double,https://en.wikibooks.org//wiki/Java_Programming/Keywords
230,"else is a Java keyword. It is an optional part of a branching statement. It starts the 'false' statement block.The general syntax of a if , using Extended Backus-Naur Form , isbranching-statement::= if  condition-clause  single-statement | block-statement [ else  single-statement | block-statement ]
 
condition-clause    ::= ( Boolean Expression ) single-statement    ::= Statement block-statement     ::= {  Statement [ Statement ] }For example:See also:Java Programming/Keywords/if",Keywords else,https://en.wikibooks.org//wiki/Java_Programming/Keywords
231,"This enumeration constant then can be passed in to methods:An enumeration may also have parameters:It is also possible to let an enumeration implement interfaces other than java.lang.Comparable and java.io.Serializable , which are already implicitly implemented by each enumeration:",Keywords enum,https://en.wikibooks.org//wiki/Java_Programming/Keywords
232,"extends is a Java keyword.Used in class and interface definition to declare the class or interface that is to be extended.Syntax:In Java 1.5 and later, the ""extends"" keyword is also used to specify an upper bound on a type parameter in Generics.See also:Java Programming/Creating Objects  Java Programming/Keywords/class",Keywords extends,https://en.wikibooks.org//wiki/Java_Programming/Keywords
233,"final is a keyword. Beware! It has distinct meanings depending whether it is used for a class, a method, or for a variable. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and after the static keyword.",Keywords final,https://en.wikibooks.org//wiki/Java_Programming/Keywords
234,"The final keyword only allows a single assignment for the variable. That is to say, once the variable has been assigned, its value is in read-only. If the variable is a primitive type, its value will no longer change. If it is an object, only its reference will no longer change. Keep in mind that its value can still be changed.A final variable is often used for universal constants, such as pi :The final keyword can also be used for method parameters:It is useful for methods that use side effects to update some objects. Such methods modify the content of an object passed in parameter. The method caller will receive the object update. This will fail if the object parameter has been reassigned in the method. Another object will be updated instead. Final method parameter can also be used to keep the code clean.The final keyword is similar to const in other languages and the readonly keyword in C# . A final variable cannot be volatile .",Keywords For a variable,https://en.wikibooks.org//wiki/Java_Programming/Keywords
235,The final keyword forbids the creation of a subclass. It is the case of the Integer or String class.A final class cannot be abstract . The final keyword is similar to sealed keyword in C# .,Keywords For a class,https://en.wikibooks.org//wiki/Java_Programming/Keywords
236,The final keyword forbids to overwrite the method in a subclass. It is useless if the class is already final and a private method is implicitly final . A final method cannot be abstract .,Keywords For a method,https://en.wikibooks.org//wiki/Java_Programming/Keywords
237,"The final keyword is mostly used to guarantee a good usage of the code. For instance (non- static ) methods, this allows the compiler to expand the method (similar to an inline function) if the method is small enough. Sometimes it is required to use it. For instance, a nested class can only access the members of the top-level class if they are final.See also Access Modifiers .",Keywords Interest,https://en.wikibooks.org//wiki/Java_Programming/Keywords
238,"finally is a keyword which is an optional ending part of the try block.The code inside the finally block will always be executed. This is also true for cases when there is an exception or even executed return statement in the try block.Three things can happen in a try block. First, no exception is thrown:You can see that we have passed in the try block, then we have executed the finally block and we have continued the execution. Now, a caught exception is thrown:We have passed in the try block until where the exception occurred, then we have executed the matching catch block, the finally block and we have continued the execution. Now, an uncaught exception is thrown:We have passed in the try block until where the exception occurred and we have executed the finally block. NO CODE after the try-catch block has been executed. If there is an exception that happens before the try-catch block, the finally block is not executed.If return statement is used inside finally, it overrides the return statement in the try-catch block.  For instance, the constructwill return 12, not 11. Professional code almost never contains statements that alter execution order (like return , break , continue ) inside the finally block, as such code is more difficult to read and maintain.",Keywords finally,https://en.wikibooks.org//wiki/Java_Programming/Keywords
239,float is a keyword which designates the 32 bit float primitive type .The java.lang.Float class is the nominal wrapper class when you need to store a float value but an object reference is required.Syntax:float <variable-name> = <float-value>;For example:See also:Java Programming/Primitive Types,Keywords float,https://en.wikibooks.org//wiki/Java_Programming/Keywords
240,"for is a Java keyword.It starts a looping block.The general syntax of a for , using Extended Backus-Naur Form , isfor-looping-statement::= for  condition-clause  single-statement | block-statement condition-clause    ::= ( before-statement; Boolean Expression ; after-statement ) single-statement    ::= Statement block-statement     ::= {  Statement [ Statement ] }For example:See also:Java Programming/Keywords/while  Java Programming/Keywords/do",Keywords for,https://en.wikibooks.org//wiki/Java_Programming/Keywords
241,"goto is a reserved keyword , presently not being used.",Keywords goto,https://en.wikibooks.org//wiki/Java_Programming/Keywords
242,"if is a Java keyword. It starts a branching statement.The general syntax of a if , using Extended Backus-Naur Form , isbranching-statement::= if  condition-clause  single-statement | block-statement [ else  single-statement | block-statement ]
 
condition-clause    ::= ( Boolean Expression ) single-statement    ::= Statement block-statement     ::= {  Statement [ Statements ] }For example:See also:Java Programming/Keywords/else",Keywords if,https://en.wikibooks.org//wiki/Java_Programming/Keywords
243,implements is a Java keyword.Used in class definition to declare the Interfaces that are to be implemented by the class.Syntax:See also:Java Programming/Creating Objects  Java Programming/Keywords/class  Java Programming/Keywords/interface,Keywords implements,https://en.wikibooks.org//wiki/Java_Programming/Keywords
244,"import is a Java keyword.It declares a Java class to use in the code below the import statement.  Once a Java class is declared, then the class name can be used in the code without specifying the package the class belongs to.Use the '*' character to declare all the classes belonging to the package.Syntax:The static import construct allows unqualified access to static members without inheriting from the type containing the static members:import static java.lang.Math.PI;Once the static members have been imported, they may be used without qualification:double r = cos(PI * theta);Caveat: use static import very sparingly to avoid polluting the program's namespace!See also:Java Programming/Packages",Keywords import,https://en.wikibooks.org//wiki/Java_Programming/Keywords
245,"instanceof is a keyword.It checks if an object reference is an instance of a type, and returns a boolean value;The <object-reference> instanceof  Object will return true for all non-null object references, since all Java objects are inherited from Object . instanceof will always return false if <object-reference> is null .Syntax:<object-reference> instanceof TypeNameFor example:Run the program:java TestThe output:""It is a Java Object and It is a Fruit and it is an Apple""  ""It is a Java Object and It is a Fruit and it is an Apple""  ""It is a Java Object and It is a Fruit and it is an Orange""  ""It is a Java Object and It is a Fruit and it is an Orange""Note that the instanceof operator can also be applied to interfaces. 
For example, if the example above was enhanced with the interfaceand the classes modified such that they implemented this interfacewe could ask if our object were edible.",Keywords instanceof,https://en.wikibooks.org//wiki/Java_Programming/Keywords
246,int is a keyword which designates the 32 bit signed integer primitive type .The java.lang.Integer class is the nominal wrapper class when you need to store an int value but an object reference is required.Syntax:int <variable-name> = <integer-value>;For example:See also:Java Programming/Primitive Types,Keywords int,https://en.wikibooks.org//wiki/Java_Programming/Keywords
247,interface is a Java keyword. It starts the declaration of a Java Interface.For example:See also:Java Programming/Keywords/new,Keywords interface,https://en.wikibooks.org//wiki/Java_Programming/Keywords
248,long is a keyword which designates the 64 bit signed integer primitive type .The java.lang.Long class is the nominal wrapper class when you need to store a long value but an object reference is required.Syntax:long <variable-name> = <integer-value>;For example:See also:Java Programming/Primitive Types,Keywords long,https://en.wikibooks.org//wiki/Java_Programming/Keywords
249,"native is a java keyword. It marks a method, that it will be implemented in other languages, not in Java. The method is declared without a body and cannot be abstract . It works together with JNI (Java Native Interface) .Syntax:[ public | protected | private ] native method();Native methods were used in the past to write performance critical sections but with java getting faster this is now less common. Native methods are currently needed whenYou need to call from java a library, written in another language.  You need to access system or hardware resources that are only reachable from the other language (typically C ). Actually, many system functions that interact with real computer (disk and network IO, for instance) can only do this because they call native code.To complete writing native method, you need to process your class with javah tool that will generate a header code in C. You then need to provide implementation of the header code, produce dynamically loadable library ( .so under Linux, .dll under Windows) and load it (in the simplest case with System.load(library_file_name) . The code completion is trivial if only primitive types like integers are passed but gets more complex if it is needed to exchange strings or objects from the C code. In general, everything can be on C level, including creation of the new objects and calling back methods, written in java.To call the code in some other language (including C++ ), you need to write a bridge from C to that language. This is usually trivial as most of languages are callable from C.",Keywords native,https://en.wikibooks.org//wiki/Java_Programming/Keywords
250,[1] - JNI programming tutorial.  [2] - JNI specification.,Keywords See also,https://en.wikibooks.org//wiki/Java_Programming/Keywords
251,"new is a Java keyword. It creates a Java object and allocates memory for it on the heap. new is also used for array creation, as arrays are also objects.Syntax:<JavaType> <variable> = new <JavaObject>();For example:See also:Java Programming/Creating Objects",Keywords new,https://en.wikibooks.org//wiki/Java_Programming/Keywords
252,"package is a Java keyword. It declares a 'name space' for the Java class.  It must be put at the top of the Java file, it should be the first Java statement line.To ensure that the package name will be unique across vendors, usually the company url is used starting in backword.Syntax:package package;For example:See also:Java Programming/Packages  Java Programming/Keywords/import",Keywords package,https://en.wikibooks.org//wiki/Java_Programming/Keywords
253,"private is a Java keyword which declares a member's access as private. That is, the member is only visible within the class,
not from any other class (including subclasses). The visibility of private members extends to nested classes .Please note: Because access modifiers are not handled at instance level but at class level, private members of an object are visible from other instances of the same class!Syntax:private  void method();See also:Java Programming/Access Modifiers",Keywords private,https://en.wikibooks.org//wiki/Java_Programming/Keywords
254,"protected is a Java keyword.This keyword is an access modifier, used before a method or other class member to signify that the method or variable can only be accessed by elements residing in its own class or classes in the same package (as it would be for the default visibility level) but moreover from subclasses of its own class, including subclasses in foreign packages (if the access is made on an expression, whose type is the type of this subclass).Syntax:protected <returnType> <methodName>(<parameters>);For example:See also:Java Programming/Scope#Access modifiers",Keywords protected,https://en.wikibooks.org//wiki/Java_Programming/Keywords
255,"public is a Java keyword which declares a member's access as public. Public members are visible to all other classes. This means that any other class can access a public field or method. Further, other classes can modify public fields unless the field is declared as final .A best practice is to give fields private access and reserve public access to only the set of methods and final fields that define the class' public constants. This helps with encapsulation and information hiding, since it allows you to change the implementation of a class without affecting the consumers who use only the public API of the class.Below is an example of an immutable public class named Length which maintains private instance fields named units and magnitude but provides a public constructor and two public accessor methods.",Keywords public,https://en.wikibooks.org//wiki/Java_Programming/Keywords
256,"return is a Java keyword.Returns a primitive value, or an object reference, or nothing(void).  It does not return object values, only object references.Syntax:return variable;  // --- Returns variable
or return ;           // --- Returns nothing",Keywords return,https://en.wikibooks.org//wiki/Java_Programming/Keywords
257,short is a keyword. It defines a 16 bit signed integer primitive type.Syntax:short <variable-name> = <integer-value>;For example:See also:Java Programming/Primitive Types,Keywords short,https://en.wikibooks.org//wiki/Java_Programming/Keywords
258,"static is a Java keyword. It can be applied to a field, a method or an inner class . A static field, method or class has a single instance for the whole class that defines it, even if there is no instance of this class in the program. For instance, a Java entry point ( main() ) has to be static. A static method cannot be abstract . It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and before the final keyword:The static items can be called on an instantiated object or directly on the class:Static methods cannot call nonstatic methods. The this current object reference is also not available in static methods.",Keywords static,https://en.wikibooks.org//wiki/Java_Programming/Keywords
259,"Static variables can be used as data sharing amongst objects of the same class. For example to implement a counter that stores the number of objects created at a given time can be defined as so:The counter variable is incremented each time an object is created.Public static variable should not be used, as these become global variables that can be accessed from everywhere in the program. Global constants can be used, however. See below:Static methods can be used for utility functions or for functions that do not belong to any particular object. For example:See also Static methods",Keywords Interest,https://en.wikibooks.org//wiki/Java_Programming/Keywords
260,"strictfp is a java keyword, since Java 1.2 .It makes sure that floating point calculations result precisely the same regardless of the underlying operating system and hardware platform, even if more precision could be obtained.  This is compatible with the earlier version of Java 1.1 .  If you need that use it.Syntax for classes:public  strictfp  class MyClass 
{ 
  //...
}Syntax for methods:public  strictfp  void method() 
{ 
  ...
}See also:http://en.wikipedia.org/wiki/Strictfp",Keywords strictfp,https://en.wikibooks.org//wiki/Java_Programming/Keywords
261,"super is a keyword.It is used inside a sub-class method definition to call a method defined in the super class. Private methods of the super-class cannot be called. Only public and protected methods can be called by the super keyword.  It is also used by class constructors to invoke constructors of its parent class .  Super keyword are not used in static Method.Syntax:super .<method-name>([zero or more arguments]);or:super ([zero or more arguments]);For example:Running the above program:In Java 1.5 and later, the ""super"" keyword is also used to specify a lower bound on a wildcard type parameter in Generics.See also:extends",Keywords super,https://en.wikibooks.org//wiki/Java_Programming/Keywords
262,"switch is a Java keyword.It is a branching operation, based on a number. The 'number' must be either char , byte , short , or int primitive type.Syntax:switch ( <integer-var> )
{ case <label 1 >: <statements>; case <label 2 >: <statements>;
   ... case <label n >: <statements>; default : <statements>;
}When the <integer-var> value match one of the <label>, then:
The statements after the matched label will be executed including the following label's statements, until the end of the switch block, or until a break keyword is reached.For example:The output from the above code is:Case: 3
Execute until breakThe same code can be written with if-else blocks"":See also:Java Programming/Keywords/if",Keywords switch,https://en.wikibooks.org//wiki/Java_Programming/Keywords
263,"synchronized is a keyword.It marks a critical section .  A critical section is where one and only one thread is executing.  So to enter into the marked code the threads are synchronized , only one can enter, the others have to wait. For more information see Synchronizing Threads Methods or [3] .The synchronized keyword can be used in two ways:Create a synchronized block  Mark a method synchronizedA synchronized block is marked as:The syntax to mark a method synchronized is:The synchronization is always associated to an object. If the method is static, the associated object is the class. If the method is non-static, the associated object is the instance. While it is allowed to declare an abstract method as synchronized , it is meaningless to do so since synchronization is an aspect of the implementation, not the declaration, and abstract methods do not have an implementation.",Keywords synchronized,https://en.wikibooks.org//wiki/Java_Programming/Keywords
264,"As an example, we can show a thread-safe version of a singleton:",Keywords Singleton example,https://en.wikibooks.org//wiki/Java_Programming/Keywords
265,"this is a Java keyword. It contains the current object reference.Solves ambiguity between instance variables and parameters .  Used to pass current object as a parameter to another method .Syntax:this .method();
or this .variable;Example #1 for case 1:Example #2 for case 1:",Keywords this,https://en.wikibooks.org//wiki/Java_Programming/Keywords
266,"throw is a keyword; it 'throws' an exception. In a throw statement, the three types of objects that can be thrown are: Exception , java:Throwable , and java:ErrorSyntax:throw <Exception Ref>;For example:",Keywords throw,https://en.wikibooks.org//wiki/Java_Programming/Keywords
267,Java Programming/Keywords/throws,Keywords See also,https://en.wikibooks.org//wiki/Java_Programming/Keywords
268,"throws is a Java keyword. It is used in a method definition to declare the Exceptions to be thrown by the method.Syntax:public myMethod() throws MyException1, MyException2
{MyException1
  ...
}Example:",Keywords throws,https://en.wikibooks.org//wiki/Java_Programming/Keywords
269,"transient is a Java keyword which marks a member variable not to be serialized when it is persisted to streams of bytes.  When an object is transferred through the network, the object needs to be 'serialized'.  Serialization converts the object state to serial bytes. Those bytes are sent over the network and the object is recreated from those bytes.  Member variables marked by the java transient keyword are not transferred; they are lost intentionally.Syntax:private  transient <member-variable>;
or transient  private <member-variable>;For example:See also:Java language specification reference: jls  Serializable Interface. Serializable",Keywords transient,https://en.wikibooks.org//wiki/Java_Programming/Keywords
270,"try is a keyword.It starts a try block. If an Exception is thrown inside a try block, the Exception will be compared to any of the catch part of the block. If the Exception matches with one of the Exceptions in the catch part, the exception will be handled there.Three things can happen in a try block:No exception is thrown: the code in the try block  plus the code in the finally block will be executed  plus the code after the try-catch block is executed  An exception is thrown and a match is found among the catch blocks: the code in the try block until the exception occurred is executed  plus the matched catch block is executed  plus the finally block is executed  plus the code after the try-catch block is executed  An exception is thrown and no match found among the catch blocks: the code in the try block until the exception occurred is executed  plus the finally block is executed  NO CODE after the try-catch block is executedFor example:How the catch-blocks are evaluated see Catching RuleSee also:Java Programming/Keywords/catch  Java Programming/Keywords/finally  Java Programming/Throwing and Catching Exceptions#Catching Rule",Keywords try,https://en.wikibooks.org//wiki/Java_Programming/Keywords
271,"void is a Java keyword.Used at method declaration and definition to specify that the method does not return any type, the method returns void . It is not a type and there is no void references/pointers as in C/C++.For example:See also:Java Programming/Keywords/return",Keywords void,https://en.wikibooks.org//wiki/Java_Programming/Keywords
272,"volatile is a keyword.When member variables are marked with this keyword, it changes the runtime behavior in a way that is noticeable when multiple threads access these variables. Without the volatile keyword, one thread could observe another thread update member variables in an order that is not consistent with what is specified in sourcecode. Unlike the synchronized keyword, concurrent access to a volatile field is allowed.Syntax:private  volatile <member-variable>;
or volatile  private <member-variable>;For example:See also:Java Programming/Keywords/synchronized",Keywords volatile,https://en.wikibooks.org//wiki/Java_Programming/Keywords
273,"Every class in Java can be composed of the following elements:fields , member variables or instance variables  Fields are variables that hold data specific to each object.  For example, an employee might have an ID number. There is one field for each object of a class.  member methods or instance methods  Member methods perform operations on an object.  For example, an employee might have a method to issue his paycheck or to access his name.  static fields or class fields  Static fields are common to any object of the same class.  For example, a static field within the Employee class could keep track of the last ID number issued. Each static field exists only once in the class, regardless of how many objects are created for that class.  static methods or class methods  Static methods are methods that do not affect a specific object.  inner classes  Sometimes it is useful to contain a class within another one if it is useless outside of the class or should not be accessed outside the class.  Constructors  A special method that generates a new object.  Parameterized types  Since 1.5, parameterized types can be assigned to a class during definition.  The parameterized types will be substituted with the types specified at the class's instantiation. It is done by the compiler. It is similar to the C language macro '#define' statement, where a preprocessor evaluates the macros.The following Java code would produce this output:",Defining classes Fundamentals,https://en.wikibooks.org//wiki/Java_Programming/Defining_Classes
274,"A constructor is called to initialize an object immediately after the object has been allocated:Typically, a constructor is invoked using the new keyword:The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:The returned object is always a valid, meaningful object, as opposed to relying on a separate initialization method. A constructor cannot be abstract , final , native , static , strictfp nor synchronized . However, a constructor, like methods, can be overloaded and take parameters.By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor . One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:The super() command calls the constructor of the superclass. If there is no explicit call to super(...) or this(...) , then the default superclass constructor super(); is called before the body of the constructor is executed. That said, there are instances where you need to add in the call manually. For example, if you write even one constructor, no matter what parameters it takes, the compiler will not add a default constructor. The code listing 4.8 results in a runtime error:This is something to keep in mind when extending existing classes. Either make a default constructor, or make sure every class that inherits your class uses the correct constructor.",Defining classes Constructors,https://en.wikibooks.org//wiki/Java_Programming/Defining_Classes
275,Initializers are blocks of code that are executed at the same time as initializers for fields.,Defining classes Initializers,https://en.wikibooks.org//wiki/Java_Programming/Defining_Classes
276,Static initializers are blocks of code that are executed at the same time as initializers for static fields.  Static field initializers and static initializers are executed in the order declared.  The static initialization is executed after the class is loaded.,Defining classes Static initializers,https://en.wikibooks.org//wiki/Java_Programming/Defining_Classes
277,"Inheritance is one of the most powerful mechanisms of the Object Oriented Programming . It allows the reuse of the members of a class (called the superclass or the mother class ) in another class (called subclass , child class or the derived class ) that inherits from it. This way, classes can be built by successive inheritance.In Java, this mechanism is enabled by the extends keyword.
Example:In the Code listing 4.10 , the class Car inherits from Vehicle , which means that the attributes speed and numberOfSeats are present in the class Car , whereas they are defined in the class Vehicle . Also, the constructor defined in the class Car allows to initialize those attributes.
In Java, the inheritance mechanism allows to define a class hierarchy with all the classes. Without explicit inheritance, a class implicitly inherits from the Object class. This Object class is the root of the class hierarchy.Some classes can't be inherited. Those classes are defined with the final keyword. For instance, the Integer class can't have subclasses. It is called a final class.",Inheritance ,https://en.wikibooks.org//wiki/Java_Programming/Inheritance
278,"At the instantiating, the child class receives the features inherited from its superclass, which also has received the features inherited from its own superclass and so on to the Object class.
This mechanism allows to define reusable global classes, whose user details the behavior in the derived more specific classes.In Java, a class can only inherit from one class. Java does not allow you to create a subclass from two classes, as that would require creating complicated rules to disambiguate fields and methods inherited from multiple superclasses.  If there is a need for Java to inherit from multiple sources, the best option is through interfaces, described in the next chapter.",Inheritance The Object class,https://en.wikibooks.org//wiki/Java_Programming/Inheritance
279,"An interface is an abstraction of class with no implementation details. For example, java.lang.Comparable is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the class keyword but the interface keyword to define it. Then, there are fields and methods you cannot define here:A field is always a constant: it is always public, static and final, even if you do not mention it.  A method must be public and abstract, but it is not required to write the public and abstract keywords.  Constructors are forbidden.An interface represents a contract :You can see that the method1() method is abstract (unimplemented). To use an interface, you have to define a class that implements it, using the implements keyword:A class can implement several interface, separated by a comma. Java interfaces behave much like the concept of the Objective-C protocol. It is recommended to name an interface <verb> able , to mean the type of action this interface would enable on a class. However, it is not recommended to start the name of an interface by I as in C++ . It is useless. Your IDE will help you instead.",Interfaces ,https://en.wikibooks.org//wiki/Java_Programming/Interfaces
280,"If you have objects from different classes that do not have a common superclass, you can't call the same method in those classes, even if the two classes implement a method with the same signature.The solution is to write an interface that defines the method that should be implemented in the two classes as the SimpleInterface in the Code listing 4.14 and then the both classes can implement the interface as in the Code listing 4.15 .You can also implement this using a common super class but a class can only inherit from one super class whereas it can implement several interfaces.Java does not support full orthogonal multiple inheritance (i.e. Java does not allow you to create a subclass from two classes). Multiple inheritance in C++ has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types that are inherited multiple times.  By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity.  The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited. The major benefit of that is that all Java objects can have a common ancestor (a class called Object ).When overriding methods defined in interfaces there are several rules to be followed:Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.  The signature of the interface method and the same return type or subtype should be maintained when implementing the methods.  All the methods of the interface need to be defined in the class, unless the class that implements the interface is abstract.",Interfaces Interest,https://en.wikibooks.org//wiki/Java_Programming/Interfaces
281,"In a class, there can be several methods with the same name. However they must have a different signature . The signature of a method is comprised of its name, its parameter types and the order of its parameters. The signature of a method is not comprised of its return type nor its visibility nor the exceptions it may throw.
The practice of defining two or more methods within the same class that share the same name but have different parameters is called overloading methods .Methods with the same name in a class are called overloaded methods . Overloading methods offers no specific benefit to the JVM but it is useful to the programmer to have several methods do the same things but with different parameters. For example, we may have the operation runAroundThe represented as two methods with the same name, but different input parameter types:One type can be the subclass of the other:Although both methods would be fit to call the method with the String parameter, it is the method with the nearest type that will be called instead. To be more accurate, it will call the method whose parameter type is a subclass of the parameter type of the other method. So, aObject will output Object . Beware! The parameter type is defined by the declared type of an object, not its instantiated type!The following two method definitions are validbecause the type order is different. If both input parameters were type String, that would be a problem since the compiler would not be able to distinguish between the two:The compiler would give an error for the following method definitions as well:Note, the return type is not part of the unique signature.  Why not?  The reason is that a method can be called without assigning its return value to a variable.  This feature came from C and C++. So for the call:the compiler would not know which method to call. It is also the case for the thrown exceptions.Test your knowledge  Question 4.6 : Which methods of the Question6 class will cause compile errors?      Question6.java  1 public  class  Question6  {  2  3  public  void  example1 ()  {  4  }  5  6  public  int  example1 ()  {  7  }  8  9  public  void  example2 ( int  x )  {  10  }  11  12  public  void  example2 ( int  y )  {  13  }  14  15  private  void  example3 ()  {  16  }  17  18  public  void  example3 ()  {  19  }  20  21  public  String  example4 ( int  x )  {  22  return  null ;  23  }  24  25  public  String  example4 ()  {  26  return  null ;  27  }  28 }    Answer      Question6.java  1 public  class  Question6  {  2  3  public  void  example1 ()  {  4  }  5  6  public  int  example1 ()  {  7  }  8  9  public  void  example2 ( int  x )  {  10  }  11  12  public  void  example2 ( int  y )  {  13  }  14  15  private  void  example3 ()  {  16  }  17  18  public  void  example3 ()  {  19  }  20  21  public  String  example4 ( int  x )  {  22  return  null ;  23  }  24  25  public  String  example4 ()  {  26  return  null ;  27  }  28 }    The example1 , example2 and example3 methods will cause compile errors. The example1 methods cannot co-exist because they have the same signature (remember, return type is not part of the signature). The example2 methods cannot co-exist because the names of the parameters are not part of the signature. The example3 methods cannot co-exist because the visibility of the methods are not part of the signature. The example4 methods can co-exist, because they have different method signatures.",Overloading methods and constructors Method overloading,https://en.wikibooks.org//wiki/Java_Programming/Overloading_Methods_and_Constructors
282,"Instead of overloading, you can use a dynamic number of arguments. After the last parameter, you can pass optional unlimited parameters of the same type. These parameters are defined by adding a last parameter and adding ... after its type. The dynamic arguments will be received as an array:The above method can be called with a dynamic number of arguments, for example:This feature was not available before Java 1.5 .",Overloading methods and constructors Variable Argument,https://en.wikibooks.org//wiki/Java_Programming/Overloading_Methods_and_Constructors
283,"The constructor can be overloaded. You can define more than one constructor with different parameters. For example:In the code listing 4.12 , we defined two constructors, one with no input parameter, and one with one input parameter. You may ask which constructor will be called.  Its depends how the object is created with the new keyword. See below:In the code section 4.29 , we created two objects from the same class, or we can also say that obj1 and obj2 both have the same type. The difference between the two is that in the first one the memberField field is not initialized, in the second one that is initialized to ""Init Value"" . A constructor may also be called from another constructor, see below:In the code listing 4.13 , the constructor with no input parameter calls the other constructor with the default initial value. This call must be the first instruction of a constructor or else a compiler error will occur. The code gives an option to the user, to create the object with the default value or create the object with a specified value. The first constructor could have been written using the this keyword as well:Such a call reduces the code repetition.",Overloading methods and constructors Constructor overloading,https://en.wikibooks.org//wiki/Java_Programming/Overloading_Methods_and_Constructors
284,"Before a Java object can be created the class byte code must be loaded from the file system (with .class extension) to memory. This process of locating the byte code for a given class name and converting that code into a Java class instance is known as class loading . There is one class created for each type of Java class.All objects in Java programs are created on heap memory.  An object is created based on its class.  You can consider a class as a blueprint, template, or a description how to create an object.  When an object is created, memory is allocated to hold the object properties. An object reference pointing to that memory location is also created. To use the object in the future, that object reference has to be stored as a local variable or as an object member variable.The Java Virtual Machine (JVM) keeps track of the usage of object references.  If there are no more reference to the object, the object can not be used any more and becomes garbage.  After a while the heap memory  will be full of  unused objects.  The JVM collects those garbage objects and frees the memory they allocated, so the memory can be reused again when a new object is created.  See below a simple example:The obj variable contains the object reference pointing to an object created from the MyObject class. The obj object reference is in scope inside the {  } .  After the } the object becomes garbage.  Object references can be passed in to methods and can be returned from methods.",Object Lifecycle ,https://en.wikibooks.org//wiki/Java_Programming/Object_Lifecycle
285,"99% of new objects are created using the new keyword.When an object from the MyObject class is created for the first time, the JVM searches the file system for the definition of the class, that is the Java byte code. The file has the extension of *.class .  The CLASSPATH environment variable contains locations where Java classes are stored.  The JVM is looking for the MyObject.class file. Depending on which package the class belongs to, the package name will be translated to a directory path.When the MyObject.class file is found, the JVM's class loader loads the class in memory, and creates a java.lang.Class object. The JVM stores the code in memory, allocates memory for the static variables, and executes any static initialize block.  Memory is not allocated for the object member variables at this point, memory will be allocated for them when an instance of the class, an object, is created.There is no limit on how many objects from the same class can be created.  Code and static variables are stored only once, no matter how many objects are created. Memory is allocated for the object member variables when the object is created.  Thus, the size of an object is determined not by its code's size but by the memory it needs for its member variables to be stored.",Object Lifecycle Creating object with the new keyword,https://en.wikibooks.org//wiki/Java_Programming/Object_Lifecycle
286,"Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the object's states.You may ask why we need this clone method. Can't we create a constructor, pass in the same object and do the copying variable by variable? An example would be (note that accessing the private memberVar variable of obj is legal as this is in the same class):This method works but object creation with the new keyword is time-consuming. The clone() method copies the whole object's memory in one operation and this is much faster than using the new keyword and copying each variable so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.Now, let's see how to make the Customer object cloneable.First the Customer class needs to implement the Cloneable Interface.  Override and make the clone() method public , as that is protected in the Object class.  Call the super.clone() method at the beginning of your clone method.  Override the clone() method in all the subclasses of Customer .In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects.  So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't.  Also let's say that the Customer object has a reference to an Activity object that contains the customer activities.  Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects.  The solution:Make the Activity class also cloneable  Make sure that if the Activity class has other 'changeable' object references, those have to be cloned as well, as seen below  Change the Customer class clone() method as follows:Note that only mutable objects need to be cloned. References to unchangeable objects such as a String can be used in the cloned object without worry.",Object Lifecycle Creating object by cloning an object,https://en.wikibooks.org//wiki/Java_Programming/Object_Lifecycle
287,"When an object is sent through a network, the object needs to be re-created at the receiving host.Object Serialization  The term Object Serialization refers to the act of converting the object to a byte stream. The byte stream can be stored on the file system or can be sent through a network.  At a later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available both times, when the object is serialized and also when the object is re-created. If that happens on different servers, then the same class must be available on both servers.  Same class means that exactly the same version of the class must be available, otherwise the object won't be able to be re-created. This is a maintenance problem for those applications where java serialization is used to make objects persistent or to sent the object through the network.  When a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.By default, a class will have all of its fields serialized when converted into a data stream (with transient fields being skipped).  If additional handling is required beyond the default of writing all fields, you need to provide an implementation for the following three methods:private void writeObject(java.io.ObjectOutputStream out) throws IOException;private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException;If the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:Object writeReplace() throws ObjectStreamException;Object readResolve() throws ObjectStreamException;Normally, a minor change to the class can cause the serialization to fail.  You can still allow the class to be loaded by defining the serialization version id:",Object Lifecycle Re-creating an object received from a remote source,https://en.wikibooks.org//wiki/Java_Programming/Object_Lifecycle
288,"Unlike in many other object-oriented programming languages, Java performs automatic garbage collection  any unreferenced objects are automatically erased from memory  and prohibits the user from manually destroying objects.",Object Lifecycle Destroying objects,https://en.wikibooks.org//wiki/Java_Programming/Object_Lifecycle
289,"When an object is garbage-collected, the programmer may want to manually perform cleanup, such as closing any open input/output streams.  To accomplish this, the finalize() method is used.  Note that finalize() should never be manually called, except to call a super class' finalize method from a derived class' finalize method.  Also, we can not rely on when the finalize() method will be called.  If the java application exits before the object is garbage-collected, the finalize() method may never be called.The garbage-collector thread runs in a lower priority than the other threads. If the application creates objects faster than the garbage-collector can claim back memory, the program can run out of memory.The finalize method is required only if there are resources beyond the direct control of the Java Virtual Machine that needs to be cleaned up.  In particular, there is no need to explicitly close an OutputStream, since the OutputStream will close itself when it gets finalized.  Instead, the finalize method is used to release either native or remote resources controlled by the class.",Object Lifecycle finalize(),https://en.wikibooks.org//wiki/Java_Programming/Object_Lifecycle
290,"The scope of a class, a variable or a method is its visibility and its accessibility. The visibility or accessibility means that you can use the item from a given place.",Scope Scope,https://en.wikibooks.org//wiki/Java_Programming/Scope
291,"A method parameter is visible inside of the entire method but not visible outside the method.In code listing 3.14 , i is visible within the entire method1 method but not in the method2 and the main methods.",Scope Scope of method parameters,https://en.wikibooks.org//wiki/Java_Programming/Scope
292,A local variable is visible after its declaration until the end of the block in which the local variable has been created.,Scope Scope of local variables,https://en.wikibooks.org//wiki/Java_Programming/Scope
293,"You surely would have noticed by now, the words public , protected and private at the beginning of class's method declarations used in this book. These keywords are called the access modifiers in the Java language syntax, and they define the scope of a given item.",Scope Access modifiers,https://en.wikibooks.org//wiki/Java_Programming/Scope
294,"If a class has public visibility, the class can be referenced by anywhere in the program.  If a class has protected visibility, the class can be referenced only in the package where the class is defined.  If a class has private visibility, (it can happen only if the class is defined nested in an other class) the class can be accessed only in the outer class.",Scope For a class,https://en.wikibooks.org//wiki/Java_Programming/Scope
295,"If a variable is defined in a public class and it has public visibility, the variable can be referenced anywhere in the application through the class it is defined in.  If a variable has protected visibility, the variable can be referenced only in the sub-classes and in the same package through the class it is defined in.  If a variable has package visibility, the variable can be referenced only in the same package through the class it is defined in.  If a variable has private visibility, the variable can be accessed only in the class it is defined in.",Scope For a variable,https://en.wikibooks.org//wiki/Java_Programming/Scope
296,"If a method is defined in a public class and it has public visibility, the method can be called anywhere in the application through the class it is defined in.  If a method has protected visibility, the method can be called only in the sub-classes and in the same package through the class it is defined in.  If a method has package visibility, the method can be called only in the same package through the class it is defined in.  If a method has private visibility, the method can be called only in the class it is defined in.",Scope For a method,https://en.wikibooks.org//wiki/Java_Programming/Scope
297,The interface methods and interfaces are always public . You do not need to specify the access modifier. It will default to public . For clarity it is considered a good practice to put the public keyword.The same way all member variables defined in the Interface by default will become static  final once inherited in a class.,Scope For an interface,https://en.wikibooks.org//wiki/Java_Programming/Scope
298,The cases in bold are the default.,Scope Summary,https://en.wikibooks.org//wiki/Java_Programming/Scope
299,"A general guideline for visibilities is to only make a member as visible as it needs to be. Don't make a member public if it only needs to be private.Doing so, you can rewrite a class and change all the private members without making compilation errors, even you don't know all the classes that will use your class as long as you do not change the signature of the public members.",Scope Utility,https://en.wikibooks.org//wiki/Java_Programming/Scope
300,In Java you can define a class inside an other class. A class can be nested inside another class or inside a method. A class that is not nested is called a top-level class and a class defining a nested class is an outer class.,Nested classes ,https://en.wikibooks.org//wiki/Java_Programming/Nested_Classes
301,"When a class is declared inside another class, the nested class' access modifier can be public , private , protected or package(default) .The inner class has access to the enclosing class instance's variables and methods, even private ones, as seen above. This makes it very different from the nested class in C++, which are equivalent to the ""static"" inner classes, see below.An inner object has a reference to the outer object. In other words, all inner objects are tied to the outer object. The inner object can only be created through a reference to the 'outer' object. See below.Note that inner objects, because they are tied to the outer object, cannot contain static variables or methods.When in a non-static method of the outer class, you can directly use new InnerClass() , since the class instance is implied to be this .You can directly access the reference to the outer object from within an inner class with the syntax OuterClass.this ; although this is usually unnecessary because you already have access to its fields and methods.Inner classes compile to separate "".class"" bytecode files, with the name of the enclosing class, followed by a ""$"", followed by the name of the inner class. So for example, the above inner class would be compiled to a file named ""OuterClass$InnerClass.class"".",Nested classes Nesting a class inside a class,https://en.wikibooks.org//wiki/Java_Programming/Nested_Classes
302,"A nested class can be declared static . These classes are not bound to an instance of the outer defining class. A static nested class has no enclosing instance, and therefore cannot access instance variables and methods of the outer class. You do not specify an instance when creating a static inner class. This is equivalent to the inner classes in C++.",Nested classes Static nested classes,https://en.wikibooks.org//wiki/Java_Programming/Nested_Classes
303,"These inner classes, also called local classes , cannot have access modifiers, like local variables, since the class is 'private' to the method. The inner class can be only abstract or final .In addition to instance variables of the enclosing class, local classes can also access local variables of the enclosing method, but only ones that are declared final . This is because the local class instance might outlive the invocation of the method, and so needs its own copy of the variable. To avoid problems with having two different copies of a mutable variable with the same name in the same scope, it is required to be final , so it cannot be changed.",Nested classes Nesting a class inside a method,https://en.wikibooks.org//wiki/Java_Programming/Nested_Classes
304,"Java is a strongly typed language, so a field in a class may be typed like this:This ensures that, only Integer objects can be put in the field and a ClassCastException can't occur at runtime, only compile-time error can occur. Unfortunately, it can be used only with Integer objects. If you want to use the same class in another context with String s, you have to generalize the type like this:But you will have ClassCastException at runtime again and you can't easily use your field. The solution is to use Generics .",Generics ,https://en.wikibooks.org//wiki/Java_Programming/Generics
305,"A generic class does not hard code the type of a field, a return value or a parameter. The class only indicates that a generic type should be the same, for a given object instance. The generic type is not specified in the class definition. It is specified during object instantiation. This allows the generic type to be different from an instance to another. So we should write our class this way:Here, the generic type is defined after the name of the class. Any new identifier can be chosen. Here, we have chosen T , which is the most common choice. The actual type is defined at the object instantiation:Although each object instance has its own type, each object instance is still strongly typed:A class can define as many generic types as you like. Choose a different identifier for each generic type and separate them by a comma:When a type that is defined with generic (for example, Collection<T> ) is not used with generics (for example, Collection ) is called a raw type .",Generics Generic class,https://en.wikibooks.org//wiki/Java_Programming/Generics
306,"A generic type can be defined for just a method:Here a new identifier ( D ) has been chosen at the beginning of the method declaration. The type is specific to a method call and different types can be used for the same object instance:The actual type will be defined by the type of the method parameter. Hence, the generic type can't be defined only for the return value as it wouldn't be resolved. See the Class<T> section for a solution.Test your knowledge  Question 4.8 : Consider the following class.      Question 4.8: Question8.java  1 public  class  Question8 < T >  {  2  public  T  item ;  3  4  public  T  getItem ()  {  5  return  item ;  6  }  7  8  public  void  setItem ( T  newItem )  {  9  item  =  newItem ;  10  }  11  12  public  static  void  main ( String []  args )  {  13  Question8 < String >  aQuestion  =  new  Question8 < String >();  14  aQuestion . setItem ( ""Open your mind."" );  15  aQuestion . display ( aQuestion . getItem ());  16  }  17  18  public  void  display ( String  parameter )  {  19  System . out . println ( ""Here is the text: ""  +  parameter );  20  }  21  22  public  void  display ( Integer  parameter )  {  23  System . out . println ( ""Here is the number: ""  +  parameter );  24  }  25  26  public  void  display ( Object  parameter )  {  27  System . out . println ( ""Here is the object: ""  +  parameter );  28  }  29 }    What will be displayed on the console?  Answer      Console for Answer 4.8  Here is the text: Open your mind.   aQuestion.getItem() is typed as a string.",Generics Generic method,https://en.wikibooks.org//wiki/Java_Programming/Generics
307,"As we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables.
In some cases this is too restrictive.  What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds?
The wildcard type is represented by the character <?> , and pronounced Unknown , or Any-Type . Any-Type can be expressed also by <? extends Object> . Any-Type includes Interfaces, not only Classes.
So now we can define a collection whose element type matches anything. See below:",Generics Wildcard Types,https://en.wikibooks.org//wiki/Java_Programming/Generics
308,"You can specify a restriction on the types of classes that may be used. For example, <? extends ClassName> only allows objects of class ClassName or a subclass.
For example, to create a collection that may only contain ""Serializable"" objects, specify:The above code is valid because the String class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as Serializable object. You can call methods of the Serializable interface or cast it to String . The following collection can only contain objects that extend the class Animal .",Generics Upper bounded wildcards,https://en.wikibooks.org//wiki/Java_Programming/Generics
309,"<? super ClassName> specifies a restriction on the types of classes that may be used.
For example, to declare a Comparator that can compare Dogs, you use:Now suppose you define a comparator that can compare Animals:Since Dogs are Animals , you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.The above code is valid because the Animal class is a supertype of the Dog class. Use of a class that is not a supertype would cause a compilation error.",Generics Lower bounded wildcards,https://en.wikibooks.org//wiki/Java_Programming/Generics
310,"The advantage of the unbounded wildcard (i.e. <?> ) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, not any type . That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:This code will compile but this code may corrupt the collection if the collection only contains strings:This situation could have been avoided if the addAtBottom(Collection) method was defined with an unbounded wildcard: addAtBottom(Collection<?>) . With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection ( clear() , isEmpty() , iterator() , remove(Object o) , size() , ...) can be called. For instance, addAtBottom(Collection<?>) could contain the following code:",Generics Unbounded wildcard,https://en.wikibooks.org//wiki/Java_Programming/Generics
311,"Since Java 1.5, the class java.lang.Class is generic. It is an interesting example of using generics for something other than a container class.
For example, the type of String.class is Class<String> , and the type of Serializable.class is Class<Serializable> . This can be used to improve the type safety of your reflection code.
In particular, since the newInstance() method in Class now returns T, you can get more precise types when creating objects reflectively.
Now we can use the newInstance() method to return a new object with exact type, without casting. An example with generics:The same code without generics:",Generics Class<T>,https://en.wikibooks.org//wiki/Java_Programming/Generics
312,"Java was long criticized for the need to explicitly type-cast an element when it was taken out of a ""container/collection"" class. There was no way to enforce that a ""collection"" class contains only one type of object (e.g., to forbid at compile time that an Integer object is added to a Collection that should only contain String s). This is possible since Java 1.5.
In the first couple of years of Java evolution, Java did not have a real competitor. This has changed by the appearance of Microsoft C#. With Generics Java is better suited to compete against C#.
Similar constructs to Java Generics exist in other languages, see Generic programming for more information.
Generics were added to the Java language syntax in version 1.5. This means that code using Generics will not compile with Java 1.4 and less.
Use of generics is optional. For backwards compatibility with pre-Generics code, it is okay to use generic classes without the generics type specification ( <T> ). In such a case, when you retrieve an object reference from a generic object, you will have to manually cast it from type Object to the correct type.",Generics Motivation,https://en.wikibooks.org//wiki/Java_Programming/Generics
313,"The most basic collection interface is called Collection . This interface gives the user the generic usage of a collection. All collections need to have the same basic operations. Those are:Adding element(s) to the collection  Removing element(s) from the collection  Obtaining the number of elements in the collection  Listing the contents of the collection, (Iterating through the collection)When you put an object in a collection, this object is not actually in the collection. Only its object reference is added to the collection. This means that if an object is changed after it was put in an collection, the object in the collection also changes. The code listing 5.2 computes the seven next days from tomorrow and stores each date in a list to read it afterwards. See what happens:All collection items were meant to be updated to a different date but they all have been updated to the last one. This means that each update has updated all the collection items. The currentDate has been used to fill all the collection items. The collection didn't keep trace of the added values (one of the seven dates) but the added object references ( currentDate ). So the collection contains the same object seven times! To avoid this issue, we should have coded it this way:Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item being changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.",Collection ,https://en.wikibooks.org//wiki/Java_Programming/Collection
314,"Objects put into a collection are upcasted to the Object class. This means that you need to cast the object reference back when you get an element out of the collection. It also means that you need to know the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. For example. let's use this collection with two objects in it:This error could have been found earlier, at compile time, by using generic types. The Generics have been added since JDK version 1.5. It is an enhancement to the type system of the Java language.  All collection implementations since 1.5 now have a parameterized type <E> .  The E refers to an Element type.  When a collection is created, the actual Element type will replace the E.  In the collection, the objects are now upcasted to E class.ageList is a collection that can contain only Integer objects as elements. No casting is required when we take out an element.Generics are not mandatory but are is often used with the collection classes.",Collection Generics,https://en.wikibooks.org//wiki/Java_Programming/Collection
315,There is no direct implementation for the java.util.Collection interface.  The Collection interface has five sub interfaces.,Collection Collection classes,https://en.wikibooks.org//wiki/Java_Programming/Collection
316,"A set collection contains unique elements, so duplicates are not allowed. It is similar to a mathematical Set. When adding a new item to a set, the set calls the method int hashCode() of the item and compares its result to the hash code of all the already inserted items. If the hash code is not found, the item is added. If the hash code is found, the set calls the boolean equals(Object obj); method for all the set items with the same hashcode as the new item. If all equal-calls return false, the new item is inserted in the set. If an equal-call returns true, the new item is not inserted in the set.java.util. HashSet <E>   This is the basic implementation of the Set interface. Not synchronized. Allows the null elements  java.util. TreeSet <E>  Elements are sorted, not synchronized. null not allowed  java.util. CopyOnWriteArraySet <E>   Thread safe, a fresh copy is created during modification operation. Add, update, delete are expensive.  java.util. EnumSet <E extends Enum<E>>   All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors.  java.util. LinkedHashSet <E>   Same as HashSet, plus defines the iteration ordering, which is the order in which elements were inserted into the set.",Collection Set,https://en.wikibooks.org//wiki/Java_Programming/Collection
317,"Set cannot have duplicates in it. You may wonder how duplicates are detected when we are adding an object to the Set . We have to see if that object exists in the Set or not. It is not enough to check the object references, the objects' values have to be checked as well.To do that, fortunately, each java object has the boolean equals(Object obj) , method available inherited from Object . You need to override it. That method will be called by the Set implementation to compare the two objects to see if they are equal or not.There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared.  Calling the equals() method would cause a ClassCastException . There are two solutions to this:Solution one : Override the int hashCode() method and return the same values for the same type of objects and return different values for different type of objects.  The equals() method is used to compare objects only with the same value of hashCode. So before an object is added, the Set implementation needs to: find all the objects in the Set that have the same hashCode as the candidate object hashCode  and for those, call the equals() methods passing in the candidate object  if any of them returns true, the object is not added to the Set.Solution two : Create a super class for the Apple and Orange, let's call it Fruit class. Put Fruits in the Set. You need to do the following: Do not override the equals() and hashCode() methods in the Apple and Orange classes  Create appleEquals() method in the Apple class, and create orangeEquals() method in the Orange class  Override the hashCode() method in the Fruit class and return the same value, so the equals() is called by the Set implementation  Override the equals() method in the Fruit class for something like this.Note:Only the objects that have the same hashCode will be compared.  You are responsible to override the equals() and hashCode() methods. The default implementations in Object won't work.  Only override the hashCode() method if you want to eliminate value duplicates.  Do not override the hashCode() method if you know that the values of your objects are different, or if you only want to prevent adding the exactly same object.  Beware that the hashCode() may be used in other collection implementations, like in a Hashtable to find an object fast. Overriding the default hashCode() method may affect performance there.  The default hashCodes are unique for each object created, so if you decide not to override the hashCode() method, there is no point overriding the equals() method, as it won't be called.",Collection Detecting duplicate objects in Sets,https://en.wikibooks.org//wiki/Java_Programming/Collection
318,"The SortedSet interface is the same as the Set interface plus the elements in the SortedSet are sorted. It extends the Set Interface. All elements in the SortedSet must implement the Comparable Interface, furthermore all elements must be mutually comparable.Note that the ordering maintained by a sorted set must be consistent with equals if the sorted set is to correctly implement the Set interface. This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compare method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal.The SortedSet interface has additional methods due to the sorted nature of the 'Set'.  Those are:",Collection SortedSet,https://en.wikibooks.org//wiki/Java_Programming/Collection
319,"In a list collection, the elements are put in a certain order, and can be accessed by an index.  Duplicates are allowed, the same element can be added twice to a list. It has the following implementations:java.util. Vector <E>   Synchronized, use in multiple thread access, otherwise use ArrayList .  java.util. Stack <E>   It extends class Vector with five operations that allow a vector to be treated as a stack. It represents a last-in-first-out (LIFO) stack of objects.  java.util. ArrayList <E>   The basic implementation of the List interface is the ArrayList . The ArrayList is not synchronized, not thread safe. Vector is synchronized, and thread safe. Vector is slower, because of the extra overhead to make it thread safe.  When only one thread is accessing the list, use the ArrayList. Whenever you insert or remove an element from the list, there are extra overhead to reindex the list. When you have a large list, and you have lots of insert and remove, consider using the LinkedList .  java.util. LinkedList <E>   Non-synchronized, update operation is faster than other lists, easy to use for stacks, queues, double-ended queues. The name LinkedList implies a special data structure where the elements/nodes are connected by pointers.Head               Node 1                   Node 2                     Node n
  ______
 | Size |          _________________        _______________            _____________
 |______|         |      | point   |       |      | point  |          |      |      |  
 | First|-------->| Data | to next |------>| Data | to next|-- ... -->| Data | null |
 | elem |         |______|_________|       |______|________|          |______|______|
 |______|                                                                 ^
 | Last |                                                                 |
 | elem |-----------------------------------------------------------------
 |______|Each node is related to an item of the linked list. To remove an element from the linked list the pointers need to be rearranged. After removing Node 2:Head               Node 1                   Node 2                     Node n
  ______                                 _____________________
 | Size |          _________________    |   _______________   |       ______________
 |_- 1__|         |      | point   |    |  |      | point  |  |       |      |      |  
 | First|-------->| Data | to next |----   | Data | to next|   -...-->| Data | null |
 | elem |         |______|_________|       |______|________|          |______|______|
 |______|                                                                 ^
 | Last |                                                                 |
 | elem |-----------------------------------------------------------------
 |______|javax.management. AtributeList <E>   Represents a list of values for attributes of an MBean. The methods used for the insertion of Attribute objects in the AttributeList overrides the corresponding methods in the superclass ArrayList. This is needed in order to insure that the objects contained in the AttributeList are only Attribute objects.  javax.management.relation. RoleList <E>   A RoleList represents a list of roles (Role objects). It is used as parameter when creating a relation, and when trying to set several roles in a relation (via 'setRoles()' method). It is returned as part of a RoleResult, to provide roles successfully retrieved.  javax.management.relation. RoleUnresolvedList <E>   A RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write to roles).",Collection List,https://en.wikibooks.org//wiki/Java_Programming/Collection
320,"The Queue interface provides additional insertion, extraction, and inspection operations. There are FIFO (first in, first out) and LIFO (last in, first out) queues. This interface adds the following operations to the Collection interface:java.util. BlockingQueue <E>   waits for the queue to become non-empty when retrieving an element, and waits for space to become available in the queue when storing an element. Best used for producer-consumer queues.  java.util. PriorityQueue <E>   orders elements according to an order/priority  specified at construction time, null element is not allowed.  java.util.concurrent. ArrayBlockingQueue <E>   orders elements FIFO; synchronized, thread safe.  java.util.concurrent. SynchronousQueue <E>   each put must wait for a take, and vice versa, does not have any internal capacity, not even a capacity of one, an element is only present when you try to take it; you cannot add an element (using any method) unless another thread is trying to remove it.",Collection Queue,https://en.wikibooks.org//wiki/Java_Programming/Collection
321,"Synchronization is important when you are running several threads. Beware, synchronization does not mean that your collection is thread-safe. A thread-safe collection is also called a concurrent collection . Most of the popular collection classes have implementations for both single thread and multiple thread environments. The non-synchronized implementations are always faster. You can use the non-synchronized implementations in multiple thread environments, when you make sure that only one thread updates the collection at any given time.A new Java JDK package was introduced at Java 1.5, that is java.util.concurrent .  This package supplies a few Collection implementations designed for use in multi-threaded environments.The following table lists all the synchronized collection classes:",Collection Synchronization,https://en.wikibooks.org//wiki/Java_Programming/Collection
322,"The ArrayList class extends AbstractList and implements the List interface. ArrayList supports dynamic arrays that can grow as needed.Standard Java arrays are of a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold.Array lists are created with an initial size. When this size is exceeded, the collection is automatically enlarged. When objects are removed, the array may be shrunk.",ArrayList ,https://en.wikibooks.org//wiki/Java_Programming/ArrayList
323,The ArrayList class supports three constructors. The first constructor builds an empty array list.:ArrayList (  )The following constructor builds an array list that is initialized with the elements of the collection c.ArrayList ( Collection  c )The following constructor builds an array list that has the specified initial capacity. The capacity is the size of the underlying array that is used to store the elements.The capacity grows automatically as elements are added to an array list.ArrayList ( int  capacity ),ArrayList Initializing,https://en.wikibooks.org//wiki/Java_Programming/ArrayList
324,ArrayList defines following methods:,ArrayList Methods,https://en.wikibooks.org//wiki/Java_Programming/ArrayList
325,"Inserts the specified element at the specified position index in this list. Throws IndexOutOfBoundsException if the specified index is out of range (index < 0 || index >= size()).void  add ( int  index ,  Object  element )Appends the specified element to the end of this list.boolean  add ( Object  o )Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator. Throws NullPointerException if the specified collection is null.boolean  addAll ( Collection  c )Inserts all of the elements in the specified collection into this list, starting at the specified position. Throws NullPointerException if the specified collection is null.boolean  addAll ( int  index ,  Collection  c )",ArrayList Adding Element in ArrayList,https://en.wikibooks.org//wiki/Java_Programming/ArrayList
326,"Returns the number of elements in this list.int  size ()Adding Element and Size of ArrayListimport  java.util.* ;  public  class  ArrayListDemo {  public  static  void  main ( String []  args )  {  // create an array list  ArrayList  < String >  al =  new  ArrayList  < String >();  System . out . println ( ""Initial ArrayList : "" + al );  // add elements to the array list  al . add ( ""A"" );  al . add ( ""B"" );  //find size of ArrayList  System . out . println ( ""Size of al :"" + al . size ());  // display the array list  System . out . println ( ""Contents of al :"" + al );  al . add ( 1 , ""C"" );  System . out . println ( ""Contents of al :"" + al );  System . out . println ( ""Size of al :"" + al . size ());  }  }Output for Adding Element and Size of  ArrayList",ArrayList Size of ArrayList,https://en.wikibooks.org//wiki/Java_Programming/ArrayList
327,"Returns the element at the specified position in this list. Throws IndexOutOfBoundsException if the specified index is is out of range (index < 0 or index >= size()).Object  get ( int  index )Replaces the element at the specified position in this list with the specified element. Throws IndexOutOfBoundsException if the specified index is is out of range (index < 0 or index >= size()).Object  set ( int  index ,  Object  element )",ArrayList Get and Set ArrayList Element,https://en.wikibooks.org//wiki/Java_Programming/ArrayList
328,"Returns the index in this list of the first occurrence of the specified element, or -1 if the List does not contain this element.int  indexOf ( Object  o )Returns the index in this list of the last occurrence of the specified element, or -1 if the list does not contain this element.int  lastIndexOf ( Object  o )",ArrayList Find Index of ArrayList Element,https://en.wikibooks.org//wiki/Java_Programming/ArrayList
329,"Aside from the java.util.Collection interface, the Java JDK has the java.util.Map interface as well.  It is sometimes also called an Associated Array or a Dictionary .  A map defines key value mappings.  Implementations of the Map interface do not contain collections of objects.  Instead they contain collections of key->value mappings.  It can be thought of as an array where the index doesn't need to be an integer.Use the Map interface if you need to keep related objects together in a Map where you can:Access an element by a key object  Map one object to otherjava.util. Map <K,V>   maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The key is usually a non-mutable object. The value object however can be a mutable object.  java.util. SortedMap <K,V>   same as the Map interface, plus the keys in the Map are sorted.In the above example, the same operations are made with two different map implementations:We see that only the TreeMap has sorted the keys. Beware of the generics. The Map interface is tricky. The methods get() and remove() are not generic. This means that you must be careful of the type of the key:The remove() call has done nothing because ""2"" is a String , not an Integer so no key and value has been found and removed.",Map ,https://en.wikibooks.org//wiki/Java_Programming/Map
330,"The Map interface has the following implementations:java.util. TreeMap <E>  guarantees that the map will be in ascending key order, sorted according to the natural order for the key's class, not-synchronized.  java.util. Hashtable <E>   Synchronized, null can not be used as key  java.util. HashMap <E>   is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls  java.util.concurrent. ConcurrentHashMap  same as Hashtable, plus retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).  java.util. WeakHashMap <E>   entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. Non-synchronized.  java.util. LinkedHashMap <E>   This linked list defines the iteration ordering, which is normally the order in which keys were first inserted into the map (first insertion-order). Note that insertion order is not affected if a key is re-inserted into the map.  java.util. IdentityHashMap  This class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if (k1==k2) . (In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only if (k1==null? k2==null: k1.equals(k2)) .) Not-synchronized.  java.util. EnumMap  All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. Not-synchronized.",Map Map Classes,https://en.wikibooks.org//wiki/Java_Programming/Map
331,"In Java, we can distinguish two kinds of equality.Object reference equality: when two object references point to the same object.  Object value equality: when two separate objects happen to have the same values/state.If two objects are equal in reference, they are equal in value too.",Comparing Objects ,https://en.wikibooks.org//wiki/Java_Programming/Comparing_Objects
332,The == operator can be used to check if two object references point to the same object.,Comparing Objects Comparing for reference equality,https://en.wikibooks.org//wiki/Java_Programming/Comparing_Objects
333,"To be able to compare two Java objects of the same class the boolean equals( Object obj) method must be overriden and implemented by the class.The implementor decides which values must be equal to consider two objects to be equal. For example in the below class , the name and the address must be equal but not the description .After the equals() method is overriden, two objects from the same class can be compared like this:Note that equal objects must have equal hash codes. Therefore, when overriding the equals method, you must also override the hashCode method. Failure to do so violates the general contract for the hashCode method, and any classes that use the hash code, such as HashMap will not function properly.",Comparing Objects Comparing for value equality,https://en.wikibooks.org//wiki/Java_Programming/Comparing_Objects
334,"In Java, there are several existing methods that already sort objects from any class like Collections.sort(List<T> list) . However, Java needs to know the comparison rules between two objects. So when you define a new class and want the objects of your class to be sortable, you have to implement the Comparable and redefine the compareTo(Object obj) method.int compareTo(T o)  Compares two objects and return an integer:A negative integer means that the current object is before the parameter object in the natural ordering.  Zero means that the current object and the parameter object are equal.  A positive integer means that the current object is after the parameter object in the natural ordering.Let's say that the name is more important than the address and the description is ignored.Objects that implement this interface can be used as keys in a sorted map or elements in a sorted set, without the need to specify a comparator.The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo((Object) e2) == 0 has the same boolean value as e1.equals((Object) e2) for every e1 and e2 of class C. Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.It is strongly recommended (though not required) that natural orderings be consistent with equals. This is because sorted sets (and sorted maps) without explicit comparators behave ""strangely"" when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates the general contract for set (or map), which is defined in terms of the equals method.",Comparing Objects Sorting/Ordering,https://en.wikibooks.org//wiki/Java_Programming/Comparing_Objects
335,"Language compilers are adept at pointing out most of the erroneous code in a program, however there are some errors that only become apparent when the program is executed. Consider the code listing 6.1 ; here, the program defines a method divide that does a simple division operation taking two integers as parameter arguments and returning the result of their division. It can safely be assumed that when the divide(4, 2) statement is called, it would return the number 2 . However, consider the next statement, where the program relies upon the provided command line arguments to generate a division operation. What if the user provides the number zero ( 0 ) as the second argument? We all know that division  by zero is impossible, but the compiler couldn't possibly have anticipated the user providing zero as an argument.Such exceptional code that results in erroneous interpretations at program runtime usually results in errors that are called exceptions in Java. When the Java interpreter encounters an exceptional code, it halts execution and displays information about the error that occurs. This information is known as a stack trace . The stack trace in the above example tells us more about the error, such as the thread  ""main""  where the exception occurred, the type of exception  java.lang.ArithmeticException , a comprehensible display message  / by zero , and the exact methods and the line numbers where the exception may have occurred.",Throwing and catching exceptions ,https://en.wikibooks.org//wiki/Java_Programming/Throwing_and_Catching_Exceptions
336,"The preceding exception could have been created explicitly by the developer as it is the case in the following code:Note that when b equals zero, there is no return value. Instead of a java.lang.ArithmeticException generated by the Java interpreter itself, it is an exception created by the coder. The result is the same. It shows you that an exception is an object. Its main particularity is that it can be thrown. An exception object must inherit from java.lang.Exception . Standard exceptions have two constructors:The default constructor; and,  A constructor taking a string argument so that you can place pertinent information in the exception.This string can later be extracted using various methods, as you can see in the code listing 6.2 .You can throw any type of Throwable object using the keyword throw . It interrupts the method. Anything after the throw statement would not be executed, unless the thrown exception is handled . The exception object is not returned from the method, it is thrown from the method. That means that the exception object is not the return value of the method and the calling method can be interrupted too and so on and so on...Typically, you'll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the name of the exception class, so someone in the bigger context can figure out what to do with your exception. Often, the only information is the type of exception, and nothing meaningful is stored within the exception object.",Throwing and catching exceptions Exception object,https://en.wikibooks.org//wiki/Java_Programming/Throwing_and_Catching_Exceptions
337,The box 6.1 below talks about the various exception classes within the java.lang package.,Throwing and catching exceptions Oracle standard exception classes,https://en.wikibooks.org//wiki/Java_Programming/Throwing_and_Catching_Exceptions
338,"By default, when an exception is thrown, the current method is interrupted, the calling method is interrupted too and so on till the main method. A thrown exception can also be caught using a try / catch statement. Below is how a try / catch statement works:The executed code lines have been highlighted. When no exception is thrown, the method flow executes the try statement and not the catch statement.As there is a thrown exception at line 5, the line 6 is not executed, but the exception is caught by the catch statement so the catch block is executed. The following code is also executed. Note that the catch statement takes an exception as parameter. There is a third case: when the exception is not from the same class as the parameter:It is as if there is no try / catch statement. The exception is thrown to the calling method.",Throwing and catching exceptions try/catch statement,https://en.wikibooks.org//wiki/Java_Programming/Throwing_and_Catching_Exceptions
339,"A try / catch statement can contain several catch blocks, to handle different exceptions in different ways. Each catch block must take a parameter of a different throwable class. A thrown object may match several catch block but only the first catch block that matches the object will be executed. A catch-block will catch a thrown exception if and only if:the thrown exception object is the same as the exception object specified by the catch-block.  the thrown exception object is the subtype of the exception object specified by the catch-block.This means that the catch block order is important. As a consequence, you can't put a catch block that catches all the exception (which take a java.lang.Exception as parameter) before a catch block that catches a more specific exception as the second block could never be executed.At line 14, we use a multi-catch clause. It is available since the JDK 7. This is a combination of several catch clauses and let's you handle exceptions in a single handler while also maintaining their types. So, instead of being boxed into a parent Exception super-class, they retain their individual types.You can also use the java.lang.Throwable class here, since Throwable is the parent class for the application-specific  Exception classes. However, this is discouraged in Java programming circles. This is because Throwable happens to also be the parent class for the non-application specific  Error classes which are not meant to be handled explicitly as they are catered for by the JVM itself.",Throwing and catching exceptions catch blocks,https://en.wikibooks.org//wiki/Java_Programming/Throwing_and_Catching_Exceptions
340,"A finally block can be added after the catch blocks. A finally block is always executed, even when no exception is thrown, an exception is thrown and caught, or an exception is thrown and not caught. It's a place to put code that should always be executed after an unsafe operation like a file close or a database disconnection. You can define a try block without catch block, however, in this case, it must be followed by a finally block.",Throwing and catching exceptions finally block,https://en.wikibooks.org//wiki/Java_Programming/Throwing_and_Catching_Exceptions
341,"Let's examine the following code:In the code section 6.7 , methodC is invalid.  Because methodA and methodB pass (or throw) exceptions, methodC must be prepared to handle them.  This can be handled in two ways: a try - catch block, which will handle the exception within the method and a throws clause which would in turn throw the exception to the caller to handle.  The above example will cause a compilation error, as Java is very strict about exception handling. So the programmer is forced to handle any possible error condition at some point.A method can do two things with an exception: ask the calling method to handle it by the throws declaration or handle the exception inside the method by the try - catch block.To work correctly, the original code can be modified in multiple ways.  For example, the following:The AnotherException from methodB will be handled locally, while CustomException and SomeException will be thrown to the caller to handle it. Most of the developers are embarrassed when they have to choose between the two options. This type of decision should not be taken at development time. If you are a development team, it should be discussed between all the developers in order to have a common exception handling policy.",Throwing and catching exceptions Example of handling exceptions,https://en.wikibooks.org//wiki/Java_Programming/Throwing_and_Catching_Exceptions
342,"A checked exception is a type of exception that must be either caught or declared in the method in which it is thrown. For example, the java.io.IOException is a checked exception. To understand what is a checked exception, consider the following code:This code won't compile because it can throw a checked exception. The compilation error can be resolved in either of two ways: By catching the exception and handling it, or by declaring that the exception can be thrown using the throws keyword.In the Java class hierarchy, an exception is a checked exception if it inherits from java.lang.Throwable , but not from java.lang.RuntimeException or java.lang.Error . All the application or business logic exceptions should be checked exceptions.It is possible that a method declares that it can throw an exception, but actually it does not. Still, the caller has to deal with it. The checked exception declaration has a domino effect. Any methods that will use the previous method will also have to handle the checked exception, and so on.So the compiler for the Java programming language checks, at compile time, that a program contains handlers for all application exceptions, by analyzing each method body. If, by executing the method body, an exception can be thrown to the caller, that exception must be declared. How does the compiler know whether a method body can throw an exception? That is easy. Inside the method body, there are calls to other methods; the compiler looks at each of their method signature, what exceptions they declared to throw.",Checked exceptions ,https://en.wikibooks.org//wiki/Java_Programming/Checked_Exceptions
343,"This may look boring to the developer but it forces them to think about all the checked exceptions and increase the code quality. This compile-time checking for the presence of exception handlers is designed to make the application developer life easier. To debug whether a particular thrown exception has a matching catch would be a long process. In conventional languages like C, and C++, a separate error handling debugging were needed. In Java we can be sure that when an application exception is thrown, that exception somewhere in the program is handled. In C, and C++, that has to be tested. In Java that does not need to be tested, so the freed up time can be used for more meaningful testing, testing the business features.",Checked exceptions Why Force Exception Handling?,https://en.wikibooks.org//wiki/Java_Programming/Checked_Exceptions
344,"The checked exception classes specified after the throws keyword are part of the contract between the implementer and user. An overriding method can declare the same exceptions, subclasses or no exceptions.",Checked exceptions What Exceptions can be Declared when Overriding a Method?,https://en.wikibooks.org//wiki/Java_Programming/Checked_Exceptions
345,"NullPointerException is a RuntimeException . In Java, a special null value can be assigned to an object reference. NullPointerException is thrown when an application attempts to use an object reference that has the null value.
These include:Calling an instance method on the object referred by a null reference.  Accessing or modifying an instance field of the object referred by a null reference.  If the reference type is an array type, taking the length of a null reference.  If the reference type is an array type, accessing or modifying the slots of a null reference.  If the reference type is a subtype of Throwable , throwing a null reference.Applications should throw instances of this class to indicate other illegal uses of the null object.The above code shows one of the pitfalls of Java and the most common source of bugs. No object is created and the compiler does not detect it. NullPointerException is one of the most common exceptions thrown in Java.",Preventing NullPointerException ,https://en.wikibooks.org//wiki/Java_Programming/Preventing_NullPointerException
346,"The reason we need it is because many times we need to create an object reference before the object itself is created. Object references cannot exist without a value, so we assign the null value to it.In code section 6.14 we want to create the Person inside the if-else, but we also want to return the object reference to the caller, so we need to create the object reference outside of the if-else, because of the scoping rule in Java. Incorrect error-handling and poor contract design can be a pitfall with any programming language. This is also true for Java.Now we will describe how to prevent NullPointerException . We do not describe general techniques for how you should program Java, we just hope to make you more aware of null values, and to be more careful about generating them yourself.This list is not complete  there are no rules for preventing NullPointerException entirely in Java, because the standard libraries have to be used, and they can cause NullPointerException s.  Also, it is possible to observe an uninitialized final field in Java, so you can't even treat a final field as being completely trusted during the object's creation.A good approach is to learn how to deal with NullPointerException s first, and become competent with that.  These suggestions will help you to cause less NullPointerException s, but they don't replace the need to know about NullPointerException s.",Preventing NullPointerException Why do we need null?,https://en.wikibooks.org//wiki/Java_Programming/Preventing_NullPointerException
347,"When you compare a variable with a string literal, most of people would do that this way:Always put the string literal first:If the state variable is null, you get a NullPointerException in the first example, but not in the second one.",Preventing NullPointerException Comparing string variable with a string literal,https://en.wikibooks.org//wiki/Java_Programming/Preventing_NullPointerException
348,"This means not doing things like:You can replace this with:You might also consider replacing null with """" in the first example, but default values bring about bugs caused by default values being left in place.  A NullPointerException is actually better, as it allows the runtime to tell you about the bug, rather than just continue with a default value.",Preventing NullPointerException Minimize the use of the keyword 'null' in assignment statements,https://en.wikibooks.org//wiki/Java_Programming/Preventing_NullPointerException
349,"An array created using new Object[10] has 10 null pointers.  That's 10 more than we want, so use collections instead, or explicitly fill the array at initialization with:or:",Preventing NullPointerException Minimize the use of the new Type[int] syntax for creating arrays of objects,https://en.wikibooks.org//wiki/Java_Programming/Preventing_NullPointerException
350,"Many methods that can return a reference null reference.  Make sure you check these.  For example:File.listFiles() can return null if /etc is not a directory.You can decide to trust some methods not to return null, if you like, but that's an assumption you're making.  Some methods that don't specify that they might return null, actually do, instead of throwing an exception.",Preventing NullPointerException Check all references obtained from 'untrusted' methods,https://en.wikibooks.org//wiki/Java_Programming/Preventing_NullPointerException
351,"Beware if you loop on an array or a collection in a for each loop.If the object is null, it does not just do zero loops, it throws a null pointer exception. So don't forget this case. Add an if statement or return empty collections:",Preventing NullPointerException For each loop trap,https://en.wikibooks.org//wiki/Java_Programming/Preventing_NullPointerException
352,"Stack Trace is a list of method calls from the point when the application was started to the point where the exception was thrown. The most recent method calls are at the top.The stack trace can be printed to the standard error by calling the public void printStackTrace() method of an exception.From Java 1.4, the stack trace is encapsulated into an array of a java class called java.lang.StackTraceElement .
The stack trace element array returned by Throwable.getStackTrace() method. Each element represents a single stack frame. All stack frames except for the one at the top of the stack represent a method invocation. The frame at the top of the stack represents the execution point at which the stack trace was generated. Typically, this is the point at which the throwable corresponding to the stack trace was created.A stack frame represents the following information:Creates a stack trace element representing the specified execution point.",Stack trace ,https://en.wikibooks.org//wiki/Java_Programming/Stack_trace
353,"CPUs for any computer are designed to execute one task at any given time , yet we run multiple applications side-by-side and everything works in perfect congruence. It's not just because CPUs are extremely fast in performing calculations, it's because CPUs use a clever device of dividing their time amongst various tasks. Each application or task that is invoked on a computer gets associated with the CPU in the form of a process . A CPU therefore manages various processes, and jumps back and forth amongst each process giving it a fraction of its time and processing capability. This happens so fast that to a normal computer user it presents with the illusion of processes being run simultaneously. This capability of the CPU to divide its time amongst processes is called multitasking .So, if we run a Java application on a computer, we are effectively creating a process with the CPU that gets a fraction of the CPU's time. In Java parlance, this main process gets called the daemon process or the daemon thread . But, Java goes one step further. It allows programmers to divide this daemon thread into several multiple threads which get executed simultaneously (much like a CPU) hence providing a Java application with a finer multitasking capability called multithreading .In this section, we will take a look at what threads are and how multithreading is implemented within a Java program to make it appear congruent and effectively fast to respond.",Threads and Runnables ,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
354,"In light of the above discussion, a thread is the smallest unit of processing that can be scheduled by an operating system. Therefore, using threads, a programmer can effectively create two or more tasks [1] that run at the same time. The first call-to-action is to implement a set of tasks that a particular thread would execute. To do so, we require the creation of a Runnable process.",Threads and Runnables Threads,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
355,"A Runnable process block is a simple class that implements a run() method. Within the run() method is the actual task that needs to be executed by a running thread. By implementing a class with the Runnable interface, we ensure that the class holds a run() method. Consider the following program:In the above code, we create a class called RunnableProcess and implement the Runnable interface to ensure that we have a run() method in the class declaration.We then declare the rest of the logic for the class. For the constructor, we take a String parameter that would serve as the name of the class. Then, we initialize the class member variable time with a random number between 0 and 999 . To ensure the initialization of a random number, we use the Random class in the java.util package.The actual task that would be executed per this runnable block is presented within the run() method. To keep safe from exceptions occurring because of the concurrent programming, we wrap the code within this method with a try..catch block. The executing task actually consists of just three statements. The first outputs the provided name for the Runnable process, and the last reports that the thread has executed. Perhaps the most intriguing part of the code is the second statement: Thread.sleep(...) .This statement allows the thread executing the current runnable block to halt its execution for the given amount of time. This time is presented in milliseconds. But for our convenience, this time would be the random number generated in the constructor and can be anywhere between 0 and 999 milliseconds. We will explore this in a later section. Creating a Runnable process block is just the beginning. No code is actually executed. To do so, we would require the creation of threads that would then individually execute this task.",Threads and Runnables Creating a Runnable process block,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
356,"Once we have a Runnable process block, we can create various threads that can then execute the logic encased within such blocks. Multithreading capabilities in Java are utilized and manipulated using the Thread class. A Thread object therefore holds all the necessary logic and devices to create truly multithreaded programs. Consider the following program:Creating threads is as simple as the above program suggests. You just have to create an object of the Thread class and pass a reference to a Runnable process object. In the case above, we present the Thread constructor with the class object for the RunnableProcess class that we created in code listing 1 . But for each object, we give a different name (i.e., ""Thread-1"" and ""Thread-2"" , etc.) to differentiate between the three Thread objects. The above example only declares Thread objects and hasn't yet started them for execution.",Threads and Runnables Creating threads,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
357,"Now, that we know how to effectively create a Runnable process block and a Thread object that executes it, we need to understand how to start the created Thread objects. This couldn't be simpler. For this process, we will be calling the start() method on the Thread objects and voil, our threads will begin executing their individual process tasks.The above code will start all three declared threads. This way, all three threads will begin their execution one-by-one. However, this being concurrent programming and us having declared random times for the halting of the execution, the outputs for every one of us would differ. Following is the output we received when we executed the above program.It should be noted that the execution of the Thread didn't occur in the desired order. Instead of the order t1  t2  t3 , the threads executed in the order of t1  t3  t2 . The order in which the threads are executed is completely dependent on the operating system and may change for every execution of the program, thus making output of multithreaded application difficult to predict and control. Some people suggest that this is the major reason that adds to the complexity of multithreaded programming and its debugging. However, it should be observed that once the threads were put to sleep using the Thread.sleep(...) function, the execution intervals and order can be predicted quite capably. The thread with the least amount of sleeping time was t2 ( ""Thread-2"" ) with 189 milliseconds of sleep hence it got called first. Then t1 was called and finally t3 was called.",Threads and Runnables Starting threads,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
358,It can be said that the execution order of the threads was manipulated to some degree using the Thread.sleep(...) method. The Thread class has such static methods that can arguably affect the execution order and manipulation of threads. Below are some useful static methods in the Thread class. These methods when called will only affect the currently running threads.,Threads and Runnables Manipulating threads,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
359,"The text in its current form is incomplete.Given below is an example of creating and running multiple threads that behave in a synchronous manner such that when one thread is using a particular resource, the others wait until the resource has been released. We will talk more about this in later sections.",Threads and Runnables Synchronization,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
360,"Video games intensively use threadsThreads are used intensively in applications that require a considerable amount of CPU usage. For operations that are time-consuming and intensive, it is usually advised to use threads. An example of such an application would be a typical video game. At any given time, a video game involves various characters, objects in the surroundings and other such nuances that needs to be dealt with simultaneously. Dealing with each element or object within the game requires a fair amount of threads to monitor every object.For example, take this screen-shot of a role-playing strategy game on the right. Here the game visuals depict various in-game characters moving about on the screen. Now imagine processing the movements, direction and behaviors of each of the characters visible on screen. It would certainly take a lot of time moving each character one-by-one if this were to be done one task after another. However if fundamentals of multi-threading are employed, each character would move in a synchronous manner with respect to others.Threads are not only used heavily in video games, their use is common in everything from simple browser applications to complex operating systems and networking applications. Today it often goes beyond the simple preference of the developer but into the need to maximize the usefulness of contemporaneous hardware that is predicated in heavy multitasking.",Threads and Runnables Where are threads used?,https://en.wikibooks.org//wiki/Java_Programming/Threads_and_Runnables
361,"In 1990s, the trend was moving away from Mainframe computing to Client/Server as the price of Unix servers dropped. The database access and some business logic were centralized on the back-end server, collecting data from the user program was installed on the front-end users' ""client"" computers. In the Java world there are three main ways the front-end and the back-end can communicate.The client application uses JDBC (Java DataBase Connectivity API) to connect to the data base server, (Limited business logic on the back-end, unless using Stored procedures ).  The client application uses RMI ( Remote Method Invocation ) to communicate with the back-end.  The client application uses a socket connection to communicate with the back-end.",Client Server Programming ,https://en.wikibooks.org//wiki/Java_Programming/Client_Server
362,Figure 1:Simple Client Server ImplementationThis page shows an example of a socket connection.,Client Server Programming Socket Connection Example,https://en.wikibooks.org//wiki/Java_Programming/Client_Server
363,"The Java language was developed having network computing in mind. For this reason it is very easy to create a server program. A server is a piece of code that runs all the time listening on a particular port on the computer for incoming requests. When a request arrives, it starts a new thread to service the request.
See the following example:",Client Server Programming Create a Server,https://en.wikibooks.org//wiki/Java_Programming/Client_Server
364,"ComServer  class is for listening on a port for a client.ServerSocket( iPortNumber )  Creates a server socket, bound to the specified port.  serverSocket.accept()  Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. It returns a new Socket.",Client Server Programming Listening on a port,https://en.wikibooks.org//wiki/Java_Programming/Client_Server
365,"ComServerThread  This class extended from a Thread is responsible to service one client. The Socket connection will be open between the client and server. A simple protocol has to be defined between the client and server, the server has to understand what the client wants from the server. The client will send a terminate command, for which the server will terminate the socket connection.  The ComServerThread class is responsible to handle all client requests, until the client sends a terminate command.COM_DATA tDataFromClient  This variable will contain the data object from the client.  COM_DATA tDataToClient  This variable will contain the data object to be sent to the client.  sendDataToClient  This method sends the data object to the client.  getDataFromClient  This method gets the data object from the client.  processInput( tDataFromClient )  This method of the class ComProtocol interprets the client commands and returns the data object that will be sent back to the client.",Client Server Programming Service One Client,https://en.wikibooks.org//wiki/Java_Programming/Client_Server
366,"ComProtocol  This class implements, and encapsulates the communication logic (protocol). The protocol is the following: The client initiate the connection.  The server accepts it and sends an acknowledgment notifying that it's ready  The client sends a request  The server response based on the request  ... The client sends a BYE request  The server acknowledge the BYE request and disconnects the socket connection  The client gets the acknowledgment to the BYE  ... The client sends a SHUTDOWN request  The server acknowledge the SHUTDOWN request and disconnects and also stops listening of other clients.  The client gets the acknowledgment to the SHUTDOWN",Client Server Programming Handling the request; implements the communication protocol,https://en.wikibooks.org//wiki/Java_Programming/Client_Server
367,COM_DATA  is data structure class that is transmitted through the network. The class contains only data.,Client Server Programming The Data object that goes through the network,https://en.wikibooks.org//wiki/Java_Programming/Client_Server
368,"Java's Remote Method Invocation (commonly referred to as RMI) is used for client and server models. RMI is the object oriented equivalent to RPC (Remote procedure call) .The Java Remote Method Invocation (RMI) system allows an object running in one Java Virtual Machine (VM) to invoke methods of an object running in another Java VM. RMI provides for remote communication between programs written in the Java programming language.RMI is only defined for use with the Java platform. If you need to call methods between different language environments, use CORBA . With CORBA a Java client can call a C++ server and/or a C++ client can call a Java server. With RMI that can not be done.",Remote Method Invocation (RMI) ,https://en.wikibooks.org//wiki/Java_Programming/Remote_Method_Invocation
369,"The remote method invocation goes through a STUB on the client side and a so called SKELETON on the server side.CLIENT --> STUB --> ... Network ... --> SKELETON --> REMOTE OBJECTPrior to Java 1.2 the skeleton had to be explicitly generated with the rmic tool. Since 1.2 a dynamic skeleton is used, which employs the features of Java Reflection to do its work.",Remote Method Invocation (RMI) STUB and SKELETON,https://en.wikibooks.org//wiki/Java_Programming/Remote_Method_Invocation
370,"Remote objects can be listed in the RMI Registry. Clients can get a reference to the remote object by querying the Registry. After that, the client can call methods on the remote objects. (Remote object references can also be acquired by calling other remote methods. The Registry is really a 'bootstrap' that solves the problem of where to get the initial remote reference from.)The RMI Registry can either be started within the server JVM, via the LocateRegistry.createRegistry() API, or a separate process called rmiregistry that has to be started before remote objects can be added to it, e.g. by the command line in Unix:or under Windows:If port is not specified the default 1099 is used. The client will need to connect to this port to access the Registry.The Registry can also be started from a program by calling the following code:Objects passed in as parameters to the remote objects's methods will be passed by value. If the remote object changes the passed-in object values, it won't be reflected on the client side, this is opposite what happens when a local object is called. Objects that used as parameters for remote methods invocation must implement the java.io.Serializable interface, as they are going to be serialized when passed through the network, and a new object will be created on the other side.However, exported remote objects passed as parameters are passed by remote reference.",Remote Method Invocation (RMI) rmiregistry,https://en.wikibooks.org//wiki/Java_Programming/Remote_Method_Invocation
371,"The remote object has to either extend the java.rmi.server.UnicastRemoteObject object, or be explicitly exported by calling the java.rmi.server.UnicastRemoteObject.exportObject() method.",Remote Method Invocation (RMI) RMI Remote object,https://en.wikibooks.org//wiki/Java_Programming/Remote_Method_Invocation
372,"Enterprise JavaBeans (EJB) technology is the server-side component architecture for Java Platform, Enterprise Edition (Java EE). EJB technology enables to create distributed, transactional, secure and portable application component objects.EJB supports the development and deployment of component based business applications.  Applications written using the Enterprise JavaBeans architecture are scalable, transactional, and multi-user secure.  These applications may be written once, and then deployed on any server platform that supports the Enterprise JavaBeans specification.",Enterprise JavaBean Programming (EJB) ,https://en.wikibooks.org//wiki/Java_Programming/EJB
373,Security Management  Persistence Management  Transaction Management  Distributable Interoperable Management  Exception Management,Enterprise JavaBean Programming (EJB) EJB Features,https://en.wikibooks.org//wiki/Java_Programming/EJB
374,Session Beans StateFull Session Beans  Stateless Session Beans  Entity Beans  Message Driven Beans,Enterprise JavaBean Programming (EJB) Types of EJB,https://en.wikibooks.org//wiki/Java_Programming/EJB
375,"EJBs are an attempt to create component based application development.  With EJBs it is easier to develop components, but the same basic and fundamental maintenance problem will still be there. That is the dependencies between the client and the components.  The usage of a component is fixed, changes on the component interface cause to break the client code.  The same client/server problem comes back, that is as the users of a component increases the maintenance of that component getting harder and harder until it goes to impossible.For a true component based application development we need to standardize the usage of a component.  The client must somehow flexibly figure out automatically how to use a component, so component changes don't affect any of the clients using that component. Without that flexibility, a true component based application development will remain as an idea, a dream, a theory without significant practical use.
If we had that flexibility, it could cause a paradigm shift in the software development industry.JINI was an attempt from Sun to address this flexibility problem.  In JINI, the client download the component interface implementation and execute it in the client space.So we need to mix (somehow) EJB and JINI technologies to come up with a true flexible component based technology.",Enterprise JavaBean Programming (EJB) Problems with EJB as a component based development,https://en.wikibooks.org//wiki/Java_Programming/EJB
376,Sun EJB Home,Enterprise JavaBean Programming (EJB) References,https://en.wikibooks.org//wiki/Java_Programming/EJB
377,EJB in Java EE,Enterprise JavaBean Programming (EJB) See also,https://en.wikibooks.org//wiki/Java_Programming/EJB
378,"After J2EE, Sun had a vision about the next step of network computing: in a network environment, there would be many independent services and consumers. That is JavaSpaces .  JavaSpaces would allow these services/consumers to interact dynamically with each other in a robust way.  It can be viewed as an object repository that provides a distributed persistent  object exchange mechanism (persistent can be in memory or disk) for Java objects. It can be used to store the system state and implement distributed algorithms. In a JavaSpace, all communication partners (peers) communicate by sharing state. It is an implementation of the Tuple spaces idea.JavaSpaces is used when someone wants to achieve scalability and availability and at the same time reducing the complexity of the overall system.Processes perform simple operations to write new objects into a JavaSpace , take objects from a JavaSpace , or read (make a copy of) objects from the JavaSpace .In conventional applications, objects are assembled from the database before presenting to the end user. In JavaSpace applications, we keep the ready made ""end user"" objects and store them in the JavaSpace. In JavaSpace applications the services are decoupled from each other; they communicate through objects that they write and read/take from the JavaSpace. Services search for objects that they want to take or read from the Space by using template object.",Java Spaces Programming (Jini) ,https://en.wikibooks.org//wiki/Java_Programming/JavaSpaces
379,"JavaSpaces technology is part of the Java Jini technology.  The basic features of JINI are:No user intervention is needed when services are brought on or offline. (In contrast to EJBs where the client program has to know the server and port number where the EJB is deployed. In JINI the client is supposed to find , discover the service in the network.)  Self healing by adapting when services (consumers of services) come and go. Services need to periodically renew a lease to indicate that they are still available.  Consumers of JINI services do not need prior knowledge of the service's implementation. The implementation is downloaded dynamically and run on the consumer JVM, without configuration and user intervention. For example, the end user may be presented with slightly different user interface depending which service is being used at the time. The implementation of those user interface code would be provided by the service being used.This fact that the implementation is running on the consumer/client's JVM can increase performance, by eliminating the need of remote calls.A minimal JINI network environment consists of:One or more services  A lookup-service keeping a list of registered services  One or more consumers",Java Spaces Programming (Jini) JINI,https://en.wikibooks.org//wiki/Java_Programming/JavaSpaces
380,The lookup service is described in the: Jini Lookup Service Specification (reggie) .  This service interface defines all operations that are possible on the lookup service.  Clients locate services by requesting with a lookup server that implements a particular interface.  Client asks the lookup server for all services that implement the particular service interface.  The lookup service returns service objects for all registered services that implement the given interface.  The client may invoke methods on that object in order to interact directly with the server.,Java Spaces Programming (Jini) The JINI Lookup Service,https://en.wikibooks.org//wiki/Java_Programming/JavaSpaces
381,"Jini Discovery and Join Specification describes how does the client find the jini lookup service.  There is a protocol to do that, jini comes with a set of API's that implement that protocol.  The Jini Discovery Utility Specification defines a set of utility classes that are used to work with the protocol.",Java Spaces Programming (Jini) Lookup Discovery,https://en.wikibooks.org//wiki/Java_Programming/JavaSpaces
382,"When a service registers with the lookup service, it receives a lease from the lookup service, described in the Jini Distributed Leasing Specification .",Java Spaces Programming (Jini) Leasing,https://en.wikibooks.org//wiki/Java_Programming/JavaSpaces
383,Java allows users to document the classes and the members by using a particular syntax of comment.,Javadoc ,https://en.wikibooks.org//wiki/Java_Programming/Javadoc
384,"A documentation comment is framed by slash-star-star and star-slash (i.e. /** ... */). The documentation is in the HTML format.A documentation comment is placed just above the commented entity (class, constructor, method, field).In a documentation comment, the first part is a description text in the HTML format. The second part is a list of special attributes whose name starts with an at sign (@):Get the sum of two integers.  Description of the sum method.  @param a The first integer number.  Description attribute of the parameter a of the method.  @param b The second integer number.  Description attribute of the parameter b of the method.  @return The value of the sum of the two given integers.  Description attribute of the value returned by the method.Here is a non exhaustive list of special attributes:See also annotations since Java 5.",Javadoc Syntax,https://en.wikibooks.org//wiki/Java_Programming/Javadoc
385,"The JDK provides a tool named javadoc which allows to generate the documentation of the well commented classes. The javadoc command without argument give the complete syntax of the command.Example: for a class named Example defined in a package named org.wikibooks.en in the file C:\ProgJava\org\wikibooks\en\Example.java :The documentation can be generated in a specific folder (C:\ProgDoc for example) with the following command:The options of this command are described below:-locale en_US  The documentation in US English.  -use  Create the pages about the use of the classes and the packages.  -classpath C:\ProgJava  The path of the compiled classes (*.class).  -sourcepath C:\ProgJava  The path of the source classes (*.java).  -d C:\ProgDoc  The path where the documentation must be generated.  org.wikibooks.en  The name of the package to document. It is possible to specify several packages, or one or several class names to document only those ones.The description page of a package copy the description text from the file named package.html which should be placed in the given folder. In our example, we should document the package in the file C:\ProgJava\org\wikibooks\en\package.html .Since Java 5 [1] , the package.html file can be replaced by a special Java file named package-info.java containing only the package declaration preceding by a documentation comment.",Javadoc Documentation,https://en.wikibooks.org//wiki/Java_Programming/Javadoc
386,"In Java, an annotation is a language construct (introduced in J2SE 1.5) that provides a mechanism for including metadata directly in the source code.Annotations can provide metadata for Java classes, attributes, and methods. Syntactically, annotations can be viewed as a special kind of modifier and can be used anywhere that other modifiers (such as public , static , or final ) can be used.One of the main forces of adding this feature to Java was the wide spread use of XML descriptors to add additional information, metadata, for Java classes. Frameworks like EJB, JSF, Spring, Hibernate were heavily using external XML descriptors. The problem of those external descriptors was that those files are out of reach of the Java compiler and for that reason compiler type checking could not be used. A small spelling mistake bug in a huge XML descriptor file is hard to locate and fix. On the other hand the Java annotations use the Java compiler type checking features so spelling mistakes in annotation names will be caught by the Java compiler.In summary, annotations can be...used as a source of information for the compiler;  made available for compile-time or deployment-time processing;  examined at runtime.",Introduction to Annotation Introduction,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Introduction
387,Annotations can be viewed as a source of defining meta-data for a piece of code in Java. The annotation @CodeDescription used in the following sections does not come as a part of the Java API.,Creating custom annotations ,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Custom_Annotations
388,"Before you can use an annotation with classes, theirs members and statements or expressions, you need to define an annotation type . Following is the syntax on how to define a type for the mentioned annotation.That's it! Our first ever annotation has been defined. Now, we can use it with any of our classes. An annotation definition if you look closely resembles the definition of a normal interface, except that the interface keyword is preceded by the @ character. Some refer to this syntactical declaration as the annotation type declaration due to the fact that @ is 'AT' or 'Annotation Type' for that very instance.",Creating custom annotations Annotation Type Declaration,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Custom_Annotations
389,"What look like methods in the body of the annotation definition are called annotation element declarations . These are the named entities that we used with the annotation body in the example in the previous section . However, for the sake of clarity, code below also represents the calling of the following annotation:",Creating custom annotations Annotation Element Declarations,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Custom_Annotations
390,There are five annotation types in the java.lang.annotation package called meta-annotations . These annotation types are used to annotate other annotation types.,Meta-annotations ,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Meta-Annotations
391,"If a member is annotated with a type itself marked as @Documented , then that member will be documented as annotating that type.In the documentation for the Example class, such as the JavaDoc, Example will be shown as annotated with @NotSecret , but not @Secret .",Meta-annotations Documented,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Meta-Annotations
392,"Exactly as the name sounds, an @Inherited annotation type is inherited by subclasses of an annotated type.In this example, Superclass has been explicitly annotated with both @ForEveryone and @JustForMe . Subclass hasn't been explicitly marked with either one; however, it inherits @ForEveryone because the latter is annotated with @Inherited . @JustForMe isn't annotated, so it isn't inherited by Subclass .",Meta-annotations Inherited,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Meta-Annotations
393,A @Repeatable annotation type is repeatable - i.e. can be specified multiple times on the same class. This meta-annotation was added in Java 8.,Meta-annotations Repeatable,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Meta-Annotations
394,"Different annotation types have different purposes. Some are intended for use with the compiler; others are meant to be reflected dynamically at runtime. There's no reason for a compiler annotation to be available at runtime, so the @Retention meta-annotation specifies how long an annotation type should be retained. The value attribute is one of the java.lang.annotation.RetentionPolicy enum constants. The possible values, in order from shortest to longest retention, are as follows:RetentionPolicy.SOURCE  The annotation will not be included in the class file. This is useful for annotations which are intended for the compiler only.  RetentionPolicy.CLASS  The annotation will be included in the class file, but cannot be read reflectively.  RetentionPolicy.RUNTIME  The annotation can be reflected at runtime.If no @Retention policy is specified, it defaults to RetentionPolicy.CLASS .",Meta-annotations Retention,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Meta-Annotations
395,"Annotations can be used by the compiler to carry out certain directives.  Much that you'd love programming in Java, you probably would have been fussed about compiler warnings. Compiler warnings are not necessarily errors but are warnings that tell you the code might malfunction because of some reason.",Helping the compiler ,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Compiler_and_Annotations
396,"You can issue directive to the compiler in the shape of three pre-defined annotation to tell it what sort of pre-processing a certain bit of code requires. The three annotations are:@Deprecated  @Override  @SuppressWarnings(..)@Deprecated is used to flag that a method or class should no longer be used, normally because a better alternative exists.  Compilers and IDEs typically raise a warning if deprecated code is invoked from non deprecated code. [1]@Override flags that a method overrides a method in a superclass.  If there is no overridden method, a compile error should occur. [2]@SuppressWarnings(..) SuppressWarnings tells the compiler not to report on some, or all, types of warnings.  It can be applied to a type, a method or a variable. [3]",Helping the compiler Taming the compiler,https://en.wikibooks.org//wiki/Java_Programming/Annotations/Compiler_and_Annotations
397,"This section covers the Java platform classes used for basic input and output . But before we begin we need to have a concrete understanding of what input and output means in programming. To grasp this concept, think of the Java platform as a system .",Basic I/O ,https://en.wikibooks.org//wiki/Java_Programming/Basic_IO
398,"The Java platform is an isolated entity, a space on your OS in a way, where everything outside this system is its environment . The interaction between the system and its environment is a two-way dialog of sorts. Either the system receives messages from its environment, or it conveys its messages to the same. When a message is received by the system, it is called an input , its opposite is an output . On a whole, this communication is termed input/output abbreviated as I/O .The following chapters are designed to introduce basic input and output in Java, including reading text input from the keyboard, outputting text to the monitor, and reading/writing files from the file system.  More advanced user interaction using Graphics and Graphical User Interface (GUI) programs is taken up in the later section on Swing .There are two packages for I/O: the older java.io package (does not support symbolic links) and the newer java.nio (""new io"") package that has improved exception handling at java.nio.file.",Basic I/O Understanding input and output,https://en.wikibooks.org//wiki/Java_Programming/Basic_IO
399,"Writing to the screen is very easy, and can be accomplished using one of two methods:",Basic I/O Simple Java Output: Writing to the Screen,https://en.wikibooks.org//wiki/Java_Programming/Basic_IO
400,"The most basic input and output in Java ( System.in and System.out fields that have been used in the Basic I/O ) is done using streams. Streams are objects that represent sources and destinations of data.  Streams that are sources of data can be read from, and streams that are destinations of data can be written to. A stream in Java is an ordered sequence of bytes of undetermined length. Streams are ordered and in sequence so that the java virtual machine can understand and work upon the stream. Streams are analogous to water streams. They exist as a communication medium, just like electromagnetic waves in communication. The order or sequence of bytes in a Java stream allow the virtual machine to classify it among other streams.Java has various inbuilt streams implemented as classes in the package java.io like the classes of System.in and System.out . Streams can be classed as both input and output streams. All Java streams are derived from Input Stream ( java.io.InputStream ) and Output Stream ( java.io.OutputStream ) classes. They are abstract base classes meant for other stream classes. The System.in is the input stream class derivative and analogically System.out is the output counterpart. Both are basic classes used to directly interact with input and output through console, similarly follows System.err . Also Java has streams to communicate across different parts of a program or even among threads. There are also classes that ""filter"" streams, changing one format to another (e.g. class DataOutputStream , which translates various primitive types to byte streams).It is a characteristic of streams that they deal only in one discrete unit of data at a time, and different streams deal with different types of data.  If one had a stream that represented a destination for bytes, for example, one would send data to the destination one byte at a time.  If a stream was a source of byte data, one would read the data a byte at a time.  Because this is the only way to access data from a stream, in this latter case, we wouldn't know when we had read all the data from the stream until we actually got there.  When reading a stream, one generally has to check each unit of data each read operation to see if the end of the stream has been reached (with byte streams, the special value is the integer -1, or FFFF hex).",Streams ,https://en.wikibooks.org//wiki/Java_Programming/Streams
401,"Input streams acquire bytes for our programmed java application/program (e.g. a file, an array, a keyboard or monitor, etc.). InputStream is an abstract class that represents a source of byte data.  It has a read() method, which returns the next byte in the stream and a close() method, which should be called by a program when that program is done with the stream.  The read() method is overloaded, and can take a byte array to read to.  It has a skip() method that can skip a number of bytes, and an available() method that a program can use to determine the number of bytes immediately available to be read, as not all the data is necessarily ready immediately.  As an abstract class, it cannot be instantiated, but describes the general behavior of an input stream.  A few examples of concrete subclasses would be ByteArrayInputStream , which reads from a byte array, and FileInputStream , which reads byte data from a file.In the following example , we print ""Hello world!"" on the screen several times. The number of times the message is printed is stored in a file named source.txt . This file should only contain a integer and should be placed in the same folder of the ConfiguredApplication class.The close() method is not always mandatory but can avoid some inter-process concurrency conflicts. However if it occurs before a read() or write() (in the same process) they return the warning Stream closed .The class start to identify the filename with a File object. The File object is used by an input stream as the source of the stream. We create a buffer and a character to prepare the data loading. The buffer will contain all the file content and the character will temporary contain each character present in the file, one after one. This is done while{} in the loop. Each iteration of the loop will copy a character from the stream to the buffer. The loop ends when no more character is present in the stream. Then we close the stream. The last part of the code use the data we have loaded in from the file. It is transformed into string and then into an integer (so the data must be an integer). If it works, the integer is used to determine the number of time we print ""Hello world!"" on the screen. No try/catch block has been defined for readability but the thrown exceptions should be caught.Let's try with the following source file:We should obtain this:There is also Reader which is an abstract class that represents a source of character data.  It is analogous to InputStream , except that it deals with characters instead of bytes (remember that Java uses Unicode, so that a character is 2 bytes, not one).  Its methods are generally similar to those of InputStream .  Concrete subclasses include classes like FileReader , which reads characters from files, and StringReader , which reads characters from strings.  You can also convert an InputStream object to a Reader object with the InputStreamReader class, which can be ""wrapped around"" an InputStream object (by passing it as an argument in its constructor).  It uses a character encoding scheme (which can be changed by the programmer) to translate a byte into a 16-bit Unicode character.",Streams Input streams,https://en.wikibooks.org//wiki/Java_Programming/Streams
402,"Output Streams direct streams of bytes outwards to the environment from our program or application. OutputStream is an abstract class which is the destination counterpart of InputStream . OutputStream has a write() method which can be used to write a byte to the stream.  The method is overloaded, and can take an array as well.  A close() method closes the stream when the application is finished with it, and it has a flush() method.  The stream may wait until it has a certain amount before it writes it all at once for efficiency.  If the stream object is buffering any data before writing it, the flush() method will force it to write all of this data.  Like InputStream , this class cannot be instantiated, but has concrete subclasses that parallel those of InputStream , eg ByteArrayOutputStream , FileOutputStream , etc.In the following example , we store the current time in an already existing file called log.txt located in the same folder than the class.This case is more simple as we can put all the data in the stream at the same time. The first part of the code generate a string containing the current time. Then we create a File object identifying the output file and an output stream for this file. We write the data in the stream, flush it and close it. That's all. No try/catch block has been defined for readability but the thrown exceptions should be caught.Now let's execute it:We should obtain this content:There is also Writer which is a character counterpart of OutputStream , and a destination counterpart to Reader, this is also an abstract superclass.  Particular implementations parallel those of Reader, eg FileWriter , StringWriter , and OutputStreamWriter , for converting a regular OutputStream into a reader so that it can take character data.",Streams Output streams,https://en.wikibooks.org//wiki/Java_Programming/Streams
403,"System is a class in the package java.lang with a number of static members that are available to Java programs.  Two members that are useful for console output are System.out and System.err .  Both System.out and System.err are PrintStream objects. PrintStream is a subclass of FilterOutputStream , itself a subclass of OutputStream (discussed above), and its main purpose is to translate a wide variety of data types into streams of bytes that represent that data in characters according to some encoding scheme.System.out and System.err both display text to a console where the user can read it, however what this means exactly depends on the platform used and the environment in which the program is running.  In BlueJay and Eclipse IDE, for example, there is a special ""terminal"" window that will display this output.  If the program is launched in Windows, the output will be sent to the DOS prompt (usually this means that you have to launch the program from the command line to see the output).System.out and System.err differ in what they're supposed to be used for. System.out should be used for normal program output, System.err should be used to inform the user that some kind of error has occurred in the program.  In some situations, this may be important.  In DOS, for instance, a user can redirect standard output to some other destination (a file, for example), but error output will not be redirected, but rather displayed on the screen.  If this weren't the case, the user might never be able to tell that an error had occurred.",Streams System.out and System.err,https://en.wikibooks.org//wiki/Java_Programming/Streams
404,"Versions of Java prior to J2SE 1.4 only supported stream-based blocking I/O. This required a thread per stream being handled, as no other processing could take place while the active thread blocked waiting for input or output.  This was a major scalability and performance issue for anyone needing to implement any Java network service.  Since the introduction of NIO ( New I/O ) in J2SE 1.4, this scalability problem has been rectified by the introduction of a non-blocking I/O framework (though there are a number of open issues in the NIO API as implemented by Oracle).The non-blocking IO framework, though considerably more complex than the original blocking IO framework, allows any number of ""channels"" to be handled by a single thread. The framework is based on the Reactor Pattern.",Streams New I/O,https://en.wikibooks.org//wiki/Java_Programming/Streams
405,The Java platform Event Model is the basis for event-driven programming on the Java platform.,Event handling ,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
406,"No matter what the programming language or paradigm you are using, chances are that you will eventually run into a situation where your program will have to wait for an external event to happen. Perhaps your program must wait for some user input, or perhaps it must wait for data to be delivered over the network. Or perhaps something else. In any case, the program must wait for something to happen that is beyond the program's control: the program cannot make that event happen.In this situation there are two general options for making a program wait for an external event to happen. The first of these is called polling and means you write a little loop of the for ""while the event has not happened, check again"". Polling is very simple to build and very straightforward. But it is also very wasteful: it means a program takes up processor time in order to do absolutely nothing but wait. This is usually considered too much of a drawback for programs that have to do a lot of waiting. Programs that have a lot of waiting moments (for example, programs that have a graphical user interface and often have to wait for long periods of time until the user does something) usually fare much better when they use the other mechanism: event-driven programming .In event-driven programming a program that must wait, simply goes to sleep. It no longer takes up processor time, might even be unloaded from memory and generally leaves the computer available to do useful things. But the program doesn't completely go away; instead, it makes a deal with the computer or the operating system . A deal sort of like this:Okay Mr. Operating System, since I have to wait for an event to happen, I'll go away and let you do useful work in the meantime. But in return, you have to let me know when my event has happened and let me come back to deal with it.Event-driven programming usually has a pretty large impact on the design of a program. Usually, a program has to be broken up into separate pieces to do event-driven programming (one piece for general processing and one or more others to deal with events that occur). Event-driven programming in Java is more complicated than non-event driven but it makes far more efficient use of the hardware and sometimes (like when developing a graphical user interface) dividing your code up into event-driven blocks actually fits very naturally with your program's structure.In this module we examine the basis of the Java Platform's facilities for event-driven programming and we look at some typical examples of how that basis has been used throughout the platform.",Event handling Event-driven programming,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
407,"One of the most interesting things about support for event-driven programming on the Java platform is that there is none, as such. Or, depending on your point of view, there are many different individual pieces of the platform that offer their own support for event-driven programming.The reason that the Java platform doesn't offer one general implementation of event-driven programming is linked to the origins of the support that the platform does offer. Back in 1996 the Java programming language was just getting started in the world and was still trying to gain a foothold and conquer a place for itself in software development. Part of this early development concentrated on software development tooling like IDEs . One of the trends in software development around that time was for reusable software components geared towards user interfaces: components that would encapsulate some sort of interesting, reusable functionality into a single package that could be handled as a single entity rather than as a loose collection of individual classes. Sun Microsystems tried to get on the component bandwagon by introducing what they called a JavaBean , a software component not only geared towards the UI but that could also be configured easily from an IDE. In order to make this happen Sun came up with a large specification of JavaBeans (the JavaBeans Spec) dealing mostly with naming conventions (to make the components easy to handle from an IDE). But Sun also realized at the same time that a UI-centric component would need support for an event-driven way of connecting events in the component to business logic that would have to be written by the individual developer. So the JavaBeans Spec also included a small specification for an event Model for the Java platform.When they started working on this Event Model, the Sun engineers were faced with a choice: try to come up with a huge specification to encompass all possible uses of an event model, or just specify an abstract, generic framework that could be expanded for individual use in specific situations. They chose the latter option and so, love it or hate it, the Java Platform has no generic support for event-driven programming other than this general Event Model framework.",Event handling Introduction,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
408,"The basic Event Model frameworkThe Event Model framework is really very simple in and of itself, consisting of three classes (one abstract) and an interface. Most of all it consists of naming conventions that the programmer must obey. The framework is depicted in the image on the right.Speaking in terms of classes and interfaces, the most important parts of the framework are the java.util.EventObject abstract class and the java.util.EventListener interface. These two types are the centerpieces of the rules and conventions of the Java Platform Event Model, which are:A class that has to be notified when an event occurs, is called an event listener . An event listener has one distinct method for each type of event notification that it is interested in.  Event notification method declarations are grouped together into categories. Each category is represented by an event listener interface, which must extend java.util.EventListener . By convention an event listener interface is named <Event category name>Listener . Any class that will be notified of events must implement at least one listener interface.  Any and all state related to an event occurrence will be captured in a state object. The class of this object must be a subclass of java.util.EventObject and must record at least which object was the source of the event. Such a class is called an event class and by convention is named <Event category name>Event .  Usually (but not necessarily!) an event listener interface will relate to a single event class. An event listener may have multiple event notification methods that take the same event class as an argument.  An event notification method usually (but not necessarily!) has the conventional signature public  void <specific event>(<Event category name>Event evt) .  A class that is the source of events must have a method that allows for the registration of listeners, one for each possible listener interface type. These methods must by convention have the signature public  void add<Event category name>Listener(<Event category name>Listener listener) .  A class that is the source of events may have a method that allows for the deregistration of listeners, one for each possible listener interface type. These methods must by convention have the signature public  void remove<Event category name>Listener(<Event category name>Listener listener) .A general example of how the framework is usedThat seems like a lot, but it's pretty simple once you get used to it. Take a look at the image on the left, which contains a general example of how you might use the framework. In this example we have a class called EventSourceClass that publishes interesting events. Following the rules of the Event Model, the events are represented by the InterestingEvent class which has a reference back to the EventSourceClass object ( source , inherited from java.util.EventObject ).Whenever an interesting event occurs, the EventSourceClass must notify all of the listeners for that event that it knows about by calling the notification method that exist for that purpose. All of the notification methods (in this example there is only one, interestingEventOccurred ) have been grouped together by topic in a listener interface: InterestingEventListener , which implements java.util.EventListener and is named according to the Event Model conventions. This interface must be implemented by all event listener classes (in this case only InterestingEventListenerImpl ). Because EventSourceClass must be able to notify any interested listeners, it must be possible to register them. For this purpose the EventSourceClass has an addInterestingEventListener method. And since it is required, there is a removeInterestingEventListener method as well.As you can clearly see from the example, using the Event Model is mostly about following naming conventions. This might seem a little cumbersome at first, but the point of having naming conventions is to allow automated tooling to access and use the event model. And there are indeed many tools, IDEs and frameworks that are based on these naming conventions.",Event handling The Event Model framework,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
409,"There's one more thing to notice about the Event Model and that is what is not in the Model. The Event Model is designed to allow implementations a large degree of freedom in the implementation choices made, which means that the Event Model can serve as the basis for a very wide range of specific, purpose-built event handling systems.Aside from naming conventions and some base classes and interfaces, the Event Model specifies the following:It must be possible to register and deregister listeners.  An event source must publish events by calling the correct notification method on all registered listeners.  A call to an event notification method is a normal, synchronous Java call and the method must be executed by the same thread that called it.But the Event Model doesn't specify how any of this must be done. There are no rules regarding which classes exactly must be event sources, nor about how they must keep track of registered event listeners. So one class might publish its own events, or be responsible for publishing the events that relate to an entire collection of objects (like an entire component). And an event source might allow listeners to be deregistered at any time (even in the middle of handling an event) or might limit this to certain times (which is relevant to multithreading).Also, the Event Model doesn't specify how it must be embedded within any program. So, while the model specifies that a call to an event handling method is a synchronous call, the Model does not prescribe that the event handling method cannot hand off tasks to another thread or that the entire event model implementation must run in the main thread of the application. In fact, the Java Platform's standard user interface framework ( Swing ) includes an event handling implementation that runs as a complete subsystem of a desktop application, in its own thread.",Event handling Degrees of freedom in the Model,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
410,"In the previous section we mentioned that an event notification method usually takes a single argument. This is the preferred convention, but the specification does allow for exceptions to this rule if the application really needs that exception. A typical case for an exception is when the event notification must be sent across the network to a remote system though non-Java means, like the CORBA standard. In this case it is required to have multiple arguments and the Event Model allows for that. However, as a general rule the correct format for a notification method isAnother thing we mentioned earlier is that, as a general rule, the Event Model allows many event listeners to register with a single event source for the same event. In this case the event source must broadcast any relevant events to all the registered listeners. However, once again the Event Model specification allows for an exception to the rule. If it is necessary from a design point of view you may limit an event source to registering a single listener; this is called unicast event listener registration . When unicast registration is used, the registration method must be declared to throw the java.util.TooManyListenersException exception if too many listeners are registered:An event adaptor in between the event source and the event listener.Finally, the specification allows for one more extension: the event adaptor. An event adaptor is an implementation of an event listener interface that can be inserted between an event source and an actual event listener class. This is done by registering the adaptor with the event source object using the regular registration method. Adaptors are used to add additional functionality to the event handling mechanism, such as routing of event objects, event filtering or enriching of the event object before processing by an actual event handler class.","Event handling Event notification methods, unicast event handling and event adaptors",https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
411,"In the previous section we've explored the depths (such as there are) of the Java platform Event Model framework. If you're like most people, you've found the theoretical text more confusing than the actual use of the model. Certainly more confusing than should be necessary to explain what is, really, quite a simple framework.In order to clear everything up a bit, let's examine a simple example based on the Event Model framework. Let's assume that we want to write a program that reads a stream of numbers input by the user at the command line and processes this stream somehow. Say, by keeping track of the running sum of numbers and producing that sum once the stream has been completely read.Of course we could implement this program quite simply with a loop in a main() method. But instead let's be a little more creative. Let's say that we want to divide our program neatly into classes, each with a responsibility of its own (like we should in a proper, object-oriented design). And let's imagine that we want it to be possible not only to calculate the sum of all the numbers read, but to perform any number of calculations on the same number stream. In fact, it should be possible to add new calculations with relative ease and without having to affect any previously existing code.If we analyze these requirements, we come to the conclusion that we have a number of different responsibilities in the program:Using the Event Model framework allows us to separate the two main responsibilities cleanly and affords us the flexibility we are looking for. If we implement the logic for reading the number stream in a single class and treat the reading of a single number as an event, the Event Model allows us to broadcast that event (and the number) to as many stream processors as we like. The class for reading the number stream will act as the event source of the program and each stream processor will be a listener. Since each listener is a class of its own and can be registered with the stream reader (or not) this means our model allows us to have multiple, independent stream processing that we can add on to without affecting the code to read the stream or any pre-existing stream processor.The Event Model says that any state associated with an event should be included in a class that represents the event. That's perfect for us; we can implement a simple event class that will record the number read from the command line. Each listener can then process this number as it sees fit.For our interesting event set let's keep things simple: let's limit ourselves to having read a new number and having reached the end of the stream. With this choice we come to the following design for our example application:In the following sections we look at the implementation of this example.",Event handling A simple example,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
412,"Let's start with the basics. According to the Event Model rules, we must define an event class to encapsulate our interesting event. We should call this class something-something Event. Let's go for NumberReadEvent , since that's what will interest us. According to the Model rules, this class should encapsulate any state that belongs with an event occurrence. In our case, that's the number read from the stream. And our event class must inherit from java.util.EventObject . So all in all, the following class is all we need:Next, we must define a listener interface. This interface must define methods for interesting events and must extend java.util.EventListener . We said earlier our interesting events were ""number read"" and ""end of stream reached"", so here we go:Actually the numberStreamTerminated method is a little weird, since it isn't actually a ""number read"" event. In a real program you'd probably want to do this differently. But let's keep things simple in this example.",Event handling Example basics,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
413,"So, with our listener interface defined, we need one or more implementations (actual listener classes). At the very least we need one that will keep a running sum of the numbers read. We can add as many as we like, of course. But let's stick with just one for now. Obviously, this class must implement our NumberReadListener interface. Keeping a running summation is a matter of adding numbers to a field as the events arrive. And we wanted to report on the sum when the end of the stream is reached; since we know when that happens (i.e. the numberStreamTerminated method is called), a simple println statement will do:So, is this code any good? No. It's yucky and terrible and most of all not thread safe. But it will do for our example.",Event handling The event listener implementation,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
414,"This is where things get interesting: the event source class. This is the interesting place because this is where we must put code to read the number stream, code to send events to all the listeners and code to manage listeners (add and remove them and keep track of them).Let's start by thinking about keeping track of listeners. Normally this is a tricky business, since you have to take all sorts of multithreading concerns into account. But we're being simple in this example, so let's just stick with a simple java.util.Set of listeners. Which we can initialize in the constructor:That choice makes it really easy to implement adding and removing of listeners:We won't actually use the remove method in this example  but recall that the Model says it must be present.Another advantage of this simple choice is that notification of all the listeners is easy as well. We can just assume any listeners will be in the set and iterate over them. And since the notification methods are synchronous (rule of the model) we can just call them directly:Note that we've made some assumptions here. For starters, we've assumed that we'll get the Double value d from somewhere. Also, we've assumed that no listener will ever care about the number value in the end-of-stream notification and have passed in the fixed value 0 for that event.Finally we must deal with reading the number stream. We'll use the Console class for that and just keep on reading numbers until there are no more:Note how we've hooked the number-reading loop into the event handling mechanism by calling the notify methods? The entire class looks like this:",Event handling The event source,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
415,"Finally, we need one more class: the kickoff point for the application. This class will contain a main() method, plus code to create a NumberReader, a listener and to combine the two:If you compile and run the program, the result looks somewhat like this:",Event handling Running the example,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
416,"Next, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:is general to the process and not specific to any one listener; or  is not supposed to affect the implementation of specific listeners.According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as ""proof"" for the calculations done in the listeners.An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:Uses a fixed log file name and overwrites that log file with every program run.  Opens a FileWriter in the constructor and just keeps it open.  Implements the numberRead method by writing the number to the FileWriter .  Implements the numberStreamTerminated method by closing the FileWriter .Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:Of course, to make the adaptor work we have to make some changes to the bootstrap code:But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.And of course, if we run the same example as given above, the numbers are now recorded in a log file.",Event handling Extending the example with an adaptor,https://en.wikibooks.org//wiki/Java_Programming/Event_Handling
417,"Reusability comes at the core of any modern computer language's framework. It is often desirable to use components you previously built in recurring environments. In Rapid Application Development , these prove more helpful as you can drag them off a list of components and use it elsewhere in your project. Such level of reusability is added into the Java Programming language with the help of the JavaBeans architecture.JavaBeans are the mainstream Java component model, introduced in 1996 by Sun Microsystems. JavaBeans are defined as follows:""A JavaBean is a reusable software component that can be manipulated visually in a builder tool.""Together with the component model, Sun released a simple visual composition tool, the BeanBox. It is mostly intended for experimenting with Beans rather than offering a professional IDE. For real world applications, one should better deploy on one of the Java IDEs like Visual Age or JBuilder that support the visual composition of JavaBeans.As we will see, JavaBeans do not essentially differ from standard Java classes, which makes the component model quite easy to use. What sets a JavaBean apart from normal Java classes is that a JavaBean follows the Oracle JavaBeans Standard (the term JavaBean or simply bean also refers to the instances of a JavaBean class). There is a set of features and conventions adopted for facilitating reuse:Presence of a no argument constructor;  Support for persistence;  Properties manipulated by getter and setter methods;  Support for introspection;  Events as the mechanism of communication between beans;  Support for customization via property editors.The JavaBeans standard provides a framework for creating objects to be used by GUI tools, including Java development environments. But in more common usage, a bean is a serializable class that follows the JavaBeans naming conventions for its properties. These naming standards make it easy to use Java introspection .",JavaBeans ,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
418,"To follow these standards, the bean needs one or more properties abstractions which represent different state values of an object. A property has a name (a valid Java identifier) and a type (either a reference type , a primitive type or an array type ). By default, the properties of a JavaBean class are inferred by the presence of either a getter method, a setter method, or both:A getter method which is used to obtain the value of the property from a bean. The name is usually of the form get PropertyName . For example, the getter method for the String property whiskey is public String getWhiskey() . For boolean properties (those whose type is boolean , the convention is to use the naming pattern is PropertyName .isDiscounted() would be the getter method for a boolean property named discounted . Thus, the method signature of most getters is public PropertyType get PropertyName () or public boolean is PropertyName () .A setter method which is used to assign a value to a bean's property. A setter method is a method of the form public void set PropertyName ( PropertyType value) . For the previous example, the setter could be invoked as setWhiskey(""bourbon""); .As per the JavaBeans standard, getters and setters defined as described above automatically determine the properties of the class. However, by creating java.beans.PropertyDescriptor classes, you can specify alternate implementations by explicitly declaring the property names and the getter and/or setter methods for each property.Properties are often implemented with private  instance variables , but this is not required.",JavaBeans Implementation,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
419,This is an example of a simple JavaBean type with the properties int age and String color .,JavaBeans A Simple JavaBean,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
420,"The requirements for an object to be a bean is to define a public parameterless constructor, so that beans can be instantiated by builder tools in an uncomplicated way (In the Point bean, the parameterless constructor is given implicitly). Secondly, one of the interfaces java.io.Serializable or java.io.Externalizable need to be implemented. The interfaces do not prescribe the implementation of any methods, but are an approval, that the bean may be saved in persistent storage as in a file or database. In doing so, the bean can be restored after an application was shut down or transferred across networks. The ability to store state of a component in persistent storage is called persistence . Java offers a standard serialization mechanism, which makes it very easy to serialize objects. Alternatively, a component can be stored in a customized manner (e.g. in xml format) by implementing the Externalizable interface.",JavaBeans Persistence,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
421,"The properties of a bean are all private fields that are accessible and modifiable by public methods. These getter and setter methods should be marked as such by following a simple naming convention: for some property named, say, xxx there should be a getXxx() which returns the property value and a setXxx() which sets the property.",JavaBeans Properties,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
422,"In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.For example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field ""name"" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple ""is-a"" relationship can be confusing, as can looking through dozens of class definitions to find where a single ""dumb"" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.or",JavaBeans Introspection,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
423,"JavaBeans interact with each other by means of events . Events are notifications, a component can give to other components, that something interesting has happened. An example for an event might be a mouse click on a button or the closing of a window. Beans can be source and target of events. To be informed about an event, a bean has to register at another Bean as a listener .The Java event model realizes the observer design pattern with the effect that the inter-component coupling is reduced. Method calls require tight coupling, as caller and receiver need to know each other at compile time, while with events all communication happens solely via interfaces.A special kind of event are PropertyChangeEvents . They are used to restrict some properties to take only specific values, for example for a month integer values between 1 and 12. Every time, such a bound property is modified, notifications to all registered PropertyChangeListeners will be send.",JavaBeans Events,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
424,"Customization is done via Property Editors . A property editor is a tool for customizing at design time a particular property type. Property editors are activated from so-called property sheets , which display all properties of a bean. If a property is selected for customization, the property sheet finds out the type of the property, displays the appropriate property editor with the property's current value.",JavaBeans Customization,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
425,"A big strength of the JavaBean component model is that it is designed for simplicity. Developing JavaBeans is very simple, because a lot of behavior (like the platform independence or packaging mechanism) is supported in the Java Programming Language by default. However, one can optionally equip beans with additional objects like BeanInfos or custom PropertyEditors to use the component model in a more flexible way. A second facility is that Sun designed the whole Swing GUI library according to the JavaBeans component model. Thereby Swing components can easily be composed in visual builder tools.However, JavaBeans do not realize all features of a component model. A drawback is that JavaBeans are restricted to the Java programming language, while an important goal of components is the independence of an implementation language.",JavaBeans Additional Remarks,https://en.wikibooks.org//wiki/Java_Programming/JavaBeans
426,"An essential part of programming in Java requires you to build exciting new user interfaces for yourselves. Components that come built into the Java framework are regular UI elements, however for a more rich experience, you need controls of your own. Take, for instance, a charting application. No charting tool comes built into a Java API. You need to manually draw the chart yourself.Coding drawing, to begin with, is pretty daunting but once you know the basics of Graphics programming in Java, you can create elegant graphics and art in no time. But the question that arises in one's mind is what to draw on. The answer to this question is simpler than it seems. You can start drawing on any component in the Java framework. Whether it be a panel, window or even a button.Let me break it down for you. A component in the Java language is a class that has been derived from the Component class. Each component has a method with a signature paint(Graphics) which can be overridden to manually draw something atop it.",Canvas ,https://en.wikibooks.org//wiki/Java_Programming/Canvas
427,"Below is an example on how you need to override the above method. For this very example, the component class that we would be using would be the Canvas class. For more information about the Canvas class, see the section on Understanding the Canvas class",Canvas Overriding the paint(Graphics) method,https://en.wikibooks.org//wiki/Java_Programming/Canvas
428,"Code listing 9.1 shows the simplicity and power of the syntax for enabling the graphics functions within Java. Lets begin by understanding what a Canvas class does. A Canvas class is a derivative or a sub-class of the Component class and when placed over a Frame , displays as a blank area.For the purpose of drawing graphics, you may use any other class derived from the Component class, for instance, JPanel or even JTextField or JButton . Why we use the Canvas class is purely to grasp the idea of drawing in Java.Let us refine the above code for the class to be executable and the Canvas to be displayed. For this we will add an entry-point method namely the main(String[]) method in its body and calling a JFrame class to load the canvas on.The following code now helps our class to be executable and displays the canvas on top of the frame as it displays. Running this class would result in an empty frame, however it should be clear that the canvas is sitting atop it and is merely not displaying any drawings yet.Figure 9.1: A blank canvas atop a JFrame",Canvas Understanding the Canvas class,https://en.wikibooks.org//wiki/Java_Programming/Canvas
429,"Throughout this chapter, we will refer to the process of creating Graphical content with code as either drawing or painting. However, Java officially recognizes the latter as the proper word for the process, but we will differentiate between the two later on.Now, the main class that you would be needing would, without doubt, be the Graphics class. If you take a closer look at the method that we used in theIdentifying the acquisition of the Graphics class in our codeTo view the contents of the Graphics class, please check the external links at the bottom of the page for links to the online API.",Drawing basic shapes Introduction to Graphics,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
430,"To start off your drawing experience, consider drawing the most basic shape  a line. A canvas when viewed upon with regards to drawing routines can be expressed as an inverted Cartesian coordinate system . A plane expressed by an x- and a y-axis. The origin point or     (  0  ,  0  )    {\displaystyle (0,0)}   being the top-left corner of a canvas and the visible area of the canvas being the Cartesian quadrant I or the positive-positive (+,+) quadrant . The further you go down from the top, the greater the value of y-coordinate on the y-axis, vice-versa for the x-axis as you move toward the right from the left. And unlike the values on a normal graph, the values appear to be positive. So a point at     (  10  ,  20  )    {\displaystyle (10,20)}   would be 10 pixels away from the left and 20 pixels away from the top, hence the format     (  x  ,  y  )    {\displaystyle (x,y)}   .Figure 9.2: A simple line form displayed across the canvas from Code section 9.4",Drawing basic shapes Understanding coordinates,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
431,"Now, we already know that a line is a connection of two discreet points atop a canvas. So, if one point is at     (  x  1  ,  y  1  )    {\displaystyle (x1,y1)}   and the other is at     (  x  2  ,  y  2  )    {\displaystyle (x2,y2)}   , drawing a line would require you to write a syntax like code below. For the sake of brevity, we will skim out the rest of the method unused in the example.In the above example, a simple method is used to define precisely where to place the line on the Cartesian scale of the canvas. The drawLine(int,int,int,int) asks you to put four arguments, appearing in order, the x1 coordinate , the y1 coordinate , the x2 coordinate and the y2 coordinate . Running the program will show a simple black line diagonally going across the canvas.Figure 9.3: A simple black-outlined rectangle drawn",Drawing basic shapes Drawing a simple line across the screen,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
432,"We now proceed on to our second drawing. A simple rectangle would do it justice, see below for code.In the above example, you see how easy it is to draw a simple rectangle using the drawRect(int, int, int, int) method in the Graphics instance that we obtained. Run the program and you will see a simple black outline of a rectangle appearing where once a blank canvas was.The four arguments that are being passed into the method are, in order of appearance, the x-coordinate , the y-coordinate , width and the height . Hence, the resultant rectangle would start painting at the point on the screen 10 pixels from the left and 10 from the top and would be a 100 pixel wide and a 100 pixel in height. To save the argument here, the above drawing is that of a square with equal sides but squares are drawn using the same method and there is no such method as drawSquare(int, int, int)Figure 9.4: Same rectangle drawn with a red outline",Drawing basic shapes Drawing a simple rectangle,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
433,"You can change the color of the outline by telling the Graphics instance the color you desire. This can be done as follows:Running the program would render the same rectangle but with a red colored outline.For the purposes of bringing color to our drawing, we used a method namely the setColor(Color) method. This method comes into force for all the drawing made after its call until another color is set. It asks for an argument of type Color . Now because you have no idea of how to actually instantiate a Color class, the class itself has a few built-in colors. Some built-in colors that you can use are mentioned below.Color .red  Color .blue  Color .green  Color .yellow  Color .pink  Color .black  Color .whiteTry running the program while coding changes to colors for a different colored outline each time. Play around a bit with more colors. Look for the Color class API documentation in the external links at the bottom of the page.Figure 9.5: Same rectangle drawn with a red outline and a yellow fill",Drawing basic shapes Playing around with colors,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
434,"Up until now, you have been able to draw a simple rectangle for yourself while asking a question silently, ""why is the outline of the rectangle being painted rather the area as a whole?"" The answer is simple. Any method that starts with drawXxxx(...) only draws the outline. To paint the area within the outline, we use the fillXxxx(...) methods. For instance, the code below would fill a rectangle with yellow color while having a red outline. Notice that the arguments remain the same.Figure 9.6: A white circle drawn with a blue outline",Drawing basic shapes Filling up the area of the rectangle,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
435,"Drawing a circle is ever so easy? It is the same process as the syntax above only that the word Rect is changed to the word Oval . And don't ask me why oval? You simply don't have the method drawCircle(int, int, int) as you don't have drawSquare(int, int, int) . Following is the application of Graphics code to draw a circle just to whet your appetite.",Drawing basic shapes What about a circle?,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
436,"Figure 9.7: A pink rounded rectangle with a red outline. Amazing!Simple so far, isn't it? Of all the shapes out there, these two are the only shapes that you'd need to build for the moment. Complex graphics routines are required to build shapes like a rhombus, triangle, trapezium or a parallelogram. We would be tackling them later on in another section. However, on a last note I would leave you with another interesting shape - a combination of both ovals and rectangle. Think a rectangle with rounded corners, a Rounded Rectangle ( RoundRect ).Notice that the syntax of the drawRoundRect(int, int, int, int, int, int) method is a bit different than the syntax for the simple rectangle drawing routine drawRect(int, int, int, int) . The two new arguments added at the end are the width of the arc in pixels and the height of the arc in pixels . The result is pretty amazing when you run the program. You don't need to squint your eyes to tell that the corners of the rectangle are slightly rounded. The more the values of the width and height of the arcs, the more roundness appears to form around the corner.",Drawing basic shapes A new form of a rectangle,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
437,"Sometimes people ask, after creating simple programs like the ones above, questions like:Why did I have to tell the Graphics instance the color before each drawing routine? Why can't it remember my choice for the outlines and for the fill colors? The answer is simpler than it seems. But, to fully understand it, we need to focus on one little thing called the Graphics Context . The graphics context is the information that adheres to a single instance of the Graphics class. Such an instance remembers only one color at a time and that is why we need to make sure the context knows of the color we need to use by using the setColor(Color) method.  Can I manipulate the shapes, like tilt them and crop them? Hold your horses, cowboy! Everything is possible in Java, even tilting and cropping drawings. We will be focusing on these issues in a later section.  Is making shapes like triangles, rhombuses and other complex ones tedious? Well, to be honest here, you need to go back to your dusty book cabinet and take out that High School Geometry book because we would be covering some geometry basics while dealing with such shapes. Why not read a wikibook on Geometry ?Test your knowledge  Question 9.3 : Throughout the exercise listings above, we have been filling the shapes first and then drawing their outlines. What happens if we do it the other way around? Consider the code below.   ...  public  void  paint ( Graphics  graphics )  {  graphics . setColor ( Color . red );  graphics . drawRect ( 10 ,  10 ,  100 ,  100 );  graphics . setColor ( Color . yellow );  graphics . fillRect ( 10 ,  10 ,  100 ,  100 );  }  ...   The left and the top outlines disappear.  The right and the bottom outlines disappear.  The color for the outline becomes the color for the fill area.  All the outlines disappear.  Answer  All the outlines disappear.   Question 9.4: What would drawLine(10, 100, 100, 100) give you?   A horizontal line.  A vertical line.  A diagonal line.  Answer  A horizontal line.If you have any questions regarding the content provided here, please feel free to comment in this page's discussion .","Drawing basic shapes Hmm, everything's perfect, but...",https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
438,"Throughout this chapter, we will refer to the process of creating Graphical content with code as either drawing or painting. However, Java officially recognizes the latter as the proper word for the process, but we will differentiate between the two later on.Now, the main class that you would be needing would, without doubt, be the Graphics class. If you take a closer look at the method that we used in theIdentifying the acquisition of the Graphics class in our codeTo view the contents of the Graphics class, please check the external links at the bottom of the page for links to the online API.",Drawing basic shapes Introduction to Graphics,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
439,"To start off your drawing experience, consider drawing the most basic shape  a line. A canvas when viewed upon with regards to drawing routines can be expressed as an inverted Cartesian coordinate system . A plane expressed by an x- and a y-axis. The origin point or     (  0  ,  0  )    {\displaystyle (0,0)}   being the top-left corner of a canvas and the visible area of the canvas being the Cartesian quadrant I or the positive-positive (+,+) quadrant . The further you go down from the top, the greater the value of y-coordinate on the y-axis, vice-versa for the x-axis as you move toward the right from the left. And unlike the values on a normal graph, the values appear to be positive. So a point at     (  10  ,  20  )    {\displaystyle (10,20)}   would be 10 pixels away from the left and 20 pixels away from the top, hence the format     (  x  ,  y  )    {\displaystyle (x,y)}   .Figure 9.2: A simple line form displayed across the canvas from Code section 9.4",Drawing basic shapes Understanding coordinates,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
440,"Now, we already know that a line is a connection of two discreet points atop a canvas. So, if one point is at     (  x  1  ,  y  1  )    {\displaystyle (x1,y1)}   and the other is at     (  x  2  ,  y  2  )    {\displaystyle (x2,y2)}   , drawing a line would require you to write a syntax like code below. For the sake of brevity, we will skim out the rest of the method unused in the example.In the above example, a simple method is used to define precisely where to place the line on the Cartesian scale of the canvas. The drawLine(int,int,int,int) asks you to put four arguments, appearing in order, the x1 coordinate , the y1 coordinate , the x2 coordinate and the y2 coordinate . Running the program will show a simple black line diagonally going across the canvas.Figure 9.3: A simple black-outlined rectangle drawn",Drawing basic shapes Drawing a simple line across the screen,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
441,"We now proceed on to our second drawing. A simple rectangle would do it justice, see below for code.In the above example, you see how easy it is to draw a simple rectangle using the drawRect(int, int, int, int) method in the Graphics instance that we obtained. Run the program and you will see a simple black outline of a rectangle appearing where once a blank canvas was.The four arguments that are being passed into the method are, in order of appearance, the x-coordinate , the y-coordinate , width and the height . Hence, the resultant rectangle would start painting at the point on the screen 10 pixels from the left and 10 from the top and would be a 100 pixel wide and a 100 pixel in height. To save the argument here, the above drawing is that of a square with equal sides but squares are drawn using the same method and there is no such method as drawSquare(int, int, int)Figure 9.4: Same rectangle drawn with a red outline",Drawing basic shapes Drawing a simple rectangle,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
442,"You can change the color of the outline by telling the Graphics instance the color you desire. This can be done as follows:Running the program would render the same rectangle but with a red colored outline.For the purposes of bringing color to our drawing, we used a method namely the setColor(Color) method. This method comes into force for all the drawing made after its call until another color is set. It asks for an argument of type Color . Now because you have no idea of how to actually instantiate a Color class, the class itself has a few built-in colors. Some built-in colors that you can use are mentioned below.Color .red  Color .blue  Color .green  Color .yellow  Color .pink  Color .black  Color .whiteTry running the program while coding changes to colors for a different colored outline each time. Play around a bit with more colors. Look for the Color class API documentation in the external links at the bottom of the page.Figure 9.5: Same rectangle drawn with a red outline and a yellow fill",Drawing basic shapes Playing around with colors,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
443,"Up until now, you have been able to draw a simple rectangle for yourself while asking a question silently, ""why is the outline of the rectangle being painted rather the area as a whole?"" The answer is simple. Any method that starts with drawXxxx(...) only draws the outline. To paint the area within the outline, we use the fillXxxx(...) methods. For instance, the code below would fill a rectangle with yellow color while having a red outline. Notice that the arguments remain the same.Figure 9.6: A white circle drawn with a blue outline",Drawing basic shapes Filling up the area of the rectangle,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
444,"Drawing a circle is ever so easy? It is the same process as the syntax above only that the word Rect is changed to the word Oval . And don't ask me why oval? You simply don't have the method drawCircle(int, int, int) as you don't have drawSquare(int, int, int) . Following is the application of Graphics code to draw a circle just to whet your appetite.",Drawing basic shapes What about a circle?,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
445,"Figure 9.7: A pink rounded rectangle with a red outline. Amazing!Simple so far, isn't it? Of all the shapes out there, these two are the only shapes that you'd need to build for the moment. Complex graphics routines are required to build shapes like a rhombus, triangle, trapezium or a parallelogram. We would be tackling them later on in another section. However, on a last note I would leave you with another interesting shape - a combination of both ovals and rectangle. Think a rectangle with rounded corners, a Rounded Rectangle ( RoundRect ).Notice that the syntax of the drawRoundRect(int, int, int, int, int, int) method is a bit different than the syntax for the simple rectangle drawing routine drawRect(int, int, int, int) . The two new arguments added at the end are the width of the arc in pixels and the height of the arc in pixels . The result is pretty amazing when you run the program. You don't need to squint your eyes to tell that the corners of the rectangle are slightly rounded. The more the values of the width and height of the arcs, the more roundness appears to form around the corner.",Drawing basic shapes A new form of a rectangle,https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
446,"Sometimes people ask, after creating simple programs like the ones above, questions like:Why did I have to tell the Graphics instance the color before each drawing routine? Why can't it remember my choice for the outlines and for the fill colors? The answer is simpler than it seems. But, to fully understand it, we need to focus on one little thing called the Graphics Context . The graphics context is the information that adheres to a single instance of the Graphics class. Such an instance remembers only one color at a time and that is why we need to make sure the context knows of the color we need to use by using the setColor(Color) method.  Can I manipulate the shapes, like tilt them and crop them? Hold your horses, cowboy! Everything is possible in Java, even tilting and cropping drawings. We will be focusing on these issues in a later section.  Is making shapes like triangles, rhombuses and other complex ones tedious? Well, to be honest here, you need to go back to your dusty book cabinet and take out that High School Geometry book because we would be covering some geometry basics while dealing with such shapes. Why not read a wikibook on Geometry ?Test your knowledge  Question 9.3 : Throughout the exercise listings above, we have been filling the shapes first and then drawing their outlines. What happens if we do it the other way around? Consider the code below.   ...  public  void  paint ( Graphics  graphics )  {  graphics . setColor ( Color . red );  graphics . drawRect ( 10 ,  10 ,  100 ,  100 );  graphics . setColor ( Color . yellow );  graphics . fillRect ( 10 ,  10 ,  100 ,  100 );  }  ...   The left and the top outlines disappear.  The right and the bottom outlines disappear.  The color for the outline becomes the color for the fill area.  All the outlines disappear.  Answer  All the outlines disappear.   Question 9.4: What would drawLine(10, 100, 100, 100) give you?   A horizontal line.  A vertical line.  A diagonal line.  Answer  A horizontal line.If you have any questions regarding the content provided here, please feel free to comment in this page's discussion .","Drawing basic shapes Hmm, everything's perfect, but...",https://en.wikibooks.org//wiki/Java_Programming/Graphics/Drawing_shapes
447,"A Java applet is an applet delivered in the form of Java bytecode. Java applets can run in a Web browser using a Java Virtual Machine (JVM), or in Oracle's AppletViewer, a stand alone tool to test applets. Java applets were introduced in the first version of the Java language in 1995. Java applets are usually written in the Java programming language but they can also be written in other languages that compile to Java bytecode such as Jython.Applets are used to provide interactive features to web applications that cannot be provided by HTML . Since Java's bytecode is platform independent, Java applets can be executed by browsers for many platforms, including Windows, Unix, Mac OS and Linux.  There are open source tools like applet2app which can be used to convert an applet to a stand alone Java application/windows executable.  This has the advantage of running a Java applet in off-line mode without the need for Internet browser software.The Java applet is less and less used. You'd rather use JavaScript when it is possible.",Overview ,https://en.wikibooks.org//wiki/Java_Programming/Applets/Overview
448,"The two things you must at least create is an HTML page and a Java class. It can be done on a local folder, no need to run a server but it will be harder to understand what is local, what is remote. The HTML page has to call the Java class using the <applet/> markup:Save this file on a folder. As the <applet/> markup is calling a Java class called HelloWorld , our class should be called HelloWorld.java :Save this file and compile the class on the same folder. Now let's open the web page on a browser:Figure 9.8: Java applet HelloWorld.We clearly see that ""Hello, world!"" is not rendered the same way as the rest of the page.",Overview First applet,https://en.wikibooks.org//wiki/Java_Programming/Applets/Overview
449,"See also applet markup .To embed an applet in a HTML page, you have to insert a <applet/> markup. This markup can have several attributes:The attributes with * are mandatory.There have been some discussions about the usage of applet tag but it still can be used for beginning and also would work in the real world as well.",Overview HTML code,https://en.wikibooks.org//wiki/Java_Programming/Applets/Overview
450,"The main difference between an applet and a regular command-line executed program is that applets allow for extensible Graphical User Interfaces (GUI).Since applets provide for the ability to create complex GUI, it is important for developers to know how to create such programs.",User Interface ,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
451,"In Java applets, graphical portions are initialized and added in two different areas.  While objects are initialized in the main class, they are added to the layout of the applet in the init() method.  This is done using the syntax of add(<object>) .  A typical init() method looks something like this:The different aspects of this method will be covered below.",User Interface Applying styles and adding content,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
452,"Lots of applets use buttons.  There are only a few ways to have contact between the applet and the user, and the use of buttons is one of those ways.  Buttons are created the same way as most other Java applet objects:When initializing a button, it is necessary to define what text will appear on that button in the given parameter.  In this example, the button is initialized with the word ""Submit"" printed on it. Adding the button to the actual layout is done in the init() method, as described above.Allowing buttons to carry out tasks or utilize a user's input is a bit more complicated.  These functions require an ActionListener , and will be discussed in ActionListener section.",User Interface Button,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
453,"Labels are areas in applets that contain text which can not be edited by the user.  This is usually ideal for descriptions (i.e. ""Insert name:"").  Labels are initialized and added to applet layouts in the same way as buttons.  Also, like buttons, the text inside labels must be identified at initialization.  If, however, the label will receive its text as the cause of a later function and should start off blank, no text should be placed between the quotation marks.",User Interface Label,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
454,"TextFields are areas in applets that allow users to insert text.  The two parameters, which are optional, for TextFields can set predefined text in the field or set the number of columns allowed in the TextField.  Here are a few examples:",User Interface TextField,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
455,"Using stylish fonts in your Java applets may be necessary to help keep your Java applets attractive.  The setFont() allows for either the font used throughout the applet to be defined or for one element's font to be set at a time.The syntax for setting a font is setFont(<fontName>, <fontStyle>, <fontSize>) .To make every font in the applet plain, size 24 Times New Roman, the following code should be used:It is not necessary to initialize the font and set the font through two different lines of code.However, to make the font of element a plain, size 24 Times New Roman, and element b italicized, size 28 Times New Roman, the following code should be used:To set the color of the fonts used in an applet, the setForeground(<color>) method is used.  This method already includes some predefined colors which can be used by calling, for example, setForeground(Color.white) .  Here are all of the predefined colors:Color.black  Color.blue  Color.cyan  Color.darkGray  Color.gray  Color.green  Color.red  Color.white  Color.yellowTo create a custom color, the RGB values of the color can be passed in as the color parameter.  For example, if red were not a predefined color, one could use setForeground(new Color(255, 0, 0)) to define red.Just as font styles, font colors can be applied to separate elements.  The syntax follows the same pattern: a.setForeground(Color.white) .",User Interface Font,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
456,"Layouts are what make applets visible.  Without a layout, nothing would display.  There are five different types of layouts to choose from  some are very simple while others are complex.",User Interface Layout,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
457,"This layout places components left to right, using as much space as is needed. The Flow Layout is the default layout for applets and, therefore, does not need to be set.  However, for clarity, one can specify the applet layout as a Flow Layout by placing this line of code at the top of the init() method:The added components to the layout that follow will be placed on screen in order of which they are added.Assuming that these variables are defined the same as above, these lines of code will create the layout of an applet that is composed of a label, a text field, and a button.  They will all appear on one line if the window permits.  By changing the width of window, the Flow Layout will contract and expand the components accordingly.",User Interface Flow Layout,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
458,"This layout arranges components in the form of the table (grid). The number of rows and columns in the grid is specified in the constructor. The other two parameters, if present, specify vertical and horizontal padding between components.The items have been displayed in this order:We see that the layout has been configured to fill the grid left-to-right and then top-to-bottom and that the two last columns have been ignored (they don't even exist). They have been ignored because there are not enough items to fill them and the number of rows is prior to the number of columns. This means that when you specify a number of rows that is not zero, the number of columns is simply ignored. You should specify zero rows in order that the number of columns is taken into account.A grid layout creates cells with equal sizes. So it can be used not only to display items as a grid but also to display two items with the same width or height.",User Interface Grid Layout,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
459,"This layout places one big component in the center and up till four components at the edges. When adding to the container with this layout, you need to specify the location as the second parameter like BorderLayout.CENTER for the center or one of the world directions for the edge ( BorderLayout.NORTH points to the top edge).If you have two components, it is not the same to put the first in the north and the second to the center as to put the first in the center and the second to the south. In the first case, the layout will calculate the size of the component and the second component will have all the space left. In the second case, it is the opposite.",User Interface Border Layout,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
460,"A card stackThe card layout displays only one item at a time and is only interesting with interactivity. The other items are stored in a stack and the displayed item is one of the items of the stack. The name of the card layout is a reference to a playing card deck where you can see the card at the top of the stack and you can put a card on the top. The difference in the card layout is that the items in the stack keeps their order. When you use this layout, you must use this method to add items to the container, i.e. the applet:The card layout has several methods to change the currently displayed item:",User Interface Card Layout,https://en.wikibooks.org//wiki/Java_Programming/Applets/User_Interface
461,"An Event Listener, once set to an applet object, waits for some action to be performed on it, be it mouse click, mouse hover, pressing of keys, click of button, etc. The class you are using (e.g. JButton , etc.) reports the activity to a class set by the class using it. That method then decides on how to react because of that action, usually with a series of if statements to determine which action it was performed on. source .getSource() will return the name of the object that the event was performed on, while the source is the object passed to the function when the action is performed. Every single time the action is performed, it calls the method.",Event Listeners ,https://en.wikibooks.org//wiki/Java_Programming/Applets/Event_Listeners
462,"ActionListener is an interface that could be implemented in order to determine how a certain event should be handled. When implementing an interface, all methods in that interface should be implemented, ActionListener interface has one method to implement named actionPerformed() .The code listing 9.6 shows how to implement ActionListener :When you compile and run the above code, the message ""Hi!!!"" will appear when you click on the button.",Event Listeners ActionListener,https://en.wikibooks.org//wiki/Java_Programming/Applets/Event_Listeners
463,"Reflection is the mechanism by which Java exposes the features of a class during runtime, allowing Java programs to enumerate and access a class' methods, fields, and constructors as objects. In other words, there are object-based mirrors that reflect the Java object model, and you can use these objects to access an object's features using runtime API constructs instead of compile-time language constructs. 
Each object instance has a getClass() method, inherited from java.lang . Object , which returns an object with the runtime representation of that object's class; this object is an instance of the java.lang . Class , which in turn has methods that return the fields, methods, constructors, superclass, and other properties of that class.
You can use these reflection objects to access fields, invoke methods, or instantiate instances, all without having compile-time dependencies on those features. The Java runtime provides the corresponding classes for reflection. Most of the Java classes that support reflection are in the java.lang.reflect package .
Reflection is most useful for performing dynamic operations with Java  operations that are not hard-coded into a source program, but that are determined at run time. One of the most important aspects of reflection is dynamic class loading .",Reflection Overview ,https://en.wikibooks.org//wiki/Java_Programming/Reflection/Overview
464,Dynamic Class Loading allows the loading of java code that is not known about before a program starts. Many classes rely on other classes and resources such as icons which make loading a single class unfeasible. For this reason the ClassLoader ( java.lang.ClassLoader ) is used to manage all the inner dependencies of a collection of classes. The Java model loads classes as needed and doesn't need to know the name of all classes in a collection before any one of its classes can be loaded and run.,Dynamic Class Loading ,https://en.wikibooks.org//wiki/Java_Programming/Reflection/Dynamic_Class_Loading
465,"All features of a class can be obtained via reflection, including access to private methods & variables. But not always see [1] .
Let us look at the following example:Although the field and method are marked private , the following class shows that it is possible to access the private features of a class:",Accessing Private Features with Reflection ,https://en.wikibooks.org//wiki/Java_Programming/Reflection/Accessing_Private_Features_with_Reflection
466,"Java uses JDBC , an API that defines how a client may access a database. Its drivers may be installed first. [1] [2]",Database programming ,https://en.wikibooks.org//wiki/Java_Programming/Database_Programming
467,"The following is used to open an ODBC connection to an Access database.  Note that the username (and password, if applicable) are given in the DSN rather than the getConnection call.  This is a MS Windows-only example, due to the requirement for the Microsoft Access Driver.Class . forName ( ""sun.jdbc.odbc.JdbcOdbcDriver"" );  String  path  =  ""C:/example.mdb"" ;  String  dsn  =  ""jdbc:odbc:Driver={Microsoft Access Driver (*.mdb)};DBQ=""  +  path  +  "";UID=admin"" ;  accessConn  =  DriverManager . getConnection ( dsn ,  """" ,  """" );",Database programming Connecting to Microsoft Access databases,https://en.wikibooks.org//wiki/Java_Programming/Database_Programming
468,"try  {  Class . forName ( ""com.mysql.jdbc.Driver"" );  Connection  conn  =  DriverManager . getConnection ( ""jdbc:mysql://localhost/MySite?user=MyAccount&password=MyPassword"" );  conn . close ();  }  catch ( SQLException  e )  {  e . printStackTrace ();  }",Database programming Connecting to MySQL,https://en.wikibooks.org//wiki/Java_Programming/Database_Programming
469,"This script returns the database size:import  java.sql.* ;  import  java.io.* ;  import  oracle.jdbc.* ;  import  oracle.sql.* ;  public  class  OracleDatabase  {  public  static  void  main ( String []  args )  {  try  {  DriverManager . registerDriver ( new  oracle . jdbc . OracleDriver ());  Connection  conn  =  DriverManager . getConnection ( ""jdbc:oracle:thin:@localhost:1521:MyDatabase"" ,  ""MyAccount"" ,  ""MyPassword"" );  conn . setAutoCommit ( true );  String  sql  =  ""SELECT sum(bytes) from dba_segments;"" ;  Statement  stmt  =  conn . createStatement ();  stmt . execute ( sql );  stmt . close ();  conn . close ();  }  catch ( SQLException  e )  {  e . printStackTrace ();  }  }  }",Database programming Connecting to Oracle Database,https://en.wikibooks.org//wiki/Java_Programming/Database_Programming
470,"try  {  Class . forName ( ""org.postgresql.Driver"" );  Connection  conn  =  DriverManager . getConnection ( ""jdbc:postgresql:MyDatabase"" ,  ""MyAccount"" ,  ""MyPassword"" );  conn . close ();  }  catch ( SQLException  e )  {  e . printStackTrace ();  }",Database programming Connecting to PostgreSQL,https://en.wikibooks.org//wiki/Java_Programming/Database_Programming
471,"If you have Oracle Database on your PC, just add to the classpath its following files [3] :C:\oracle12\app\oracle\product\12.1.0\dbhome_1\jdbc\lib\ojdbc7.jar  C:\oracle12\app\oracle\product\12.1.0\dbhome_1\sqlj\lib\runtime12.jarOtherwise, ojdbc7.jar can be downloaded from http://www.oracle.com/technetwork/database/features/jdbc/jdbc-drivers-12c-download-1958347.html , and add it to the compilation. Eg:javac MyClass.java -classpath ojdbc7.jar",Database programming package oracle.jdbc does not exist,https://en.wikibooks.org//wiki/Java_Programming/Database_Programming
472,"Just add "" as sysdba"" after your Oracle account name, eg:Connection conn = DriverManager.getConnection(""jdbc:oracle:thin:@localhost:1521:MyDatabase"", ""MyAccount as sysdba"",",Database programming ORA-28009: connection as SYS should be as SYSDBA or SYSOPER,https://en.wikibooks.org//wiki/Java_Programming/Database_Programming
473,The regular expressions (regex) are provided by the package java.util.regex .,Regular Expressions ,https://en.wikibooks.org//wiki/Java_Programming/Regular_Expressions
474,"The Pattern class offers the function matches which returns true if an expression is found into a string.For example, this script returns the unknown word preceding a known word:import  java.util.regex.Pattern ;  public  class  Regex  {  public  static  void  main ( String []  args )  {  String  s  =  ""Test Java regex for Wikibooks."" ;  System . out . println ( Pattern . matches ( ""[a-z]* Wikibooks"" , s ));  }  }  // Displays: ""for Wikibooks""The Matcher class allows to get all matches for a given expression, with different methods:find() : find the next result.  group() : displays the result.For example, this script displays the HTML b tags contents:import  java.util.regex.Pattern ;  import  java.util.regex.Matcher ;  public  class  Regex  {  public  static  void  main ( String []  args )  {  String  s  =  ""Test <i>Java</i> <b>regex</b> for <b>Wikibooks</b>."" ;  Pattern  p  =  Pattern . compile ( ""<b>([^<]+)</b>"" );  Matcher  m  =  p . matcher ( s );  while ( m . find ())  {  System . out . println ( m . group ());  System . out . println ( m . group ( 1 ));  }  }  }  /* Displays:  <b>regex</b>  regex  <b>Wikibooks</b>  Wikibooks  */",Regular Expressions Researches,https://en.wikibooks.org//wiki/Java_Programming/Regular_Expressions
475,"Although Java comes with the Java 3D library other libraries have been developed over time with similar functionality.  Thus, unlike many other areas of Java development explored in this book, a Java programmer has a choice to make as to which 3D library to use.",3D programming ,https://en.wikibooks.org//wiki/Java_Programming/3D_Programming
476,"The Java Native Interface (JNI) enables Java code running in a Java Virtual Machine (JVM) to call and to be called by native applications (programs specific to a hardware and operating system platform) and libraries written in other languages, such as C, C++ and assembly.JNI can be used:To implement or use features that are platform-specific.  To implement or use features that the standard Java class library does not support.  To enable an existing applicationwritten in another programming languageto be accessible to Java applications.  To let a native method use Java objects in the same way that Java code uses these objects (a native method can create Java objects and then inspect and use these objects to perform its tasks).  To let a native method inspect and use objects created by Java application code.  For time-critical calculations or operations like solving complicated mathematical equations (native code may be faster than JVM code).On the other hand, an application that relies on JNI loses the platform portability Java offers. So you will have to write a separate implementation of JNI code for each platform and have Java detect the operating system and load the correct one at runtime. Many of the standard library classes depend on JNI to provide functionality to the developer and the user (file I/O, sound capabilities...). Including performance- and platform-sensitive API implementations in the standard library allows all Java applications to access this functionality in a safe and platform-independent manner. Only applications and signed applets can invoke JNI. JNI should be used with caution. Subtle errors in the use of JNI can destabilize the entire JVM in ways that are very difficult to reproduce and debug. Error checking is a must or it has the potential to crash the JNI side and the JVM.This page will only explain how to call native code from JVM, not how to call JVM from native code.",Java Native Interface ,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
477,"In the JNI framework, native functions are implemented in separate .c or .cpp files. C++ provides a slightly simpler interface with JNI. When the JVM invokes the function, it passes a JNIEnv pointer, a jobject pointer, and any Java arguments declared by the Java method. A JNI function may look like this:JNIEXPORT  void  JNICALL  Java_ClassName_MethodName  ( JNIEnv  * env ,  jobject  obj )  {  /*Implement Native Method Here*/  }The env pointer is a structure that contains the interface to the JVM.  It includes all of the functions necessary to interact with the JVM and to work with Java objects.  Example JNI functions are converting native arrays to/from Java arrays, converting native strings to/from Java strings, instantiating objects, throwing exceptions, etc.  Basically, anything that Java code can do can be done using JNIEnv , albeit with considerably less ease.On Linux and Solaris platforms, if the native code registers itself as a signal handler, it could intercept signals intended for the JVM.  Signal chaining should be used to allow native code to better interoperate with JVM. On Windows platforms, Structured Exception Handling (SEH) may be employed to wrap native code in SEH try/catch blocks so as to capture machine (CPU/FPU) generated software interrupts (such as NULL pointer access violations and divide-by-zero operations), and to handle these situations before the interrupt is propagated back up into the JVM (i.e. Java side code), in all likelihood resulting in an unhandled exception.",Java Native Interface Calling native code from JVM,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
478,"For example, the following converts a Java string to a native string:extern  ""C""  JNIEXPORT  void  JNICALL  Java_ClassName_MethodName  ( JNIEnv  * env ,  jobject  obj ,  jstring  javaString )  {  //Get the native string from javaString  const  char  * nativeString  =  env -> GetStringUTFChars ( javaString ,  0 );  //Do something with the nativeString  //DON'T FORGET THIS LINE!!!  env -> ReleaseStringUTFChars ( javaString ,  nativeString );  }The JNI framework does not provide any automatic garbage collection for non-JVM memory resources allocated by code executing on the native side. Consequently, native side code (such as C, C++, or assembly language) must assume the responsibility for explicitly releasing any such memory resources that it itself acquires.",Java Native Interface C++ code,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
479,"JNIEXPORT  void  JNICALL  Java_ClassName_MethodName  ( JNIEnv  * env ,  jobject  obj ,  jstring  javaString )  {  /*Get the native string from javaString*/  const  char  * nativeString  =  ( * env ) -> GetStringUTFChars ( env ,  javaString ,  0 );  /*Do something with the nativeString*/  /*DON'T FORGET THIS LINE!!!*/  ( * env ) -> ReleaseStringUTFChars ( env ,  javaString ,  nativeString );  }Note that C++ JNI code is syntactically slightly cleaner than C JNI code because like Java, C++ uses object method invocation semantics.  That means that in C, the env parameter is dereferenced using (*env)-> and env has to be explicitly passed to JNIEnv methods. In C++, the env parameter is dereferenced using env-> and the env parameter is implicitly passed as part of the object method invocation semantics.",Java Native Interface C code,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
480,"JNIEXPORT  void  JNICALL  Java_ClassName_MethodName ( JNIEnv  * env ,  jobject  obj ,  jstring  javaString )  {  /*DON'T FORGET THIS LINE!!!*/  JNF_COCOA_ENTER ( env );  /*Get the native string from javaString*/  NSString *  nativeString  =  JNFJavaToNSString ( env ,  javaString );  /*Do something with the nativeString*/  /*DON'T FORGET THIS LINE!!!*/  JNF_COCOA_EXIT ( env );  }JNI also allows direct access to assembly code, without even going through a C bridge.",Java Native Interface Objective-C code,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
481,"Native data types can be mapped to/from Java data types. For compound types such as objects, arrays and strings the native code must explicitly convert the data by calling methods in the JNIEnv . The following table shows the mapping of types between Java (JNI) and native code.In addition, the signature ""L fully-qualified-class;"" would mean the class uniquely specified by that name; e.g., the signature ""Ljava/lang/String;"" refers to the class java.lang.String . Also, prefixing [ to the signature makes the array of that type; for example, [I means the int array type. Finally, a void signature uses the V code.
Here, these types are interchangeable. You can use jint where you normally use an int , and vice-versa, without any typecasting required.However, mapping between Java Strings and arrays to native strings and arrays is different. If you use a jstring in where a char * would be, your code could crash the JVM.JNIEXPORT  void  JNICALL  Java_ClassName_MethodName  ( JNIEnv  * env ,  jobject  obj ,  jstring  javaString )  {  // printf(""%s"", javaString);        // INCORRECT: Could crash VM!  // Correct way: Create and release native string from Java string  const  char  * nativeString  =  ( * env ) -> GetStringUTFChars ( env ,  javaString ,  0 );  printf ( ""%s"" ,  nativeString );  ( * env ) -> ReleaseStringUTFChars ( env ,  javaString ,  nativeString );  }The encoding used for the NewStringUTF , GetStringUTFLength , GetStringUTFChars , ReleaseStringUTFChars , GetStringUTFRegion functions is not standard UTF-8, but modified UTF-8. The null character (U+0000) and codepoints greater than or equal to U+10000 are encoded differently in modified UTF-8. Many programs actually use these functions incorrectly and treat the UTF-8 strings returned or passed into the functions as standard UTF-8 strings instead of modified UTF-8 strings. Programs should use the NewString , GetStringLength , GetStringChars , ReleaseStringChars , GetStringRegion , GetStringCritical , and ReleaseStringCritical functions, which use UTF-16LE encoding on little-endian architectures and UTF-16BE on big-endian architectures, and then use a UTF-16 to standard UTF-8 conversion routine.The code is similar with Java arrays, as illustrated in the example below that takes the sum of all the elements in an array.JNIEXPORT  jint  JNICALL  Java_IntArray_sumArray  ( JNIEnv  * env ,  jobject  obj ,  jintArray  arr )  {  jint  buf [ 10 ];  jint  i ,  sum  =  0 ;  // This line is necessary, since Java arrays are not guaranteed  // to have a continuous memory layout like C arrays.  env -> GetIntArrayRegion ( arr ,  0 ,  10 ,  buf );  for  ( i  =  0 ;  i  <  10 ;  i ++ )  {  sum  +=  buf [ i ];  }  return  sum ;  }Of course, there is much more to it than this.",Java Native Interface Mapping types,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
482,"A JNI environment pointer ( JNIEnv* ) is passed as an argument for each native function mapped to a Java method, allowing for interaction with the JNI environment within the native method. This JNI interface pointer can be stored, but remains valid only in the current thread. Other threads must first call AttachCurrentThread() to attach themselves to the VM and obtain a JNI interface pointer. Once attached, a native thread works like a regular Java thread running within a native method. The native thread remains attached to the VM until it calls DetachCurrentThread() to detach itself.To attach to the current thread and get a JNI interface pointer:JNIEnv *env;
(*g_vm)->AttachCurrentThread (g_vm, (void **) &env, NULL);To detach from the current thread:(*g_vm)->DetachCurrentThread (g_vm);",Java Native Interface JNIEnv*,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
483,"HelloWorld.h/* DO NOT EDIT THIS FILE - it is machine generated */  #include  <jni.h>  /* Header for class HelloWorld */  #ifndef _Included_HelloWorld  #define _Included_HelloWorld  #ifdef __cplusplus  extern  ""C""  {  #endif  /*  * Class:     HelloWorld  * Method:    print  * Signature: ()V  */  JNIEXPORT  void  JNICALL  Java_HelloWorld_print  ( JNIEnv  * ,  jobject );  #ifdef __cplusplus  }  #endif  #endiflibHelloWorld.c#include  <stdio.h>  #include  ""HelloWorld.h""  JNIEXPORT  void  JNICALL  Java_HelloWorld_print ( JNIEnv  * env ,  jobject  obj )  {  printf ( ""Hello World! \n "" );  return ;  }make.sh#!/bin/sh  # openbsd 4.9  # gcc 4.2.1  # openjdk 1.7.0  JAVA_HOME = $( readlink -f /usr/bin/javac | sed ""s:bin/javac::"" )  export  LD_LIBRARY_PATH = $LD_LIBRARY_PATH :.
javac HelloWorld.java
javah HelloWorld
gcc -I ${ JAVA_HOME } /include -shared libHelloWorld.c -o libHelloWorld.so
java HelloWorld",Java Native Interface HelloWorld,https://en.wikibooks.org//wiki/Java_Programming/Java_Native_Interface
484,"You can use Runtime.exec() method to invoke a program from within a running Java application. Runtime.exec() also allows you to perform operations related to the program, such as control the program's standard input and output, wait until it completes execution, and get its exit status.Here's a simple C application that illustrates these features. This C program will be called from Java:#include  <stdio.h>  int  main ()  {  printf ( ""testing \n "" );  return  0 ;  }This application writes a string ""testing"" to standard output, and then terminates with an exit status of 0.
To execute this simple program within a Java application, compile the C application:Then invoke the C program using this Java code:The demo calls a method runCommand to actually run the program.This method hooks an input stream to the program's output stream, so that it can read the program's output, and save it into a list of strings.",Invoking C ,https://en.wikibooks.org//wiki/Java_Programming/Invoking_C
485,"Java Byte Code is the language to which Java source is compiled and the Java Virtual Machine understands. Unlike compiled languages that have to be specifically compiled for each different type of computers, a Java program only needs to be converted to byte code once, after which it can run on any platform for which a Java Virtual Machine exists.Bytecode is the compiled format for Java programs. Once a Java program has been converted to bytecode, it can be transferred across a network and executed by Java Virtual Machine (JVM). Bytecode files generally have a .class extension. 
It is not normally necessary for a Java programmer to know byte code, but it can be useful.Contents   1  Other Languages  2  Example  3  Example 2  4  The Java bytecodes  5  References  6  External Links",Byte Code ,https://en.wikibooks.org//wiki/Java_Programming/Byte_Code
486,"There are a number of exciting new languages being created that also compile to Java byte code, such as Groovy .GNAT  The GNU Ada-Compiler, is capable of compiling Ada into Java-style bytecode.  ftp://cs.nyu.edu/pub/gnatJPython  Compiles Python to Java-style bytecode.  http://www.jpython.org/Kawa  Compiles Scheme to Java-style bytecode.  http://www.gnu.org/software/kawa/",Byte Code Other Languages,https://en.wikibooks.org//wiki/Java_Programming/Byte_Code
487,"Consider the following Java code.outer :  for  ( int  i  =  2 ;  i  <  1000 ;  i ++)  {  for  ( int  j  =  2 ;  j  <  i ;  j ++)  {  if  ( i  %  j  ==  0 )  continue  outer ;  }  System . out . println  ( i );  }A Java compiler might translate the Java code above into byte code as follows, assuming the above was put in a method:Code:
  0:   iconst_2
  1:   istore_1
  2:   iload_1
  3:   sipush  1000
  6:   if_icmpge       44
  9:   iconst_2
  10:  istore_2
  11:  iload_2
  12:  iload_1
  13:  if_icmpge       31
  16:  iload_1
  17:  iload_2
  18:  irem             # remainder
  19:  ifne    25
  22:  goto    38
  25:  iinc    2, 1
  28:  goto    11
  31:  getstatic       #84; //Field java/lang/System.out:Ljava/io/PrintStream;
  34:  iload_1
  35:  invokevirtual   #85; //Method java/io/PrintStream.println:(I)V
  38:  iinc    1, 1
  41:  goto    2
  44:  return",Byte Code Example,https://en.wikibooks.org//wiki/Java_Programming/Byte_Code
488,"As an example we can write a simple Foo.java source:public  class  Foo  {  public  static  void  main ( final  String []  args )  {  System . out . println ( ""This is a simple example of decompilation using javap"" );  a ();  b ();  }  public  static  void  a ()  {  System . out . println ( ""Now we are calling a function..."" );  }  public  static  void  b ()  {  System . out . println ( ""...and now we are calling b"" );  }  }Compile it and then move Foo.java to another directory or delete it if you wish. What can we do with javap and Foo.class?$javap Fooproduces this result:Compiled from ""Foo.java""
public class Foo extends java.lang.Object {
    public Foo();
    public static void main(java.lang.String[]);
    public static void a();
    public static void b();
}As you can see the javac compiler doesn't strip any (public) variable name from the .class file. As a result the names of the functions, their parameters and types of return are exposed. (This is necessary in order for other classes to access them.)Let's do a bit more, try:$javap -c FooCompiled from ""Foo.java""
public class Foo extends java.lang.Object{
public Foo();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object.""<init>"":()V
   4:   return

public static void main(java.lang.String[]);
  Code:
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc             #3; //String This is a simple example of decompilation using javap
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   invokestatic    #5; //Method a:()V
   11:  invokestatic    #6; //Method b:()V
   14:  return

public static void a();
  Code:
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc             #7; //String Now we are calling a function...
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   return

public static void b();
  Code:
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc             #8; //String ...and now we are calling b
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   return

}",Byte Code Example 2,https://en.wikibooks.org//wiki/Java_Programming/Byte_Code
489,"See Oracle's Java Virtual Machine Specification [1] for more detailed descriptionsThe manipulation of the operand stack is notated as [before][after], where [before] is the stack before the instruction is executed and [after] is the stack after the instruction is executed. A stack with the element 'b' on the top and element 'a' just after the top element is denoted 'a,b'.",Byte Code The Java bytecodes,https://en.wikibooks.org//wiki/Java_Programming/Byte_Code
490,  Oracle's Java Virtual Machine Specification,Byte Code References,https://en.wikibooks.org//wiki/Java_Programming/Byte_Code
491,Java Certification Preparation Guides  Java Certification Mock Exams 500+ questions with exam simulator (this is the older 1.4 version of the exam)  Java Language Specification .  Thinking in Java  Java 8 SDK Documentation  Java 5 SDK Documentation in CHM Format  Java 8 API Documentation  The Java Tutorial  Sun Developer Network New to Java Center  A simple Java Tutorial  Two Semesters of College-Level Java Lectures--Free  Java Lessons - Interactive Java programming tutorials based on examples  Java Tutorials for Kids and Adults,Links External References,https://en.wikibooks.org//wiki/Java_Programming/Links
492,This is a glossary of the book.,Glossary ,https://en.wikibooks.org//wiki/Java_Programming/Glossary
493,annotation  A means of attaching metadata to methods and classes directly in the source code.,Glossary A,https://en.wikibooks.org//wiki/Java_Programming/Glossary
494,byte code  Code interpreted by the Java virtual machine; the target code of Java compilation.,Glossary B,https://en.wikibooks.org//wiki/Java_Programming/Glossary
495,"generics  A means of passing a data type as an argument of another type, such as Vector<JButton>;",Glossary G,https://en.wikibooks.org//wiki/Java_Programming/Glossary
496,"primitive type  One of the types that do not require allocation on stack, such as int, byte, or long.",Glossary P,https://en.wikibooks.org//wiki/Java_Programming/Glossary
